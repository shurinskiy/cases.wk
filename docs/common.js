/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/common.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/air-datepicker/src/js/air-datepicker.js":
/*!**************************************************************!*\
  !*** ./node_modules/air-datepicker/src/js/air-datepicker.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./datepicker */ \"./node_modules/air-datepicker/src/js/datepicker.js\");\r\n__webpack_require__(/*! ./body */ \"./node_modules/air-datepicker/src/js/body.js\");\r\n__webpack_require__(/*! ./navigation */ \"./node_modules/air-datepicker/src/js/navigation.js\");\r\n__webpack_require__(/*! ./timepicker */ \"./node_modules/air-datepicker/src/js/timepicker.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWlyLWRhdGVwaWNrZXIvc3JjL2pzL2Fpci1kYXRlcGlja2VyLmpzPzc5NGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsbUJBQU8sQ0FBQyx3RUFBYztBQUN0QixtQkFBTyxDQUFDLDREQUFRO0FBQ2hCLG1CQUFPLENBQUMsd0VBQWM7QUFDdEIsbUJBQU8sQ0FBQyx3RUFBYyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9haXItZGF0ZXBpY2tlci9zcmMvanMvYWlyLWRhdGVwaWNrZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL2RhdGVwaWNrZXInKTtcclxucmVxdWlyZSgnLi9ib2R5Jyk7XHJcbnJlcXVpcmUoJy4vbmF2aWdhdGlvbicpO1xyXG5yZXF1aXJlKCcuL3RpbWVwaWNrZXInKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/air-datepicker/src/js/air-datepicker.js\n");

/***/ }),

/***/ "./node_modules/air-datepicker/src/js/body.js":
/*!****************************************************!*\
  !*** ./node_modules/air-datepicker/src/js/body.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval(";(function () {\r\n    var templates = {\r\n        days:'' +\r\n        '<div class=\"datepicker--days datepicker--body\">' +\r\n        '<div class=\"datepicker--days-names\"></div>' +\r\n        '<div class=\"datepicker--cells datepicker--cells-days\"></div>' +\r\n        '</div>',\r\n        months: '' +\r\n        '<div class=\"datepicker--months datepicker--body\">' +\r\n        '<div class=\"datepicker--cells datepicker--cells-months\"></div>' +\r\n        '</div>',\r\n        years: '' +\r\n        '<div class=\"datepicker--years datepicker--body\">' +\r\n        '<div class=\"datepicker--cells datepicker--cells-years\"></div>' +\r\n        '</div>'\r\n        },\r\n        datepicker = $.fn.datepicker,\r\n        dp = datepicker.Constructor;\r\n\r\n    datepicker.Body = function (d, type, opts) {\r\n        this.d = d;\r\n        this.type = type;\r\n        this.opts = opts;\r\n        this.$el = $('');\r\n\r\n        if (this.opts.onlyTimepicker) return;\r\n        this.init();\r\n    };\r\n\r\n    datepicker.Body.prototype = {\r\n        init: function () {\r\n            this._buildBaseHtml();\r\n            this._render();\r\n\r\n            this._bindEvents();\r\n        },\r\n\r\n        _bindEvents: function () {\r\n            this.$el.on('click', '.datepicker--cell', $.proxy(this._onClickCell, this));\r\n        },\r\n\r\n        _buildBaseHtml: function () {\r\n            this.$el = $(templates[this.type]).appendTo(this.d.$content);\r\n            this.$names = $('.datepicker--days-names', this.$el);\r\n            this.$cells = $('.datepicker--cells', this.$el);\r\n        },\r\n\r\n        _getDayNamesHtml: function (firstDay, curDay, html, i) {\r\n            curDay = curDay != undefined ? curDay : firstDay;\r\n            html = html ? html : '';\r\n            i = i != undefined ? i : 0;\r\n\r\n            if (i > 7) return html;\r\n            if (curDay == 7) return this._getDayNamesHtml(firstDay, 0, html, ++i);\r\n\r\n            html += '<div class=\"datepicker--day-name' + (this.d.isWeekend(curDay) ? \" -weekend-\" : \"\") + '\">' + this.d.loc.daysMin[curDay] + '</div>';\r\n\r\n            return this._getDayNamesHtml(firstDay, ++curDay, html, ++i);\r\n        },\r\n\r\n        _getCellContents: function (date, type) {\r\n            var classes = \"datepicker--cell datepicker--cell-\" + type,\r\n                currentDate = new Date(),\r\n                parent = this.d,\r\n                minRange = dp.resetTime(parent.minRange),\r\n                maxRange = dp.resetTime(parent.maxRange),\r\n                opts = parent.opts,\r\n                d = dp.getParsedDate(date),\r\n                render = {},\r\n                html = d.date;\r\n\r\n            switch (type) {\r\n                case 'day':\r\n                    if (parent.isWeekend(d.day)) classes += \" -weekend-\";\r\n                    if (d.month != this.d.parsedDate.month) {\r\n                        classes += \" -other-month-\";\r\n                        if (!opts.selectOtherMonths) {\r\n                            classes += \" -disabled-\";\r\n                        }\r\n                        if (!opts.showOtherMonths) html = '';\r\n                    }\r\n                    break;\r\n                case 'month':\r\n                    html = parent.loc[parent.opts.monthsField][d.month];\r\n                    break;\r\n                case 'year':\r\n                    var decade = parent.curDecade;\r\n                    html = d.year;\r\n                    if (d.year < decade[0] || d.year > decade[1]) {\r\n                        classes += ' -other-decade-';\r\n                        if (!opts.selectOtherYears) {\r\n                            classes += \" -disabled-\";\r\n                        }\r\n                        if (!opts.showOtherYears) html = '';\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            if (opts.onRenderCell) {\r\n                render = opts.onRenderCell(date, type) || {};\r\n                html = render.html ? render.html : html;\r\n                classes += render.classes ? ' ' + render.classes : '';\r\n            }\r\n\r\n            if (opts.range) {\r\n                if (dp.isSame(minRange, date, type)) classes += ' -range-from-';\r\n                if (dp.isSame(maxRange, date, type)) classes += ' -range-to-';\r\n\r\n                if (parent.selectedDates.length == 1 && parent.focused) {\r\n                    if (\r\n                        (dp.bigger(minRange, date) && dp.less(parent.focused, date)) ||\r\n                        (dp.less(maxRange, date) && dp.bigger(parent.focused, date)))\r\n                    {\r\n                        classes += ' -in-range-'\r\n                    }\r\n\r\n                    if (dp.less(maxRange, date) && dp.isSame(parent.focused, date)) {\r\n                        classes += ' -range-from-'\r\n                    }\r\n                    if (dp.bigger(minRange, date) && dp.isSame(parent.focused, date)) {\r\n                        classes += ' -range-to-'\r\n                    }\r\n\r\n                } else if (parent.selectedDates.length == 2) {\r\n                    if (dp.bigger(minRange, date) && dp.less(maxRange, date)) {\r\n                        classes += ' -in-range-'\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            if (dp.isSame(currentDate, date, type)) classes += ' -current-';\r\n            if (parent.focused && dp.isSame(date, parent.focused, type)) classes += ' -focus-';\r\n            if (parent._isSelected(date, type)) classes += ' -selected-';\r\n            if (!parent._isInRange(date, type) || render.disabled) classes += ' -disabled-';\r\n\r\n            return {\r\n                html: html,\r\n                classes: classes\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Calculates days number to render. Generates days html and returns it.\r\n         * @param {object} date - Date object\r\n         * @returns {string}\r\n         * @private\r\n         */\r\n        _getDaysHtml: function (date) {\r\n            var totalMonthDays = dp.getDaysCount(date),\r\n                firstMonthDay = new Date(date.getFullYear(), date.getMonth(), 1).getDay(),\r\n                lastMonthDay = new Date(date.getFullYear(), date.getMonth(), totalMonthDays).getDay(),\r\n                daysFromPevMonth = firstMonthDay - this.d.loc.firstDay,\r\n                daysFromNextMonth = 6 - lastMonthDay + this.d.loc.firstDay;\r\n\r\n            daysFromPevMonth = daysFromPevMonth < 0 ? daysFromPevMonth + 7 : daysFromPevMonth;\r\n            daysFromNextMonth = daysFromNextMonth > 6 ? daysFromNextMonth - 7 : daysFromNextMonth;\r\n\r\n            var startDayIndex = -daysFromPevMonth + 1,\r\n                m, y,\r\n                html = '';\r\n\r\n            for (var i = startDayIndex, max = totalMonthDays + daysFromNextMonth; i <= max; i++) {\r\n                y = date.getFullYear();\r\n                m = date.getMonth();\r\n\r\n                html += this._getDayHtml(new Date(y, m, i))\r\n            }\r\n\r\n            return html;\r\n        },\r\n\r\n        _getDayHtml: function (date) {\r\n           var content = this._getCellContents(date, 'day');\r\n\r\n            return '<div class=\"' + content.classes + '\" ' +\r\n                'data-date=\"' + date.getDate() + '\" ' +\r\n                'data-month=\"' + date.getMonth() + '\" ' +\r\n                'data-year=\"' + date.getFullYear() + '\">' + content.html + '</div>';\r\n        },\r\n\r\n        /**\r\n         * Generates months html\r\n         * @param {object} date - date instance\r\n         * @returns {string}\r\n         * @private\r\n         */\r\n        _getMonthsHtml: function (date) {\r\n            var html = '',\r\n                d = dp.getParsedDate(date),\r\n                i = 0;\r\n\r\n            while(i < 12) {\r\n                html += this._getMonthHtml(new Date(d.year, i));\r\n                i++\r\n            }\r\n\r\n            return html;\r\n        },\r\n\r\n        _getMonthHtml: function (date) {\r\n            var content = this._getCellContents(date, 'month');\r\n\r\n            return '<div class=\"' + content.classes + '\" data-month=\"' + date.getMonth() + '\">' + content.html + '</div>'\r\n        },\r\n\r\n        _getYearsHtml: function (date) {\r\n            var d = dp.getParsedDate(date),\r\n                decade = dp.getDecade(date),\r\n                firstYear = decade[0] - 1,\r\n                html = '',\r\n                i = firstYear;\r\n\r\n            for (i; i <= decade[1] + 1; i++) {\r\n                html += this._getYearHtml(new Date(i , 0));\r\n            }\r\n\r\n            return html;\r\n        },\r\n\r\n        _getYearHtml: function (date) {\r\n            var content = this._getCellContents(date, 'year');\r\n\r\n            return '<div class=\"' + content.classes + '\" data-year=\"' + date.getFullYear() + '\">' + content.html + '</div>'\r\n        },\r\n\r\n        _renderTypes: {\r\n            days: function () {\r\n                var dayNames = this._getDayNamesHtml(this.d.loc.firstDay),\r\n                    days = this._getDaysHtml(this.d.currentDate);\r\n\r\n                this.$cells.html(days);\r\n                this.$names.html(dayNames)\r\n            },\r\n            months: function () {\r\n                var html = this._getMonthsHtml(this.d.currentDate);\r\n\r\n                this.$cells.html(html)\r\n            },\r\n            years: function () {\r\n                var html = this._getYearsHtml(this.d.currentDate);\r\n\r\n                this.$cells.html(html)\r\n            }\r\n        },\r\n\r\n        _render: function () {\r\n            if (this.opts.onlyTimepicker) return;\r\n            this._renderTypes[this.type].bind(this)();\r\n        },\r\n\r\n        _update: function () {\r\n            var $cells = $('.datepicker--cell', this.$cells),\r\n                _this = this,\r\n                classes,\r\n                $cell,\r\n                date;\r\n            $cells.each(function (cell, i) {\r\n                $cell = $(this);\r\n                date = _this.d._getDateFromCell($(this));\r\n                classes = _this._getCellContents(date, _this.d.cellType);\r\n                $cell.attr('class',classes.classes)\r\n            });\r\n        },\r\n\r\n        show: function () {\r\n            if (this.opts.onlyTimepicker) return;\r\n            this.$el.addClass('active');\r\n            this.acitve = true;\r\n        },\r\n\r\n        hide: function () {\r\n            this.$el.removeClass('active');\r\n            this.active = false;\r\n        },\r\n\r\n        //  Events\r\n        // -------------------------------------------------\r\n\r\n        _handleClick: function (el) {\r\n            var date = el.data('date') || 1,\r\n                month = el.data('month') || 0,\r\n                year = el.data('year') || this.d.parsedDate.year,\r\n                dp = this.d;\r\n            // Change view if min view does not reach yet\r\n            if (dp.view != this.opts.minView) {\r\n                dp.down(new Date(year, month, date));\r\n                return;\r\n            }\r\n            // Select date if min view is reached\r\n            var selectedDate = new Date(year, month, date),\r\n                alreadySelected = this.d._isSelected(selectedDate, this.d.cellType);\r\n\r\n            if (!alreadySelected) {\r\n                dp._trigger('clickCell', selectedDate);\r\n                return;\r\n            }\r\n\r\n            dp._handleAlreadySelectedDates.bind(dp, alreadySelected, selectedDate)();\r\n\r\n        },\r\n\r\n        _onClickCell: function (e) {\r\n            var $el = $(e.target).closest('.datepicker--cell');\r\n\r\n            if ($el.hasClass('-disabled-')) return;\r\n\r\n            this._handleClick.bind(this)($el);\r\n        }\r\n    };\r\n})();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWlyLWRhdGVwaWNrZXIvc3JjL2pzL2JvZHkuanM/YjU5ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRkFBaUYsVUFBVTtBQUMzRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Fpci1kYXRlcGlja2VyL3NyYy9qcy9ib2R5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdGVtcGxhdGVzID0ge1xyXG4gICAgICAgIGRheXM6JycgK1xyXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci0tZGF5cyBkYXRlcGlja2VyLS1ib2R5XCI+JyArXHJcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLS1kYXlzLW5hbWVzXCI+PC9kaXY+JyArXHJcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLS1jZWxscyBkYXRlcGlja2VyLS1jZWxscy1kYXlzXCI+PC9kaXY+JyArXHJcbiAgICAgICAgJzwvZGl2PicsXHJcbiAgICAgICAgbW9udGhzOiAnJyArXHJcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLS1tb250aHMgZGF0ZXBpY2tlci0tYm9keVwiPicgK1xyXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci0tY2VsbHMgZGF0ZXBpY2tlci0tY2VsbHMtbW9udGhzXCI+PC9kaXY+JyArXHJcbiAgICAgICAgJzwvZGl2PicsXHJcbiAgICAgICAgeWVhcnM6ICcnICtcclxuICAgICAgICAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItLXllYXJzIGRhdGVwaWNrZXItLWJvZHlcIj4nICtcclxuICAgICAgICAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItLWNlbGxzIGRhdGVwaWNrZXItLWNlbGxzLXllYXJzXCI+PC9kaXY+JyArXHJcbiAgICAgICAgJzwvZGl2PidcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRhdGVwaWNrZXIgPSAkLmZuLmRhdGVwaWNrZXIsXHJcbiAgICAgICAgZHAgPSBkYXRlcGlja2VyLkNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGRhdGVwaWNrZXIuQm9keSA9IGZ1bmN0aW9uIChkLCB0eXBlLCBvcHRzKSB7XHJcbiAgICAgICAgdGhpcy5kID0gZDtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XHJcbiAgICAgICAgdGhpcy4kZWwgPSAkKCcnKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3B0cy5vbmx5VGltZXBpY2tlcikgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuaW5pdCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBkYXRlcGlja2VyLkJvZHkucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYnVpbGRCYXNlSHRtbCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXIoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLiRlbC5vbignY2xpY2snLCAnLmRhdGVwaWNrZXItLWNlbGwnLCAkLnByb3h5KHRoaXMuX29uQ2xpY2tDZWxsLCB0aGlzKSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2J1aWxkQmFzZUh0bWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy4kZWwgPSAkKHRlbXBsYXRlc1t0aGlzLnR5cGVdKS5hcHBlbmRUbyh0aGlzLmQuJGNvbnRlbnQpO1xyXG4gICAgICAgICAgICB0aGlzLiRuYW1lcyA9ICQoJy5kYXRlcGlja2VyLS1kYXlzLW5hbWVzJywgdGhpcy4kZWwpO1xyXG4gICAgICAgICAgICB0aGlzLiRjZWxscyA9ICQoJy5kYXRlcGlja2VyLS1jZWxscycsIHRoaXMuJGVsKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0RGF5TmFtZXNIdG1sOiBmdW5jdGlvbiAoZmlyc3REYXksIGN1ckRheSwgaHRtbCwgaSkge1xyXG4gICAgICAgICAgICBjdXJEYXkgPSBjdXJEYXkgIT0gdW5kZWZpbmVkID8gY3VyRGF5IDogZmlyc3REYXk7XHJcbiAgICAgICAgICAgIGh0bWwgPSBodG1sID8gaHRtbCA6ICcnO1xyXG4gICAgICAgICAgICBpID0gaSAhPSB1bmRlZmluZWQgPyBpIDogMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChpID4gNykgcmV0dXJuIGh0bWw7XHJcbiAgICAgICAgICAgIGlmIChjdXJEYXkgPT0gNykgcmV0dXJuIHRoaXMuX2dldERheU5hbWVzSHRtbChmaXJzdERheSwgMCwgaHRtbCwgKytpKTtcclxuXHJcbiAgICAgICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLS1kYXktbmFtZScgKyAodGhpcy5kLmlzV2Vla2VuZChjdXJEYXkpID8gXCIgLXdlZWtlbmQtXCIgOiBcIlwiKSArICdcIj4nICsgdGhpcy5kLmxvYy5kYXlzTWluW2N1ckRheV0gKyAnPC9kaXY+JztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXREYXlOYW1lc0h0bWwoZmlyc3REYXksICsrY3VyRGF5LCBodG1sLCArK2kpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRDZWxsQ29udGVudHM6IGZ1bmN0aW9uIChkYXRlLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBjbGFzc2VzID0gXCJkYXRlcGlja2VyLS1jZWxsIGRhdGVwaWNrZXItLWNlbGwtXCIgKyB0eXBlLFxyXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUgPSBuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5kLFxyXG4gICAgICAgICAgICAgICAgbWluUmFuZ2UgPSBkcC5yZXNldFRpbWUocGFyZW50Lm1pblJhbmdlKSxcclxuICAgICAgICAgICAgICAgIG1heFJhbmdlID0gZHAucmVzZXRUaW1lKHBhcmVudC5tYXhSYW5nZSksXHJcbiAgICAgICAgICAgICAgICBvcHRzID0gcGFyZW50Lm9wdHMsXHJcbiAgICAgICAgICAgICAgICBkID0gZHAuZ2V0UGFyc2VkRGF0ZShkYXRlKSxcclxuICAgICAgICAgICAgICAgIHJlbmRlciA9IHt9LFxyXG4gICAgICAgICAgICAgICAgaHRtbCA9IGQuZGF0ZTtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LmlzV2Vla2VuZChkLmRheSkpIGNsYXNzZXMgKz0gXCIgLXdlZWtlbmQtXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQubW9udGggIT0gdGhpcy5kLnBhcnNlZERhdGUubW9udGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NlcyArPSBcIiAtb3RoZXItbW9udGgtXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0cy5zZWxlY3RPdGhlck1vbnRocykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NlcyArPSBcIiAtZGlzYWJsZWQtXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRzLnNob3dPdGhlck1vbnRocykgaHRtbCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcclxuICAgICAgICAgICAgICAgICAgICBodG1sID0gcGFyZW50LmxvY1twYXJlbnQub3B0cy5tb250aHNGaWVsZF1bZC5tb250aF07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd5ZWFyJzpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjYWRlID0gcGFyZW50LmN1ckRlY2FkZTtcclxuICAgICAgICAgICAgICAgICAgICBodG1sID0gZC55ZWFyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkLnllYXIgPCBkZWNhZGVbMF0gfHwgZC55ZWFyID4gZGVjYWRlWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMgKz0gJyAtb3RoZXItZGVjYWRlLSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0cy5zZWxlY3RPdGhlclllYXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzICs9IFwiIC1kaXNhYmxlZC1cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdHMuc2hvd090aGVyWWVhcnMpIGh0bWwgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRzLm9uUmVuZGVyQ2VsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyID0gb3B0cy5vblJlbmRlckNlbGwoZGF0ZSwgdHlwZSkgfHwge307XHJcbiAgICAgICAgICAgICAgICBodG1sID0gcmVuZGVyLmh0bWwgPyByZW5kZXIuaHRtbCA6IGh0bWw7XHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzICs9IHJlbmRlci5jbGFzc2VzID8gJyAnICsgcmVuZGVyLmNsYXNzZXMgOiAnJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdHMucmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkcC5pc1NhbWUobWluUmFuZ2UsIGRhdGUsIHR5cGUpKSBjbGFzc2VzICs9ICcgLXJhbmdlLWZyb20tJztcclxuICAgICAgICAgICAgICAgIGlmIChkcC5pc1NhbWUobWF4UmFuZ2UsIGRhdGUsIHR5cGUpKSBjbGFzc2VzICs9ICcgLXJhbmdlLXRvLSc7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PSAxICYmIHBhcmVudC5mb2N1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZHAuYmlnZ2VyKG1pblJhbmdlLCBkYXRlKSAmJiBkcC5sZXNzKHBhcmVudC5mb2N1c2VkLCBkYXRlKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGRwLmxlc3MobWF4UmFuZ2UsIGRhdGUpICYmIGRwLmJpZ2dlcihwYXJlbnQuZm9jdXNlZCwgZGF0ZSkpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NlcyArPSAnIC1pbi1yYW5nZS0nXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZHAubGVzcyhtYXhSYW5nZSwgZGF0ZSkgJiYgZHAuaXNTYW1lKHBhcmVudC5mb2N1c2VkLCBkYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzICs9ICcgLXJhbmdlLWZyb20tJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZHAuYmlnZ2VyKG1pblJhbmdlLCBkYXRlKSAmJiBkcC5pc1NhbWUocGFyZW50LmZvY3VzZWQsIGRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMgKz0gJyAtcmFuZ2UtdG8tJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudC5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRwLmJpZ2dlcihtaW5SYW5nZSwgZGF0ZSkgJiYgZHAubGVzcyhtYXhSYW5nZSwgZGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NlcyArPSAnIC1pbi1yYW5nZS0nXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgaWYgKGRwLmlzU2FtZShjdXJyZW50RGF0ZSwgZGF0ZSwgdHlwZSkpIGNsYXNzZXMgKz0gJyAtY3VycmVudC0nO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50LmZvY3VzZWQgJiYgZHAuaXNTYW1lKGRhdGUsIHBhcmVudC5mb2N1c2VkLCB0eXBlKSkgY2xhc3NlcyArPSAnIC1mb2N1cy0nO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50Ll9pc1NlbGVjdGVkKGRhdGUsIHR5cGUpKSBjbGFzc2VzICs9ICcgLXNlbGVjdGVkLSc7XHJcbiAgICAgICAgICAgIGlmICghcGFyZW50Ll9pc0luUmFuZ2UoZGF0ZSwgdHlwZSkgfHwgcmVuZGVyLmRpc2FibGVkKSBjbGFzc2VzICs9ICcgLWRpc2FibGVkLSc7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgaHRtbDogaHRtbCxcclxuICAgICAgICAgICAgICAgIGNsYXNzZXM6IGNsYXNzZXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgZGF5cyBudW1iZXIgdG8gcmVuZGVyLiBHZW5lcmF0ZXMgZGF5cyBodG1sIGFuZCByZXR1cm5zIGl0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRlIC0gRGF0ZSBvYmplY3RcclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2dldERheXNIdG1sOiBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgdG90YWxNb250aERheXMgPSBkcC5nZXREYXlzQ291bnQoZGF0ZSksXHJcbiAgICAgICAgICAgICAgICBmaXJzdE1vbnRoRGF5ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIDEpLmdldERheSgpLFxyXG4gICAgICAgICAgICAgICAgbGFzdE1vbnRoRGF5ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIHRvdGFsTW9udGhEYXlzKS5nZXREYXkoKSxcclxuICAgICAgICAgICAgICAgIGRheXNGcm9tUGV2TW9udGggPSBmaXJzdE1vbnRoRGF5IC0gdGhpcy5kLmxvYy5maXJzdERheSxcclxuICAgICAgICAgICAgICAgIGRheXNGcm9tTmV4dE1vbnRoID0gNiAtIGxhc3RNb250aERheSArIHRoaXMuZC5sb2MuZmlyc3REYXk7XHJcblxyXG4gICAgICAgICAgICBkYXlzRnJvbVBldk1vbnRoID0gZGF5c0Zyb21QZXZNb250aCA8IDAgPyBkYXlzRnJvbVBldk1vbnRoICsgNyA6IGRheXNGcm9tUGV2TW9udGg7XHJcbiAgICAgICAgICAgIGRheXNGcm9tTmV4dE1vbnRoID0gZGF5c0Zyb21OZXh0TW9udGggPiA2ID8gZGF5c0Zyb21OZXh0TW9udGggLSA3IDogZGF5c0Zyb21OZXh0TW9udGg7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RhcnREYXlJbmRleCA9IC1kYXlzRnJvbVBldk1vbnRoICsgMSxcclxuICAgICAgICAgICAgICAgIG0sIHksXHJcbiAgICAgICAgICAgICAgICBodG1sID0gJyc7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnREYXlJbmRleCwgbWF4ID0gdG90YWxNb250aERheXMgKyBkYXlzRnJvbU5leHRNb250aDsgaSA8PSBtYXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgeSA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICAgICAgICAgIG0gPSBkYXRlLmdldE1vbnRoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaHRtbCArPSB0aGlzLl9nZXREYXlIdG1sKG5ldyBEYXRlKHksIG0sIGkpKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaHRtbDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0RGF5SHRtbDogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuX2dldENlbGxDb250ZW50cyhkYXRlLCAnZGF5Jyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCInICsgY29udGVudC5jbGFzc2VzICsgJ1wiICcgK1xyXG4gICAgICAgICAgICAgICAgJ2RhdGEtZGF0ZT1cIicgKyBkYXRlLmdldERhdGUoKSArICdcIiAnICtcclxuICAgICAgICAgICAgICAgICdkYXRhLW1vbnRoPVwiJyArIGRhdGUuZ2V0TW9udGgoKSArICdcIiAnICtcclxuICAgICAgICAgICAgICAgICdkYXRhLXllYXI9XCInICsgZGF0ZS5nZXRGdWxsWWVhcigpICsgJ1wiPicgKyBjb250ZW50Lmh0bWwgKyAnPC9kaXY+JztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZW5lcmF0ZXMgbW9udGhzIGh0bWxcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0ZSAtIGRhdGUgaW5zdGFuY2VcclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2dldE1vbnRoc0h0bWw6IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgICAgIHZhciBodG1sID0gJycsXHJcbiAgICAgICAgICAgICAgICBkID0gZHAuZ2V0UGFyc2VkRGF0ZShkYXRlKSxcclxuICAgICAgICAgICAgICAgIGkgPSAwO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUoaSA8IDEyKSB7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9IHRoaXMuX2dldE1vbnRoSHRtbChuZXcgRGF0ZShkLnllYXIsIGkpKTtcclxuICAgICAgICAgICAgICAgIGkrK1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaHRtbDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0TW9udGhIdG1sOiBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuX2dldENlbGxDb250ZW50cyhkYXRlLCAnbW9udGgnKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAnPGRpdiBjbGFzcz1cIicgKyBjb250ZW50LmNsYXNzZXMgKyAnXCIgZGF0YS1tb250aD1cIicgKyBkYXRlLmdldE1vbnRoKCkgKyAnXCI+JyArIGNvbnRlbnQuaHRtbCArICc8L2Rpdj4nXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldFllYXJzSHRtbDogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAgICAgdmFyIGQgPSBkcC5nZXRQYXJzZWREYXRlKGRhdGUpLFxyXG4gICAgICAgICAgICAgICAgZGVjYWRlID0gZHAuZ2V0RGVjYWRlKGRhdGUpLFxyXG4gICAgICAgICAgICAgICAgZmlyc3RZZWFyID0gZGVjYWRlWzBdIC0gMSxcclxuICAgICAgICAgICAgICAgIGh0bWwgPSAnJyxcclxuICAgICAgICAgICAgICAgIGkgPSBmaXJzdFllYXI7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGk7IGkgPD0gZGVjYWRlWzFdICsgMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9IHRoaXMuX2dldFllYXJIdG1sKG5ldyBEYXRlKGkgLCAwKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBodG1sO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRZZWFySHRtbDogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLl9nZXRDZWxsQ29udGVudHMoZGF0ZSwgJ3llYXInKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAnPGRpdiBjbGFzcz1cIicgKyBjb250ZW50LmNsYXNzZXMgKyAnXCIgZGF0YS15ZWFyPVwiJyArIGRhdGUuZ2V0RnVsbFllYXIoKSArICdcIj4nICsgY29udGVudC5odG1sICsgJzwvZGl2PidcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfcmVuZGVyVHlwZXM6IHtcclxuICAgICAgICAgICAgZGF5czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRheU5hbWVzID0gdGhpcy5fZ2V0RGF5TmFtZXNIdG1sKHRoaXMuZC5sb2MuZmlyc3REYXkpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRheXMgPSB0aGlzLl9nZXREYXlzSHRtbCh0aGlzLmQuY3VycmVudERhdGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuJGNlbGxzLmh0bWwoZGF5cyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRuYW1lcy5odG1sKGRheU5hbWVzKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtb250aHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBodG1sID0gdGhpcy5fZ2V0TW9udGhzSHRtbCh0aGlzLmQuY3VycmVudERhdGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuJGNlbGxzLmh0bWwoaHRtbClcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgeWVhcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBodG1sID0gdGhpcy5fZ2V0WWVhcnNIdG1sKHRoaXMuZC5jdXJyZW50RGF0ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy4kY2VsbHMuaHRtbChodG1sKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3JlbmRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLm9ubHlUaW1lcGlja2VyKSByZXR1cm47XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclR5cGVzW3RoaXMudHlwZV0uYmluZCh0aGlzKSgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyICRjZWxscyA9ICQoJy5kYXRlcGlja2VyLS1jZWxsJywgdGhpcy4kY2VsbHMpLFxyXG4gICAgICAgICAgICAgICAgX3RoaXMgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgY2xhc3NlcyxcclxuICAgICAgICAgICAgICAgICRjZWxsLFxyXG4gICAgICAgICAgICAgICAgZGF0ZTtcclxuICAgICAgICAgICAgJGNlbGxzLmVhY2goZnVuY3Rpb24gKGNlbGwsIGkpIHtcclxuICAgICAgICAgICAgICAgICRjZWxsID0gJCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGRhdGUgPSBfdGhpcy5kLl9nZXREYXRlRnJvbUNlbGwoJCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzID0gX3RoaXMuX2dldENlbGxDb250ZW50cyhkYXRlLCBfdGhpcy5kLmNlbGxUeXBlKTtcclxuICAgICAgICAgICAgICAgICRjZWxsLmF0dHIoJ2NsYXNzJyxjbGFzc2VzLmNsYXNzZXMpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5vbmx5VGltZXBpY2tlcikgcmV0dXJuO1xyXG4gICAgICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgIHRoaXMuYWNpdHZlID0gdHJ1ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyAgRXZlbnRzXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgICAgICBfaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICB2YXIgZGF0ZSA9IGVsLmRhdGEoJ2RhdGUnKSB8fCAxLFxyXG4gICAgICAgICAgICAgICAgbW9udGggPSBlbC5kYXRhKCdtb250aCcpIHx8IDAsXHJcbiAgICAgICAgICAgICAgICB5ZWFyID0gZWwuZGF0YSgneWVhcicpIHx8IHRoaXMuZC5wYXJzZWREYXRlLnllYXIsXHJcbiAgICAgICAgICAgICAgICBkcCA9IHRoaXMuZDtcclxuICAgICAgICAgICAgLy8gQ2hhbmdlIHZpZXcgaWYgbWluIHZpZXcgZG9lcyBub3QgcmVhY2ggeWV0XHJcbiAgICAgICAgICAgIGlmIChkcC52aWV3ICE9IHRoaXMub3B0cy5taW5WaWV3KSB7XHJcbiAgICAgICAgICAgICAgICBkcC5kb3duKG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXRlKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2VsZWN0IGRhdGUgaWYgbWluIHZpZXcgaXMgcmVhY2hlZFxyXG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWREYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRhdGUpLFxyXG4gICAgICAgICAgICAgICAgYWxyZWFkeVNlbGVjdGVkID0gdGhpcy5kLl9pc1NlbGVjdGVkKHNlbGVjdGVkRGF0ZSwgdGhpcy5kLmNlbGxUeXBlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghYWxyZWFkeVNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICBkcC5fdHJpZ2dlcignY2xpY2tDZWxsJywgc2VsZWN0ZWREYXRlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZHAuX2hhbmRsZUFscmVhZHlTZWxlY3RlZERhdGVzLmJpbmQoZHAsIGFscmVhZHlTZWxlY3RlZCwgc2VsZWN0ZWREYXRlKSgpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfb25DbGlja0NlbGw6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZhciAkZWwgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KCcuZGF0ZXBpY2tlci0tY2VsbCcpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCRlbC5oYXNDbGFzcygnLWRpc2FibGVkLScpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVDbGljay5iaW5kKHRoaXMpKCRlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSkoKTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/air-datepicker/src/js/body.js\n");

/***/ }),

/***/ "./node_modules/air-datepicker/src/js/datepicker.js":
/*!**********************************************************!*\
  !*** ./node_modules/air-datepicker/src/js/datepicker.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval(";(function () {\r\n    var VERSION = '2.2.3',\r\n        pluginName = 'datepicker',\r\n        autoInitSelector = '.datepicker-here',\r\n        $body, $datepickersContainer,\r\n        containerBuilt = false,\r\n        baseTemplate = '' +\r\n            '<div class=\"datepicker\">' +\r\n            '<i class=\"datepicker--pointer\"></i>' +\r\n            '<nav class=\"datepicker--nav\"></nav>' +\r\n            '<div class=\"datepicker--content\"></div>' +\r\n            '</div>',\r\n        defaults = {\r\n            classes: '',\r\n            inline: false,\r\n            language: 'ru',\r\n            startDate: new Date(),\r\n            firstDay: '',\r\n            weekends: [6, 0],\r\n            dateFormat: '',\r\n            altField: '',\r\n            altFieldDateFormat: '@',\r\n            toggleSelected: true,\r\n            keyboardNav: true,\r\n\r\n            position: 'bottom left',\r\n            offset: 12,\r\n\r\n            view: 'days',\r\n            minView: 'days',\r\n\r\n            showOtherMonths: true,\r\n            selectOtherMonths: true,\r\n            moveToOtherMonthsOnSelect: true,\r\n\r\n            showOtherYears: true,\r\n            selectOtherYears: true,\r\n            moveToOtherYearsOnSelect: true,\r\n\r\n            minDate: '',\r\n            maxDate: '',\r\n            disableNavWhenOutOfRange: true,\r\n\r\n            multipleDates: false, // Boolean or Number\r\n            multipleDatesSeparator: ',',\r\n            range: false,\r\n\r\n            todayButton: false,\r\n            clearButton: false,\r\n\r\n            showEvent: 'focus',\r\n            autoClose: false,\r\n\r\n            // navigation\r\n            monthsField: 'monthsShort',\r\n            prevHtml: '<svg><path d=\"M 17,12 l -5,5 l 5,5\"></path></svg>',\r\n            nextHtml: '<svg><path d=\"M 14,12 l 5,5 l -5,5\"></path></svg>',\r\n            navTitles: {\r\n                days: 'MM, <i>yyyy</i>',\r\n                months: 'yyyy',\r\n                years: 'yyyy1 - yyyy2'\r\n            },\r\n\r\n            // timepicker\r\n            timepicker: false,\r\n            onlyTimepicker: false,\r\n            dateTimeSeparator: ' ',\r\n            timeFormat: '',\r\n            minHours: 0,\r\n            maxHours: 24,\r\n            minMinutes: 0,\r\n            maxMinutes: 59,\r\n            hoursStep: 1,\r\n            minutesStep: 1,\r\n\r\n            // events\r\n            onSelect: '',\r\n            onShow: '',\r\n            onHide: '',\r\n            onChangeMonth: '',\r\n            onChangeYear: '',\r\n            onChangeDecade: '',\r\n            onChangeView: '',\r\n            onRenderCell: ''\r\n        },\r\n        hotKeys = {\r\n            'ctrlRight': [17, 39],\r\n            'ctrlUp': [17, 38],\r\n            'ctrlLeft': [17, 37],\r\n            'ctrlDown': [17, 40],\r\n            'shiftRight': [16, 39],\r\n            'shiftUp': [16, 38],\r\n            'shiftLeft': [16, 37],\r\n            'shiftDown': [16, 40],\r\n            'altUp': [18, 38],\r\n            'altRight': [18, 39],\r\n            'altLeft': [18, 37],\r\n            'altDown': [18, 40],\r\n            'ctrlShiftUp': [16, 17, 38]\r\n        },\r\n        datepicker;\r\n\r\n    var Datepicker  = function (el, options) {\r\n        this.el = el;\r\n        this.$el = $(el);\r\n\r\n        this.opts = $.extend(true, {}, defaults, options, this.$el.data());\r\n\r\n        if ($body == undefined) {\r\n            $body = $('body');\r\n        }\r\n\r\n        if (!this.opts.startDate) {\r\n            this.opts.startDate = new Date();\r\n        }\r\n\r\n        if (this.el.nodeName == 'INPUT') {\r\n            this.elIsInput = true;\r\n        }\r\n\r\n        if (this.opts.altField) {\r\n            this.$altField = typeof this.opts.altField == 'string' ? $(this.opts.altField) : this.opts.altField;\r\n        }\r\n\r\n        this.inited = false;\r\n        this.visible = false;\r\n        this.silent = false; // Need to prevent unnecessary rendering\r\n\r\n        this.currentDate = this.opts.startDate;\r\n        this.currentView = this.opts.view;\r\n        this._createShortCuts();\r\n        this.selectedDates = [];\r\n        this.views = {};\r\n        this.keys = [];\r\n        this.minRange = '';\r\n        this.maxRange = '';\r\n        this._prevOnSelectValue = '';\r\n\r\n        this.init()\r\n    };\r\n\r\n    datepicker = Datepicker;\r\n\r\n    datepicker.prototype = {\r\n        VERSION: VERSION,\r\n        viewIndexes: ['days', 'months', 'years'],\r\n\r\n        init: function () {\r\n            if (!containerBuilt && !this.opts.inline && this.elIsInput) {\r\n                this._buildDatepickersContainer();\r\n            }\r\n            this._buildBaseHtml();\r\n            this._defineLocale(this.opts.language);\r\n            this._syncWithMinMaxDates();\r\n\r\n            if (this.elIsInput) {\r\n                if (!this.opts.inline) {\r\n                    // Set extra classes for proper transitions\r\n                    this._setPositionClasses(this.opts.position);\r\n                    this._bindEvents()\r\n                }\r\n                if (this.opts.keyboardNav && !this.opts.onlyTimepicker) {\r\n                    this._bindKeyboardEvents();\r\n                }\r\n                this.$datepicker.on('mousedown', this._onMouseDownDatepicker.bind(this));\r\n                this.$datepicker.on('mouseup', this._onMouseUpDatepicker.bind(this));\r\n            }\r\n\r\n            if (this.opts.classes) {\r\n                this.$datepicker.addClass(this.opts.classes)\r\n            }\r\n\r\n            if (this.opts.timepicker) {\r\n                this.timepicker = new $.fn.datepicker.Timepicker(this, this.opts);\r\n                this._bindTimepickerEvents();\r\n            }\r\n\r\n            if (this.opts.onlyTimepicker) {\r\n                this.$datepicker.addClass('-only-timepicker-');\r\n            }\r\n\r\n            this.views[this.currentView] = new $.fn.datepicker.Body(this, this.currentView, this.opts);\r\n            this.views[this.currentView].show();\r\n            this.nav = new $.fn.datepicker.Navigation(this, this.opts);\r\n            this.view = this.currentView;\r\n\r\n            this.$el.on('clickCell.adp', this._onClickCell.bind(this));\r\n            this.$datepicker.on('mouseenter', '.datepicker--cell', this._onMouseEnterCell.bind(this));\r\n            this.$datepicker.on('mouseleave', '.datepicker--cell', this._onMouseLeaveCell.bind(this));\r\n\r\n            this.inited = true;\r\n        },\r\n\r\n        _createShortCuts: function () {\r\n            this.minDate = this.opts.minDate ? this.opts.minDate : new Date(-8639999913600000);\r\n            this.maxDate = this.opts.maxDate ? this.opts.maxDate : new Date(8639999913600000);\r\n        },\r\n\r\n        _bindEvents : function () {\r\n            this.$el.on(this.opts.showEvent + '.adp', this._onShowEvent.bind(this));\r\n            this.$el.on('mouseup.adp', this._onMouseUpEl.bind(this));\r\n            this.$el.on('blur.adp', this._onBlur.bind(this));\r\n            this.$el.on('keyup.adp', this._onKeyUpGeneral.bind(this));\r\n            $(window).on('resize.adp', this._onResize.bind(this));\r\n            $('body').on('mouseup.adp', this._onMouseUpBody.bind(this));\r\n        },\r\n\r\n        _bindKeyboardEvents: function () {\r\n            this.$el.on('keydown.adp', this._onKeyDown.bind(this));\r\n            this.$el.on('keyup.adp', this._onKeyUp.bind(this));\r\n            this.$el.on('hotKey.adp', this._onHotKey.bind(this));\r\n        },\r\n\r\n        _bindTimepickerEvents: function () {\r\n            this.$el.on('timeChange.adp', this._onTimeChange.bind(this));\r\n        },\r\n\r\n        isWeekend: function (day) {\r\n            return this.opts.weekends.indexOf(day) !== -1;\r\n        },\r\n\r\n        _defineLocale: function (lang) {\r\n            if (typeof lang == 'string') {\r\n                this.loc = $.fn.datepicker.language[lang];\r\n                if (!this.loc) {\r\n                    console.warn('Can\\'t find language \"' + lang + '\" in Datepicker.language, will use \"ru\" instead');\r\n                    this.loc = $.extend(true, {}, $.fn.datepicker.language.ru)\r\n                }\r\n\r\n                this.loc = $.extend(true, {}, $.fn.datepicker.language.ru, $.fn.datepicker.language[lang])\r\n            } else {\r\n                this.loc = $.extend(true, {}, $.fn.datepicker.language.ru, lang)\r\n            }\r\n\r\n            if (this.opts.dateFormat) {\r\n                this.loc.dateFormat = this.opts.dateFormat\r\n            }\r\n\r\n            if (this.opts.timeFormat) {\r\n                this.loc.timeFormat = this.opts.timeFormat\r\n            }\r\n\r\n            if (this.opts.firstDay !== '') {\r\n                this.loc.firstDay = this.opts.firstDay\r\n            }\r\n\r\n            if (this.opts.timepicker) {\r\n                this.loc.dateFormat = [this.loc.dateFormat, this.loc.timeFormat].join(this.opts.dateTimeSeparator);\r\n            }\r\n\r\n            if (this.opts.onlyTimepicker) {\r\n                this.loc.dateFormat = this.loc.timeFormat;\r\n            }\r\n\r\n            var boundary = this._getWordBoundaryRegExp;\r\n            if (this.loc.timeFormat.match(boundary('aa')) ||\r\n                this.loc.timeFormat.match(boundary('AA'))\r\n            ) {\r\n               this.ampm = true;\r\n            }\r\n        },\r\n\r\n        _buildDatepickersContainer: function () {\r\n            containerBuilt = true;\r\n            $body.append('<div class=\"datepickers-container\" id=\"datepickers-container\"></div>');\r\n            $datepickersContainer = $('#datepickers-container');\r\n        },\r\n\r\n        _buildBaseHtml: function () {\r\n            var $appendTarget,\r\n                $inline = $('<div class=\"datepicker-inline\">');\r\n\r\n            if(this.el.nodeName == 'INPUT') {\r\n                if (!this.opts.inline) {\r\n                    $appendTarget = $datepickersContainer;\r\n                } else {\r\n                    $appendTarget = $inline.insertAfter(this.$el)\r\n                }\r\n            } else {\r\n                $appendTarget = $inline.appendTo(this.$el)\r\n            }\r\n\r\n            this.$datepicker = $(baseTemplate).appendTo($appendTarget);\r\n            this.$content = $('.datepicker--content', this.$datepicker);\r\n            this.$nav = $('.datepicker--nav', this.$datepicker);\r\n        },\r\n\r\n        _triggerOnChange: function () {\r\n            if (!this.selectedDates.length) {\r\n                // Prevent from triggering multiple onSelect callback with same argument (empty string) in IE10-11\r\n                if (this._prevOnSelectValue === '') return;\r\n                this._prevOnSelectValue = '';\r\n                return this.opts.onSelect('', '', this);\r\n            }\r\n\r\n            var selectedDates = this.selectedDates,\r\n                parsedSelected = datepicker.getParsedDate(selectedDates[0]),\r\n                formattedDates,\r\n                _this = this,\r\n                dates = new Date(\r\n                    parsedSelected.year,\r\n                    parsedSelected.month,\r\n                    parsedSelected.date,\r\n                    parsedSelected.hours,\r\n                    parsedSelected.minutes\r\n                );\r\n\r\n                formattedDates = selectedDates.map(function (date) {\r\n                    return _this.formatDate(_this.loc.dateFormat, date)\r\n                }).join(this.opts.multipleDatesSeparator);\r\n\r\n            // Create new dates array, to separate it from original selectedDates\r\n            if (this.opts.multipleDates || this.opts.range) {\r\n                dates = selectedDates.map(function(date) {\r\n                    var parsedDate = datepicker.getParsedDate(date);\r\n                    return new Date(\r\n                        parsedDate.year,\r\n                        parsedDate.month,\r\n                        parsedDate.date,\r\n                        parsedDate.hours,\r\n                        parsedDate.minutes\r\n                    );\r\n                })\r\n            }\r\n\r\n            this._prevOnSelectValue = formattedDates;\r\n            this.opts.onSelect(formattedDates, dates, this);\r\n        },\r\n\r\n        next: function () {\r\n            var d = this.parsedDate,\r\n                o = this.opts;\r\n            switch (this.view) {\r\n                case 'days':\r\n                    this.date = new Date(d.year, d.month + 1, 1);\r\n                    if (o.onChangeMonth) o.onChangeMonth(this.parsedDate.month, this.parsedDate.year);\r\n                    break;\r\n                case 'months':\r\n                    this.date = new Date(d.year + 1, d.month, 1);\r\n                    if (o.onChangeYear) o.onChangeYear(this.parsedDate.year);\r\n                    break;\r\n                case 'years':\r\n                    this.date = new Date(d.year + 10, 0, 1);\r\n                    if (o.onChangeDecade) o.onChangeDecade(this.curDecade);\r\n                    break;\r\n            }\r\n        },\r\n\r\n        prev: function () {\r\n            var d = this.parsedDate,\r\n                o = this.opts;\r\n            switch (this.view) {\r\n                case 'days':\r\n                    this.date = new Date(d.year, d.month - 1, 1);\r\n                    if (o.onChangeMonth) o.onChangeMonth(this.parsedDate.month, this.parsedDate.year);\r\n                    break;\r\n                case 'months':\r\n                    this.date = new Date(d.year - 1, d.month, 1);\r\n                    if (o.onChangeYear) o.onChangeYear(this.parsedDate.year);\r\n                    break;\r\n                case 'years':\r\n                    this.date = new Date(d.year - 10, 0, 1);\r\n                    if (o.onChangeDecade) o.onChangeDecade(this.curDecade);\r\n                    break;\r\n            }\r\n        },\r\n\r\n        formatDate: function (string, date) {\r\n            date = date || this.date;\r\n            var result = string,\r\n                boundary = this._getWordBoundaryRegExp,\r\n                locale = this.loc,\r\n                leadingZero = datepicker.getLeadingZeroNum,\r\n                decade = datepicker.getDecade(date),\r\n                d = datepicker.getParsedDate(date),\r\n                fullHours = d.fullHours,\r\n                hours = d.hours,\r\n                ampm = string.match(boundary('aa')) || string.match(boundary('AA')),\r\n                dayPeriod = 'am',\r\n                replacer = this._replacer,\r\n                validHours;\r\n\r\n            if (this.opts.timepicker && this.timepicker && ampm) {\r\n                validHours = this.timepicker._getValidHoursFromDate(date, ampm);\r\n                fullHours = leadingZero(validHours.hours);\r\n                hours = validHours.hours;\r\n                dayPeriod = validHours.dayPeriod;\r\n            }\r\n\r\n            switch (true) {\r\n                case /@/.test(result):\r\n                    result = result.replace(/@/, date.getTime());\r\n                case /aa/.test(result):\r\n                    result = replacer(result, boundary('aa'), dayPeriod);\r\n                case /AA/.test(result):\r\n                    result = replacer(result, boundary('AA'), dayPeriod.toUpperCase());\r\n                case /dd/.test(result):\r\n                    result = replacer(result, boundary('dd'), d.fullDate);\r\n                case /d/.test(result):\r\n                    result = replacer(result, boundary('d'), d.date);\r\n                case /DD/.test(result):\r\n                    result = replacer(result, boundary('DD'), locale.days[d.day]);\r\n                case /D/.test(result):\r\n                    result = replacer(result, boundary('D'), locale.daysShort[d.day]);\r\n                case /mm/.test(result):\r\n                    result = replacer(result, boundary('mm'), d.fullMonth);\r\n                case /m/.test(result):\r\n                    result = replacer(result, boundary('m'), d.month + 1);\r\n                case /MM/.test(result):\r\n                    result = replacer(result, boundary('MM'), this.loc.months[d.month]);\r\n                case /M/.test(result):\r\n                    result = replacer(result, boundary('M'), locale.monthsShort[d.month]);\r\n                case /ii/.test(result):\r\n                    result = replacer(result, boundary('ii'), d.fullMinutes);\r\n                case /i/.test(result):\r\n                    result = replacer(result, boundary('i'), d.minutes);\r\n                case /hh/.test(result):\r\n                    result = replacer(result, boundary('hh'), fullHours);\r\n                case /h/.test(result):\r\n                    result = replacer(result, boundary('h'), hours);\r\n                case /yyyy/.test(result):\r\n                    result = replacer(result, boundary('yyyy'), d.year);\r\n                case /yyyy1/.test(result):\r\n                    result = replacer(result, boundary('yyyy1'), decade[0]);\r\n                case /yyyy2/.test(result):\r\n                    result = replacer(result, boundary('yyyy2'), decade[1]);\r\n                case /yy/.test(result):\r\n                    result = replacer(result, boundary('yy'), d.year.toString().slice(-2));\r\n            }\r\n\r\n            return result;\r\n        },\r\n\r\n        _replacer: function (str, reg, data) {\r\n            return str.replace(reg, function (match, p1,p2,p3) {\r\n                return p1 + data + p3;\r\n            })\r\n        },\r\n\r\n        _getWordBoundaryRegExp: function (sign) {\r\n            var symbols = '\\\\s|\\\\.|-|/|\\\\\\\\|,|\\\\$|\\\\!|\\\\?|:|;';\r\n\r\n            return new RegExp('(^|>|' + symbols + ')(' + sign + ')($|<|' + symbols + ')', 'g');\r\n        },\r\n\r\n\r\n        selectDate: function (date) {\r\n            var _this = this,\r\n                opts = _this.opts,\r\n                d = _this.parsedDate,\r\n                selectedDates = _this.selectedDates,\r\n                len = selectedDates.length,\r\n                newDate = '';\r\n\r\n            if (Array.isArray(date)) {\r\n                date.forEach(function (d) {\r\n                    _this.selectDate(d)\r\n                });\r\n                return;\r\n            }\r\n\r\n            if (!(date instanceof Date)) return;\r\n\r\n            this.lastSelectedDate = date;\r\n\r\n            // Set new time values from Date\r\n            if (this.timepicker) {\r\n                this.timepicker._setTime(date);\r\n            }\r\n\r\n            // On this step timepicker will set valid values in it's instance\r\n            _this._trigger('selectDate', date);\r\n\r\n            // Set correct time values after timepicker's validation\r\n            // Prevent from setting hours or minutes which values are lesser then `min` value or\r\n            // greater then `max` value\r\n            if (this.timepicker) {\r\n                date.setHours(this.timepicker.hours);\r\n                date.setMinutes(this.timepicker.minutes)\r\n            }\r\n\r\n            if (_this.view == 'days') {\r\n                if (date.getMonth() != d.month && opts.moveToOtherMonthsOnSelect) {\r\n                    newDate = new Date(date.getFullYear(), date.getMonth(), 1);\r\n                }\r\n            }\r\n\r\n            if (_this.view == 'years') {\r\n                if (date.getFullYear() != d.year && opts.moveToOtherYearsOnSelect) {\r\n                    newDate = new Date(date.getFullYear(), 0, 1);\r\n                }\r\n            }\r\n\r\n            if (newDate) {\r\n                _this.silent = true;\r\n                _this.date = newDate;\r\n                _this.silent = false;\r\n                _this.nav._render()\r\n            }\r\n\r\n            if (opts.multipleDates && !opts.range) { // Set priority to range functionality\r\n                if (len === opts.multipleDates) return;\r\n                if (!_this._isSelected(date)) {\r\n                    _this.selectedDates.push(date);\r\n                }\r\n            } else if (opts.range) {\r\n                if (len == 2) {\r\n                    _this.selectedDates = [date];\r\n                    _this.minRange = date;\r\n                    _this.maxRange = '';\r\n                } else if (len == 1) {\r\n                    _this.selectedDates.push(date);\r\n                    if (!_this.maxRange){\r\n                        _this.maxRange = date;\r\n                    } else {\r\n                        _this.minRange = date;\r\n                    }\r\n                    // Swap dates if they were selected via dp.selectDate() and second date was smaller then first\r\n                    if (datepicker.bigger(_this.maxRange, _this.minRange)) {\r\n                        _this.maxRange = _this.minRange;\r\n                        _this.minRange = date;\r\n                    }\r\n                    _this.selectedDates = [_this.minRange, _this.maxRange]\r\n\r\n                } else {\r\n                    _this.selectedDates = [date];\r\n                    _this.minRange = date;\r\n                }\r\n            } else {\r\n                _this.selectedDates = [date];\r\n            }\r\n\r\n            _this._setInputValue();\r\n\r\n            if (opts.onSelect) {\r\n                _this._triggerOnChange();\r\n            }\r\n\r\n            if (opts.autoClose && !this.timepickerIsActive) {\r\n                if (!opts.multipleDates && !opts.range) {\r\n                    _this.hide();\r\n                } else if (opts.range && _this.selectedDates.length == 2) {\r\n                    _this.hide();\r\n                }\r\n            }\r\n\r\n            _this.views[this.currentView]._render()\r\n        },\r\n\r\n        removeDate: function (date) {\r\n            var selected = this.selectedDates,\r\n                _this = this;\r\n\r\n            if (!(date instanceof Date)) return;\r\n\r\n            return selected.some(function (curDate, i) {\r\n                if (datepicker.isSame(curDate, date)) {\r\n                    selected.splice(i, 1);\r\n\r\n                    if (!_this.selectedDates.length) {\r\n                        _this.minRange = '';\r\n                        _this.maxRange = '';\r\n                        _this.lastSelectedDate = '';\r\n                    } else {\r\n                        _this.lastSelectedDate = _this.selectedDates[_this.selectedDates.length - 1];\r\n                    }\r\n\r\n                    _this.views[_this.currentView]._render();\r\n                    _this._setInputValue();\r\n\r\n                    if (_this.opts.onSelect) {\r\n                        _this._triggerOnChange();\r\n                    }\r\n\r\n                    return true\r\n                }\r\n            })\r\n        },\r\n\r\n        today: function () {\r\n            this.silent = true;\r\n            this.view = this.opts.minView;\r\n            this.silent = false;\r\n            this.date = new Date();\r\n\r\n            if (this.opts.todayButton instanceof Date) {\r\n                this.selectDate(this.opts.todayButton)\r\n            }\r\n        },\r\n\r\n        clear: function () {\r\n            this.selectedDates = [];\r\n            this.minRange = '';\r\n            this.maxRange = '';\r\n            this.views[this.currentView]._render();\r\n            this._setInputValue();\r\n            if (this.opts.onSelect) {\r\n                this._triggerOnChange()\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Updates datepicker options\r\n         * @param {String|Object} param - parameter's name to update. If object then it will extend current options\r\n         * @param {String|Number|Object} [value] - new param value\r\n         */\r\n        update: function (param, value) {\r\n            var len = arguments.length,\r\n                lastSelectedDate = this.lastSelectedDate;\r\n\r\n            if (len == 2) {\r\n                this.opts[param] = value;\r\n            } else if (len == 1 && typeof param == 'object') {\r\n                this.opts = $.extend(true, this.opts, param)\r\n            }\r\n\r\n            this._createShortCuts();\r\n            this._syncWithMinMaxDates();\r\n            this._defineLocale(this.opts.language);\r\n            this.nav._addButtonsIfNeed();\r\n            if (!this.opts.onlyTimepicker) this.nav._render();\r\n            this.views[this.currentView]._render();\r\n\r\n            if (this.elIsInput && !this.opts.inline) {\r\n                this._setPositionClasses(this.opts.position);\r\n                if (this.visible) {\r\n                    this.setPosition(this.opts.position)\r\n                }\r\n            }\r\n\r\n            if (this.opts.classes) {\r\n                this.$datepicker.addClass(this.opts.classes)\r\n            }\r\n\r\n            if (this.opts.onlyTimepicker) {\r\n                this.$datepicker.addClass('-only-timepicker-');\r\n            }\r\n\r\n            if (this.opts.timepicker) {\r\n                if (lastSelectedDate) this.timepicker._handleDate(lastSelectedDate);\r\n                this.timepicker._updateRanges();\r\n                this.timepicker._updateCurrentTime();\r\n                // Change hours and minutes if it's values have been changed through min/max hours/minutes\r\n                if (lastSelectedDate) {\r\n                    lastSelectedDate.setHours(this.timepicker.hours);\r\n                    lastSelectedDate.setMinutes(this.timepicker.minutes);\r\n                }\r\n            }\r\n\r\n            this._setInputValue();\r\n\r\n            return this;\r\n        },\r\n\r\n        _syncWithMinMaxDates: function () {\r\n            var curTime = this.date.getTime();\r\n            this.silent = true;\r\n            if (this.minTime > curTime) {\r\n                this.date = this.minDate;\r\n            }\r\n\r\n            if (this.maxTime < curTime) {\r\n                this.date = this.maxDate;\r\n            }\r\n            this.silent = false;\r\n        },\r\n\r\n        _isSelected: function (checkDate, cellType) {\r\n            var res = false;\r\n            this.selectedDates.some(function (date) {\r\n                if (datepicker.isSame(date, checkDate, cellType)) {\r\n                    res = date;\r\n                    return true;\r\n                }\r\n            });\r\n            return res;\r\n        },\r\n\r\n        _setInputValue: function () {\r\n            var _this = this,\r\n                opts = _this.opts,\r\n                format = _this.loc.dateFormat,\r\n                altFormat = opts.altFieldDateFormat,\r\n                value = _this.selectedDates.map(function (date) {\r\n                    return _this.formatDate(format, date)\r\n                }),\r\n                altValues;\r\n\r\n            if (opts.altField && _this.$altField.length) {\r\n                altValues = this.selectedDates.map(function (date) {\r\n                    return _this.formatDate(altFormat, date)\r\n                });\r\n                altValues = altValues.join(this.opts.multipleDatesSeparator);\r\n                this.$altField.val(altValues);\r\n            }\r\n\r\n            value = value.join(this.opts.multipleDatesSeparator);\r\n\r\n            this.$el.val(value)\r\n        },\r\n\r\n        /**\r\n         * Check if date is between minDate and maxDate\r\n         * @param date {object} - date object\r\n         * @param type {string} - cell type\r\n         * @returns {boolean}\r\n         * @private\r\n         */\r\n        _isInRange: function (date, type) {\r\n            var time = date.getTime(),\r\n                d = datepicker.getParsedDate(date),\r\n                min = datepicker.getParsedDate(this.minDate),\r\n                max = datepicker.getParsedDate(this.maxDate),\r\n                dMinTime = new Date(d.year, d.month, min.date).getTime(),\r\n                dMaxTime = new Date(d.year, d.month, max.date).getTime(),\r\n                types = {\r\n                    day: time >= this.minTime && time <= this.maxTime,\r\n                    month: dMinTime >= this.minTime && dMaxTime <= this.maxTime,\r\n                    year: d.year >= min.year && d.year <= max.year\r\n                };\r\n            return type ? types[type] : types.day\r\n        },\r\n\r\n        _getDimensions: function ($el) {\r\n            var offset = $el.offset();\r\n\r\n            return {\r\n                width: $el.outerWidth(),\r\n                height: $el.outerHeight(),\r\n                left: offset.left,\r\n                top: offset.top\r\n            }\r\n        },\r\n\r\n        _getDateFromCell: function (cell) {\r\n            var curDate = this.parsedDate,\r\n                year = cell.data('year') || curDate.year,\r\n                month = cell.data('month') == undefined ? curDate.month : cell.data('month'),\r\n                date = cell.data('date') || 1;\r\n\r\n            return new Date(year, month, date);\r\n        },\r\n\r\n        _setPositionClasses: function (pos) {\r\n            pos = pos.split(' ');\r\n            var main = pos[0],\r\n                sec = pos[1],\r\n                classes = 'datepicker -' + main + '-' + sec + '- -from-' + main + '-';\r\n\r\n            if (this.visible) classes += ' active';\r\n\r\n            this.$datepicker\r\n                .removeAttr('class')\r\n                .addClass(classes);\r\n        },\r\n\r\n        setPosition: function (position) {\r\n            position = position || this.opts.position;\r\n\r\n            var dims = this._getDimensions(this.$el),\r\n                selfDims = this._getDimensions(this.$datepicker),\r\n                pos = position.split(' '),\r\n                top, left,\r\n                offset = this.opts.offset,\r\n                main = pos[0],\r\n                secondary = pos[1];\r\n\r\n            switch (main) {\r\n                case 'top':\r\n                    top = dims.top - selfDims.height - offset;\r\n                    break;\r\n                case 'right':\r\n                    left = dims.left + dims.width + offset;\r\n                    break;\r\n                case 'bottom':\r\n                    top = dims.top + dims.height + offset;\r\n                    break;\r\n                case 'left':\r\n                    left = dims.left - selfDims.width - offset;\r\n                    break;\r\n            }\r\n\r\n            switch(secondary) {\r\n                case 'top':\r\n                    top = dims.top;\r\n                    break;\r\n                case 'right':\r\n                    left = dims.left + dims.width - selfDims.width;\r\n                    break;\r\n                case 'bottom':\r\n                    top = dims.top + dims.height - selfDims.height;\r\n                    break;\r\n                case 'left':\r\n                    left = dims.left;\r\n                    break;\r\n                case 'center':\r\n                    if (/left|right/.test(main)) {\r\n                        top = dims.top + dims.height/2 - selfDims.height/2;\r\n                    } else {\r\n                        left = dims.left + dims.width/2 - selfDims.width/2;\r\n                    }\r\n            }\r\n\r\n            this.$datepicker\r\n                .css({\r\n                    left: left,\r\n                    top: top\r\n                })\r\n        },\r\n\r\n        show: function () {\r\n            var onShow = this.opts.onShow;\r\n\r\n            this.setPosition(this.opts.position);\r\n            this.$datepicker.addClass('active');\r\n            this.visible = true;\r\n\r\n            if (onShow) {\r\n                this._bindVisionEvents(onShow)\r\n            }\r\n        },\r\n\r\n        hide: function () {\r\n            var onHide = this.opts.onHide;\r\n\r\n            this.$datepicker\r\n                .removeClass('active')\r\n                .css({\r\n                    left: '-100000px'\r\n                });\r\n\r\n            this.focused = '';\r\n            this.keys = [];\r\n\r\n            this.inFocus = false;\r\n            this.visible = false;\r\n            this.$el.blur();\r\n\r\n            if (onHide) {\r\n                this._bindVisionEvents(onHide)\r\n            }\r\n        },\r\n\r\n        down: function (date) {\r\n            this._changeView(date, 'down');\r\n        },\r\n\r\n        up: function (date) {\r\n            this._changeView(date, 'up');\r\n        },\r\n\r\n        _bindVisionEvents: function (event) {\r\n            this.$datepicker.off('transitionend.dp');\r\n            event(this, false);\r\n            this.$datepicker.one('transitionend.dp', event.bind(this, this, true))\r\n        },\r\n\r\n        _changeView: function (date, dir) {\r\n            date = date || this.focused || this.date;\r\n\r\n            var nextView = dir == 'up' ? this.viewIndex + 1 : this.viewIndex - 1;\r\n            if (nextView > 2) nextView = 2;\r\n            if (nextView < 0) nextView = 0;\r\n\r\n            this.silent = true;\r\n            this.date = new Date(date.getFullYear(), date.getMonth(), 1);\r\n            this.silent = false;\r\n            this.view = this.viewIndexes[nextView];\r\n\r\n        },\r\n\r\n        _handleHotKey: function (key) {\r\n            var date = datepicker.getParsedDate(this._getFocusedDate()),\r\n                focusedParsed,\r\n                o = this.opts,\r\n                newDate,\r\n                totalDaysInNextMonth,\r\n                monthChanged = false,\r\n                yearChanged = false,\r\n                decadeChanged = false,\r\n                y = date.year,\r\n                m = date.month,\r\n                d = date.date;\r\n\r\n            switch (key) {\r\n                case 'ctrlRight':\r\n                case 'ctrlUp':\r\n                    m += 1;\r\n                    monthChanged = true;\r\n                    break;\r\n                case 'ctrlLeft':\r\n                case 'ctrlDown':\r\n                    m -= 1;\r\n                    monthChanged = true;\r\n                    break;\r\n                case 'shiftRight':\r\n                case 'shiftUp':\r\n                    yearChanged = true;\r\n                    y += 1;\r\n                    break;\r\n                case 'shiftLeft':\r\n                case 'shiftDown':\r\n                    yearChanged = true;\r\n                    y -= 1;\r\n                    break;\r\n                case 'altRight':\r\n                case 'altUp':\r\n                    decadeChanged = true;\r\n                    y += 10;\r\n                    break;\r\n                case 'altLeft':\r\n                case 'altDown':\r\n                    decadeChanged = true;\r\n                    y -= 10;\r\n                    break;\r\n                case 'ctrlShiftUp':\r\n                    this.up();\r\n                    break;\r\n            }\r\n\r\n            totalDaysInNextMonth = datepicker.getDaysCount(new Date(y,m));\r\n            newDate = new Date(y,m,d);\r\n\r\n            // If next month has less days than current, set date to total days in that month\r\n            if (totalDaysInNextMonth < d) d = totalDaysInNextMonth;\r\n\r\n            // Check if newDate is in valid range\r\n            if (newDate.getTime() < this.minTime) {\r\n                newDate = this.minDate;\r\n            } else if (newDate.getTime() > this.maxTime) {\r\n                newDate = this.maxDate;\r\n            }\r\n\r\n            this.focused = newDate;\r\n\r\n            focusedParsed = datepicker.getParsedDate(newDate);\r\n            if (monthChanged && o.onChangeMonth) {\r\n                o.onChangeMonth(focusedParsed.month, focusedParsed.year)\r\n            }\r\n            if (yearChanged && o.onChangeYear) {\r\n                o.onChangeYear(focusedParsed.year)\r\n            }\r\n            if (decadeChanged && o.onChangeDecade) {\r\n                o.onChangeDecade(this.curDecade)\r\n            }\r\n        },\r\n\r\n        _registerKey: function (key) {\r\n            var exists = this.keys.some(function (curKey) {\r\n                return curKey == key;\r\n            });\r\n\r\n            if (!exists) {\r\n                this.keys.push(key)\r\n            }\r\n        },\r\n\r\n        _unRegisterKey: function (key) {\r\n            var index = this.keys.indexOf(key);\r\n\r\n            this.keys.splice(index, 1);\r\n        },\r\n\r\n        _isHotKeyPressed: function () {\r\n            var currentHotKey,\r\n                found = false,\r\n                _this = this,\r\n                pressedKeys = this.keys.sort();\r\n\r\n            for (var hotKey in hotKeys) {\r\n                currentHotKey = hotKeys[hotKey];\r\n                if (pressedKeys.length != currentHotKey.length) continue;\r\n\r\n                if (currentHotKey.every(function (key, i) { return key == pressedKeys[i]})) {\r\n                    _this._trigger('hotKey', hotKey);\r\n                    found = true;\r\n                }\r\n            }\r\n\r\n            return found;\r\n        },\r\n\r\n        _trigger: function (event, args) {\r\n            this.$el.trigger(event, args)\r\n        },\r\n\r\n        _focusNextCell: function (keyCode, type) {\r\n            type = type || this.cellType;\r\n\r\n            var date = datepicker.getParsedDate(this._getFocusedDate()),\r\n                y = date.year,\r\n                m = date.month,\r\n                d = date.date;\r\n\r\n            if (this._isHotKeyPressed()){\r\n                return;\r\n            }\r\n\r\n            switch(keyCode) {\r\n                case 37: // left\r\n                    type == 'day' ? (d -= 1) : '';\r\n                    type == 'month' ? (m -= 1) : '';\r\n                    type == 'year' ? (y -= 1) : '';\r\n                    break;\r\n                case 38: // up\r\n                    type == 'day' ? (d -= 7) : '';\r\n                    type == 'month' ? (m -= 3) : '';\r\n                    type == 'year' ? (y -= 4) : '';\r\n                    break;\r\n                case 39: // right\r\n                    type == 'day' ? (d += 1) : '';\r\n                    type == 'month' ? (m += 1) : '';\r\n                    type == 'year' ? (y += 1) : '';\r\n                    break;\r\n                case 40: // down\r\n                    type == 'day' ? (d += 7) : '';\r\n                    type == 'month' ? (m += 3) : '';\r\n                    type == 'year' ? (y += 4) : '';\r\n                    break;\r\n            }\r\n\r\n            var nd = new Date(y,m,d);\r\n            if (nd.getTime() < this.minTime) {\r\n                nd = this.minDate;\r\n            } else if (nd.getTime() > this.maxTime) {\r\n                nd = this.maxDate;\r\n            }\r\n\r\n            this.focused = nd;\r\n\r\n        },\r\n\r\n        _getFocusedDate: function () {\r\n            var focused  = this.focused || this.selectedDates[this.selectedDates.length - 1],\r\n                d = this.parsedDate;\r\n\r\n            if (!focused) {\r\n                switch (this.view) {\r\n                    case 'days':\r\n                        focused = new Date(d.year, d.month, new Date().getDate());\r\n                        break;\r\n                    case 'months':\r\n                        focused = new Date(d.year, d.month, 1);\r\n                        break;\r\n                    case 'years':\r\n                        focused = new Date(d.year, 0, 1);\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return focused;\r\n        },\r\n\r\n        _getCell: function (date, type) {\r\n            type = type || this.cellType;\r\n\r\n            var d = datepicker.getParsedDate(date),\r\n                selector = '.datepicker--cell[data-year=\"' + d.year + '\"]',\r\n                $cell;\r\n\r\n            switch (type) {\r\n                case 'month':\r\n                    selector = '[data-month=\"' + d.month + '\"]';\r\n                    break;\r\n                case 'day':\r\n                    selector += '[data-month=\"' + d.month + '\"][data-date=\"' + d.date + '\"]';\r\n                    break;\r\n            }\r\n            $cell = this.views[this.currentView].$el.find(selector);\r\n\r\n            return $cell.length ? $cell : $('');\r\n        },\r\n\r\n        destroy: function () {\r\n            var _this = this;\r\n            _this.$el\r\n                .off('.adp')\r\n                .data('datepicker', '');\r\n\r\n            _this.selectedDates = [];\r\n            _this.focused = '';\r\n            _this.views = {};\r\n            _this.keys = [];\r\n            _this.minRange = '';\r\n            _this.maxRange = '';\r\n\r\n            if (_this.opts.inline || !_this.elIsInput) {\r\n                _this.$datepicker.closest('.datepicker-inline').remove();\r\n            } else {\r\n                _this.$datepicker.remove();\r\n            }\r\n        },\r\n\r\n        _handleAlreadySelectedDates: function (alreadySelected, selectedDate) {\r\n            if (this.opts.range) {\r\n                if (!this.opts.toggleSelected) {\r\n                    // Add possibility to select same date when range is true\r\n                    if (this.selectedDates.length != 2) {\r\n                        this._trigger('clickCell', selectedDate);\r\n                    }\r\n                } else {\r\n                    this.removeDate(selectedDate);\r\n                }\r\n            } else if (this.opts.toggleSelected){\r\n                this.removeDate(selectedDate);\r\n            }\r\n\r\n            // Change last selected date to be able to change time when clicking on this cell\r\n            if (!this.opts.toggleSelected) {\r\n                this.lastSelectedDate = alreadySelected;\r\n                if (this.opts.timepicker) {\r\n                    this.timepicker._setTime(alreadySelected);\r\n                    this.timepicker.update();\r\n                }\r\n            }\r\n        },\r\n\r\n        _onShowEvent: function (e) {\r\n            if (!this.visible) {\r\n                this.show();\r\n            }\r\n        },\r\n\r\n        _onBlur: function () {\r\n            if (!this.inFocus && this.visible) {\r\n                this.hide();\r\n            }\r\n        },\r\n\r\n        _onMouseDownDatepicker: function (e) {\r\n            this.inFocus = true;\r\n        },\r\n\r\n        _onMouseUpDatepicker: function (e) {\r\n            this.inFocus = false;\r\n            e.originalEvent.inFocus = true;\r\n            if (!e.originalEvent.timepickerFocus) this.$el.focus();\r\n        },\r\n\r\n        _onKeyUpGeneral: function (e) {\r\n            var val = this.$el.val();\r\n\r\n            if (!val) {\r\n                this.clear();\r\n            }\r\n        },\r\n\r\n        _onResize: function () {\r\n            if (this.visible) {\r\n                this.setPosition();\r\n            }\r\n        },\r\n\r\n        _onMouseUpBody: function (e) {\r\n            if (e.originalEvent.inFocus) return;\r\n\r\n            if (this.visible && !this.inFocus) {\r\n                this.hide();\r\n            }\r\n        },\r\n\r\n        _onMouseUpEl: function (e) {\r\n            e.originalEvent.inFocus = true;\r\n            setTimeout(this._onKeyUpGeneral.bind(this),4);\r\n        },\r\n\r\n        _onKeyDown: function (e) {\r\n            var code = e.which;\r\n            this._registerKey(code);\r\n\r\n            // Arrows\r\n            if (code >= 37 && code <= 40) {\r\n                e.preventDefault();\r\n                this._focusNextCell(code);\r\n            }\r\n\r\n            // Enter\r\n            if (code == 13) {\r\n                if (this.focused) {\r\n                    if (this._getCell(this.focused).hasClass('-disabled-')) return;\r\n                    if (this.view != this.opts.minView) {\r\n                        this.down()\r\n                    } else {\r\n                        var alreadySelected = this._isSelected(this.focused, this.cellType);\r\n\r\n                        if (!alreadySelected) {\r\n                            if (this.timepicker) {\r\n                                this.focused.setHours(this.timepicker.hours);\r\n                                this.focused.setMinutes(this.timepicker.minutes);\r\n                            }\r\n                            this.selectDate(this.focused);\r\n                            return;\r\n                        }\r\n                        this._handleAlreadySelectedDates(alreadySelected, this.focused)\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Esc\r\n            if (code == 27) {\r\n                this.hide();\r\n            }\r\n        },\r\n\r\n        _onKeyUp: function (e) {\r\n            var code = e.which;\r\n            this._unRegisterKey(code);\r\n        },\r\n\r\n        _onHotKey: function (e, hotKey) {\r\n            this._handleHotKey(hotKey);\r\n        },\r\n\r\n        _onMouseEnterCell: function (e) {\r\n            var $cell = $(e.target).closest('.datepicker--cell'),\r\n                date = this._getDateFromCell($cell);\r\n\r\n            // Prevent from unnecessary rendering and setting new currentDate\r\n            this.silent = true;\r\n\r\n            if (this.focused) {\r\n                this.focused = ''\r\n            }\r\n\r\n            $cell.addClass('-focus-');\r\n\r\n            this.focused = date;\r\n            this.silent = false;\r\n\r\n            if (this.opts.range && this.selectedDates.length == 1) {\r\n                this.minRange = this.selectedDates[0];\r\n                this.maxRange = '';\r\n                if (datepicker.less(this.minRange, this.focused)) {\r\n                    this.maxRange = this.minRange;\r\n                    this.minRange = '';\r\n                }\r\n                this.views[this.currentView]._update();\r\n            }\r\n        },\r\n\r\n        _onMouseLeaveCell: function (e) {\r\n            var $cell = $(e.target).closest('.datepicker--cell');\r\n\r\n            $cell.removeClass('-focus-');\r\n\r\n            this.silent = true;\r\n            this.focused = '';\r\n            this.silent = false;\r\n        },\r\n\r\n        _onTimeChange: function (e, h, m) {\r\n            var date = new Date(),\r\n                selectedDates = this.selectedDates,\r\n                selected = false;\r\n\r\n            if (selectedDates.length) {\r\n                selected = true;\r\n                date = this.lastSelectedDate;\r\n            }\r\n\r\n            date.setHours(h);\r\n            date.setMinutes(m);\r\n\r\n            if (!selected && !this._getCell(date).hasClass('-disabled-')) {\r\n                this.selectDate(date);\r\n            } else {\r\n                this._setInputValue();\r\n                if (this.opts.onSelect) {\r\n                    this._triggerOnChange();\r\n                }\r\n            }\r\n        },\r\n\r\n        _onClickCell: function (e, date) {\r\n            if (this.timepicker) {\r\n                date.setHours(this.timepicker.hours);\r\n                date.setMinutes(this.timepicker.minutes);\r\n            }\r\n            this.selectDate(date);\r\n        },\r\n\r\n        set focused(val) {\r\n            if (!val && this.focused) {\r\n                var $cell = this._getCell(this.focused);\r\n\r\n                if ($cell.length) {\r\n                    $cell.removeClass('-focus-')\r\n                }\r\n            }\r\n            this._focused = val;\r\n            if (this.opts.range && this.selectedDates.length == 1) {\r\n                this.minRange = this.selectedDates[0];\r\n                this.maxRange = '';\r\n                if (datepicker.less(this.minRange, this._focused)) {\r\n                    this.maxRange = this.minRange;\r\n                    this.minRange = '';\r\n                }\r\n            }\r\n            if (this.silent) return;\r\n            this.date = val;\r\n        },\r\n\r\n        get focused() {\r\n            return this._focused;\r\n        },\r\n\r\n        get parsedDate() {\r\n            return datepicker.getParsedDate(this.date);\r\n        },\r\n\r\n        set date (val) {\r\n            if (!(val instanceof Date)) return;\r\n\r\n            this.currentDate = val;\r\n\r\n            if (this.inited && !this.silent) {\r\n                this.views[this.view]._render();\r\n                this.nav._render();\r\n                if (this.visible && this.elIsInput) {\r\n                    this.setPosition();\r\n                }\r\n            }\r\n            return val;\r\n        },\r\n\r\n        get date () {\r\n            return this.currentDate\r\n        },\r\n\r\n        set view (val) {\r\n            this.viewIndex = this.viewIndexes.indexOf(val);\r\n\r\n            if (this.viewIndex < 0) {\r\n                return;\r\n            }\r\n\r\n            this.prevView = this.currentView;\r\n            this.currentView = val;\r\n\r\n            if (this.inited) {\r\n                if (!this.views[val]) {\r\n                    this.views[val] = new  $.fn.datepicker.Body(this, val, this.opts)\r\n                } else {\r\n                    this.views[val]._render();\r\n                }\r\n\r\n                this.views[this.prevView].hide();\r\n                this.views[val].show();\r\n                this.nav._render();\r\n\r\n                if (this.opts.onChangeView) {\r\n                    this.opts.onChangeView(val)\r\n                }\r\n                if (this.elIsInput && this.visible) this.setPosition();\r\n            }\r\n\r\n            return val\r\n        },\r\n\r\n        get view() {\r\n            return this.currentView;\r\n        },\r\n\r\n        get cellType() {\r\n            return this.view.substring(0, this.view.length - 1)\r\n        },\r\n\r\n        get minTime() {\r\n            var min = datepicker.getParsedDate(this.minDate);\r\n            return new Date(min.year, min.month, min.date).getTime()\r\n        },\r\n\r\n        get maxTime() {\r\n            var max = datepicker.getParsedDate(this.maxDate);\r\n            return new Date(max.year, max.month, max.date).getTime()\r\n        },\r\n\r\n        get curDecade() {\r\n            return datepicker.getDecade(this.date)\r\n        }\r\n    };\r\n\r\n    //  Utils\r\n    // -------------------------------------------------\r\n\r\n    datepicker.getDaysCount = function (date) {\r\n        return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\r\n    };\r\n\r\n    datepicker.getParsedDate = function (date) {\r\n        return {\r\n            year: date.getFullYear(),\r\n            month: date.getMonth(),\r\n            fullMonth: (date.getMonth() + 1) < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1, // One based\r\n            date: date.getDate(),\r\n            fullDate: date.getDate() < 10 ? '0' + date.getDate() : date.getDate(),\r\n            day: date.getDay(),\r\n            hours: date.getHours(),\r\n            fullHours:  date.getHours() < 10 ? '0' + date.getHours() :  date.getHours() ,\r\n            minutes: date.getMinutes(),\r\n            fullMinutes:  date.getMinutes() < 10 ? '0' + date.getMinutes() :  date.getMinutes()\r\n        }\r\n    };\r\n\r\n    datepicker.getDecade = function (date) {\r\n        var firstYear = Math.floor(date.getFullYear() / 10) * 10;\r\n\r\n        return [firstYear, firstYear + 9];\r\n    };\r\n\r\n    datepicker.template = function (str, data) {\r\n        return str.replace(/#\\{([\\w]+)\\}/g, function (source, match) {\r\n            if (data[match] || data[match] === 0) {\r\n                return data[match]\r\n            }\r\n        });\r\n    };\r\n\r\n    datepicker.isSame = function (date1, date2, type) {\r\n        if (!date1 || !date2) return false;\r\n        var d1 = datepicker.getParsedDate(date1),\r\n            d2 = datepicker.getParsedDate(date2),\r\n            _type = type ? type : 'day',\r\n\r\n            conditions = {\r\n                day: d1.date == d2.date && d1.month == d2.month && d1.year == d2.year,\r\n                month: d1.month == d2.month && d1.year == d2.year,\r\n                year: d1.year == d2.year\r\n            };\r\n\r\n        return conditions[_type];\r\n    };\r\n\r\n    datepicker.less = function (dateCompareTo, date, type) {\r\n        if (!dateCompareTo || !date) return false;\r\n        return date.getTime() < dateCompareTo.getTime();\r\n    };\r\n\r\n    datepicker.bigger = function (dateCompareTo, date, type) {\r\n        if (!dateCompareTo || !date) return false;\r\n        return date.getTime() > dateCompareTo.getTime();\r\n    };\r\n\r\n    datepicker.getLeadingZeroNum = function (num) {\r\n        return parseInt(num) < 10 ? '0' + num : num;\r\n    };\r\n\r\n    /**\r\n     * Returns copy of date with hours and minutes equals to 0\r\n     * @param date {Date}\r\n     */\r\n    datepicker.resetTime = function (date) {\r\n        if (typeof date != 'object') return;\r\n        date = datepicker.getParsedDate(date);\r\n        return new Date(date.year, date.month, date.date)\r\n    };\r\n\r\n    $.fn.datepicker = function ( options ) {\r\n        return this.each(function () {\r\n            if (!$.data(this, pluginName)) {\r\n                $.data(this,  pluginName,\r\n                    new Datepicker( this, options ));\r\n            } else {\r\n                var _this = $.data(this, pluginName);\r\n\r\n                _this.opts = $.extend(true, _this.opts, options);\r\n                _this.update();\r\n            }\r\n        });\r\n    };\r\n\r\n    $.fn.datepicker.Constructor = Datepicker;\r\n\r\n    $.fn.datepicker.language = {\r\n        ru: {\r\n            days: ['', '', '', '', '', '', ''],\r\n            daysShort: ['','','','','','',''],\r\n            daysMin: ['','','','','','',''],\r\n            months: ['', '', '', '', '', '', '', '', '', '', '', ''],\r\n            monthsShort: ['', '', '', '', '', '', '', '', '', '', '', ''],\r\n            today: '',\r\n            clear: '',\r\n            dateFormat: 'dd.mm.yyyy',\r\n            timeFormat: 'hh:ii',\r\n            firstDay: 1\r\n        }\r\n    };\r\n\r\n    $(function () {\r\n        $(autoInitSelector).datepicker();\r\n    })\r\n\r\n})();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWlyLWRhdGVwaWNrZXIvc3JjL2pzL2RhdGVwaWNrZXIuanM/ZDA0ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDs7QUFFQSw0Q0FBNEM7QUFDNUMsYUFBYTtBQUNiLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7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cUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJEQUEyRCw4QkFBOEI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Fpci1kYXRlcGlja2VyL3NyYy9qcy9kYXRlcGlja2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgVkVSU0lPTiA9ICcyLjIuMycsXHJcbiAgICAgICAgcGx1Z2luTmFtZSA9ICdkYXRlcGlja2VyJyxcclxuICAgICAgICBhdXRvSW5pdFNlbGVjdG9yID0gJy5kYXRlcGlja2VyLWhlcmUnLFxyXG4gICAgICAgICRib2R5LCAkZGF0ZXBpY2tlcnNDb250YWluZXIsXHJcbiAgICAgICAgY29udGFpbmVyQnVpbHQgPSBmYWxzZSxcclxuICAgICAgICBiYXNlVGVtcGxhdGUgPSAnJyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlclwiPicgK1xyXG4gICAgICAgICAgICAnPGkgY2xhc3M9XCJkYXRlcGlja2VyLS1wb2ludGVyXCI+PC9pPicgK1xyXG4gICAgICAgICAgICAnPG5hdiBjbGFzcz1cImRhdGVwaWNrZXItLW5hdlwiPjwvbmF2PicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItLWNvbnRlbnRcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicsXHJcbiAgICAgICAgZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXM6ICcnLFxyXG4gICAgICAgICAgICBpbmxpbmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBsYW5ndWFnZTogJ3J1JyxcclxuICAgICAgICAgICAgc3RhcnREYXRlOiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgICBmaXJzdERheTogJycsXHJcbiAgICAgICAgICAgIHdlZWtlbmRzOiBbNiwgMF0sXHJcbiAgICAgICAgICAgIGRhdGVGb3JtYXQ6ICcnLFxyXG4gICAgICAgICAgICBhbHRGaWVsZDogJycsXHJcbiAgICAgICAgICAgIGFsdEZpZWxkRGF0ZUZvcm1hdDogJ0AnLFxyXG4gICAgICAgICAgICB0b2dnbGVTZWxlY3RlZDogdHJ1ZSxcclxuICAgICAgICAgICAga2V5Ym9hcmROYXY6IHRydWUsXHJcblxyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2JvdHRvbSBsZWZ0JyxcclxuICAgICAgICAgICAgb2Zmc2V0OiAxMixcclxuXHJcbiAgICAgICAgICAgIHZpZXc6ICdkYXlzJyxcclxuICAgICAgICAgICAgbWluVmlldzogJ2RheXMnLFxyXG5cclxuICAgICAgICAgICAgc2hvd090aGVyTW9udGhzOiB0cnVlLFxyXG4gICAgICAgICAgICBzZWxlY3RPdGhlck1vbnRoczogdHJ1ZSxcclxuICAgICAgICAgICAgbW92ZVRvT3RoZXJNb250aHNPblNlbGVjdDogdHJ1ZSxcclxuXHJcbiAgICAgICAgICAgIHNob3dPdGhlclllYXJzOiB0cnVlLFxyXG4gICAgICAgICAgICBzZWxlY3RPdGhlclllYXJzOiB0cnVlLFxyXG4gICAgICAgICAgICBtb3ZlVG9PdGhlclllYXJzT25TZWxlY3Q6IHRydWUsXHJcblxyXG4gICAgICAgICAgICBtaW5EYXRlOiAnJyxcclxuICAgICAgICAgICAgbWF4RGF0ZTogJycsXHJcbiAgICAgICAgICAgIGRpc2FibGVOYXZXaGVuT3V0T2ZSYW5nZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgICAgIG11bHRpcGxlRGF0ZXM6IGZhbHNlLCAvLyBCb29sZWFuIG9yIE51bWJlclxyXG4gICAgICAgICAgICBtdWx0aXBsZURhdGVzU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgICAgICAgIHJhbmdlOiBmYWxzZSxcclxuXHJcbiAgICAgICAgICAgIHRvZGF5QnV0dG9uOiBmYWxzZSxcclxuICAgICAgICAgICAgY2xlYXJCdXR0b246IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgc2hvd0V2ZW50OiAnZm9jdXMnLFxyXG4gICAgICAgICAgICBhdXRvQ2xvc2U6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgLy8gbmF2aWdhdGlvblxyXG4gICAgICAgICAgICBtb250aHNGaWVsZDogJ21vbnRoc1Nob3J0JyxcclxuICAgICAgICAgICAgcHJldkh0bWw6ICc8c3ZnPjxwYXRoIGQ9XCJNIDE3LDEyIGwgLTUsNSBsIDUsNVwiPjwvcGF0aD48L3N2Zz4nLFxyXG4gICAgICAgICAgICBuZXh0SHRtbDogJzxzdmc+PHBhdGggZD1cIk0gMTQsMTIgbCA1LDUgbCAtNSw1XCI+PC9wYXRoPjwvc3ZnPicsXHJcbiAgICAgICAgICAgIG5hdlRpdGxlczoge1xyXG4gICAgICAgICAgICAgICAgZGF5czogJ01NLCA8aT55eXl5PC9pPicsXHJcbiAgICAgICAgICAgICAgICBtb250aHM6ICd5eXl5JyxcclxuICAgICAgICAgICAgICAgIHllYXJzOiAneXl5eTEgLSB5eXl5MidcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIHRpbWVwaWNrZXJcclxuICAgICAgICAgICAgdGltZXBpY2tlcjogZmFsc2UsXHJcbiAgICAgICAgICAgIG9ubHlUaW1lcGlja2VyOiBmYWxzZSxcclxuICAgICAgICAgICAgZGF0ZVRpbWVTZXBhcmF0b3I6ICcgJyxcclxuICAgICAgICAgICAgdGltZUZvcm1hdDogJycsXHJcbiAgICAgICAgICAgIG1pbkhvdXJzOiAwLFxyXG4gICAgICAgICAgICBtYXhIb3VyczogMjQsXHJcbiAgICAgICAgICAgIG1pbk1pbnV0ZXM6IDAsXHJcbiAgICAgICAgICAgIG1heE1pbnV0ZXM6IDU5LFxyXG4gICAgICAgICAgICBob3Vyc1N0ZXA6IDEsXHJcbiAgICAgICAgICAgIG1pbnV0ZXNTdGVwOiAxLFxyXG5cclxuICAgICAgICAgICAgLy8gZXZlbnRzXHJcbiAgICAgICAgICAgIG9uU2VsZWN0OiAnJyxcclxuICAgICAgICAgICAgb25TaG93OiAnJyxcclxuICAgICAgICAgICAgb25IaWRlOiAnJyxcclxuICAgICAgICAgICAgb25DaGFuZ2VNb250aDogJycsXHJcbiAgICAgICAgICAgIG9uQ2hhbmdlWWVhcjogJycsXHJcbiAgICAgICAgICAgIG9uQ2hhbmdlRGVjYWRlOiAnJyxcclxuICAgICAgICAgICAgb25DaGFuZ2VWaWV3OiAnJyxcclxuICAgICAgICAgICAgb25SZW5kZXJDZWxsOiAnJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaG90S2V5cyA9IHtcclxuICAgICAgICAgICAgJ2N0cmxSaWdodCc6IFsxNywgMzldLFxyXG4gICAgICAgICAgICAnY3RybFVwJzogWzE3LCAzOF0sXHJcbiAgICAgICAgICAgICdjdHJsTGVmdCc6IFsxNywgMzddLFxyXG4gICAgICAgICAgICAnY3RybERvd24nOiBbMTcsIDQwXSxcclxuICAgICAgICAgICAgJ3NoaWZ0UmlnaHQnOiBbMTYsIDM5XSxcclxuICAgICAgICAgICAgJ3NoaWZ0VXAnOiBbMTYsIDM4XSxcclxuICAgICAgICAgICAgJ3NoaWZ0TGVmdCc6IFsxNiwgMzddLFxyXG4gICAgICAgICAgICAnc2hpZnREb3duJzogWzE2LCA0MF0sXHJcbiAgICAgICAgICAgICdhbHRVcCc6IFsxOCwgMzhdLFxyXG4gICAgICAgICAgICAnYWx0UmlnaHQnOiBbMTgsIDM5XSxcclxuICAgICAgICAgICAgJ2FsdExlZnQnOiBbMTgsIDM3XSxcclxuICAgICAgICAgICAgJ2FsdERvd24nOiBbMTgsIDQwXSxcclxuICAgICAgICAgICAgJ2N0cmxTaGlmdFVwJzogWzE2LCAxNywgMzhdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkYXRlcGlja2VyO1xyXG5cclxuICAgIHZhciBEYXRlcGlja2VyICA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuZWwgPSBlbDtcclxuICAgICAgICB0aGlzLiRlbCA9ICQoZWwpO1xyXG5cclxuICAgICAgICB0aGlzLm9wdHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMsIHRoaXMuJGVsLmRhdGEoKSk7XHJcblxyXG4gICAgICAgIGlmICgkYm9keSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgJGJvZHkgPSAkKCdib2R5Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMub3B0cy5zdGFydERhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRzLnN0YXJ0RGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5lbC5ub2RlTmFtZSA9PSAnSU5QVVQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWxJc0lucHV0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm9wdHMuYWx0RmllbGQpIHtcclxuICAgICAgICAgICAgdGhpcy4kYWx0RmllbGQgPSB0eXBlb2YgdGhpcy5vcHRzLmFsdEZpZWxkID09ICdzdHJpbmcnID8gJCh0aGlzLm9wdHMuYWx0RmllbGQpIDogdGhpcy5vcHRzLmFsdEZpZWxkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbml0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNpbGVudCA9IGZhbHNlOyAvLyBOZWVkIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmVuZGVyaW5nXHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudERhdGUgPSB0aGlzLm9wdHMuc3RhcnREYXRlO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFZpZXcgPSB0aGlzLm9wdHMudmlldztcclxuICAgICAgICB0aGlzLl9jcmVhdGVTaG9ydEN1dHMoKTtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZXMgPSBbXTtcclxuICAgICAgICB0aGlzLnZpZXdzID0ge307XHJcbiAgICAgICAgdGhpcy5rZXlzID0gW107XHJcbiAgICAgICAgdGhpcy5taW5SYW5nZSA9ICcnO1xyXG4gICAgICAgIHRoaXMubWF4UmFuZ2UgPSAnJztcclxuICAgICAgICB0aGlzLl9wcmV2T25TZWxlY3RWYWx1ZSA9ICcnO1xyXG5cclxuICAgICAgICB0aGlzLmluaXQoKVxyXG4gICAgfTtcclxuXHJcbiAgICBkYXRlcGlja2VyID0gRGF0ZXBpY2tlcjtcclxuXHJcbiAgICBkYXRlcGlja2VyLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBWRVJTSU9OOiBWRVJTSU9OLFxyXG4gICAgICAgIHZpZXdJbmRleGVzOiBbJ2RheXMnLCAnbW9udGhzJywgJ3llYXJzJ10sXHJcblxyXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFjb250YWluZXJCdWlsdCAmJiAhdGhpcy5vcHRzLmlubGluZSAmJiB0aGlzLmVsSXNJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYnVpbGREYXRlcGlja2Vyc0NvbnRhaW5lcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2J1aWxkQmFzZUh0bWwoKTtcclxuICAgICAgICAgICAgdGhpcy5fZGVmaW5lTG9jYWxlKHRoaXMub3B0cy5sYW5ndWFnZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3N5bmNXaXRoTWluTWF4RGF0ZXMoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVsSXNJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdHMuaW5saW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGV4dHJhIGNsYXNzZXMgZm9yIHByb3BlciB0cmFuc2l0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uQ2xhc3Nlcyh0aGlzLm9wdHMucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRFdmVudHMoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5rZXlib2FyZE5hdiAmJiAhdGhpcy5vcHRzLm9ubHlUaW1lcGlja2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmluZEtleWJvYXJkRXZlbnRzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRkYXRlcGlja2VyLm9uKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93bkRhdGVwaWNrZXIuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRkYXRlcGlja2VyLm9uKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwRGF0ZXBpY2tlci5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5jbGFzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRkYXRlcGlja2VyLmFkZENsYXNzKHRoaXMub3B0cy5jbGFzc2VzKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnRpbWVwaWNrZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZXBpY2tlciA9IG5ldyAkLmZuLmRhdGVwaWNrZXIuVGltZXBpY2tlcih0aGlzLCB0aGlzLm9wdHMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZFRpbWVwaWNrZXJFdmVudHMoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5vbmx5VGltZXBpY2tlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kZGF0ZXBpY2tlci5hZGRDbGFzcygnLW9ubHktdGltZXBpY2tlci0nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy52aWV3c1t0aGlzLmN1cnJlbnRWaWV3XSA9IG5ldyAkLmZuLmRhdGVwaWNrZXIuQm9keSh0aGlzLCB0aGlzLmN1cnJlbnRWaWV3LCB0aGlzLm9wdHMpO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdzW3RoaXMuY3VycmVudFZpZXddLnNob3coKTtcclxuICAgICAgICAgICAgdGhpcy5uYXYgPSBuZXcgJC5mbi5kYXRlcGlja2VyLk5hdmlnYXRpb24odGhpcywgdGhpcy5vcHRzKTtcclxuICAgICAgICAgICAgdGhpcy52aWV3ID0gdGhpcy5jdXJyZW50VmlldztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuJGVsLm9uKCdjbGlja0NlbGwuYWRwJywgdGhpcy5fb25DbGlja0NlbGwuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuJGRhdGVwaWNrZXIub24oJ21vdXNlZW50ZXInLCAnLmRhdGVwaWNrZXItLWNlbGwnLCB0aGlzLl9vbk1vdXNlRW50ZXJDZWxsLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLiRkYXRlcGlja2VyLm9uKCdtb3VzZWxlYXZlJywgJy5kYXRlcGlja2VyLS1jZWxsJywgdGhpcy5fb25Nb3VzZUxlYXZlQ2VsbC5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGVkID0gdHJ1ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfY3JlYXRlU2hvcnRDdXRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWluRGF0ZSA9IHRoaXMub3B0cy5taW5EYXRlID8gdGhpcy5vcHRzLm1pbkRhdGUgOiBuZXcgRGF0ZSgtODYzOTk5OTkxMzYwMDAwMCk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4RGF0ZSA9IHRoaXMub3B0cy5tYXhEYXRlID8gdGhpcy5vcHRzLm1heERhdGUgOiBuZXcgRGF0ZSg4NjM5OTk5OTEzNjAwMDAwKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYmluZEV2ZW50cyA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy4kZWwub24odGhpcy5vcHRzLnNob3dFdmVudCArICcuYWRwJywgdGhpcy5fb25TaG93RXZlbnQuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuJGVsLm9uKCdtb3VzZXVwLmFkcCcsIHRoaXMuX29uTW91c2VVcEVsLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLiRlbC5vbignYmx1ci5hZHAnLCB0aGlzLl9vbkJsdXIuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuJGVsLm9uKCdrZXl1cC5hZHAnLCB0aGlzLl9vbktleVVwR2VuZXJhbC5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUuYWRwJywgdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgICQoJ2JvZHknKS5vbignbW91c2V1cC5hZHAnLCB0aGlzLl9vbk1vdXNlVXBCb2R5LmJpbmQodGhpcykpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9iaW5kS2V5Ym9hcmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy4kZWwub24oJ2tleWRvd24uYWRwJywgdGhpcy5fb25LZXlEb3duLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLiRlbC5vbigna2V5dXAuYWRwJywgdGhpcy5fb25LZXlVcC5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgdGhpcy4kZWwub24oJ2hvdEtleS5hZHAnLCB0aGlzLl9vbkhvdEtleS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYmluZFRpbWVwaWNrZXJFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy4kZWwub24oJ3RpbWVDaGFuZ2UuYWRwJywgdGhpcy5fb25UaW1lQ2hhbmdlLmJpbmQodGhpcykpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzV2Vla2VuZDogZnVuY3Rpb24gKGRheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRzLndlZWtlbmRzLmluZGV4T2YoZGF5KSAhPT0gLTE7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2RlZmluZUxvY2FsZTogZnVuY3Rpb24gKGxhbmcpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYW5nID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYyA9ICQuZm4uZGF0ZXBpY2tlci5sYW5ndWFnZVtsYW5nXTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5sb2MpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NhblxcJ3QgZmluZCBsYW5ndWFnZSBcIicgKyBsYW5nICsgJ1wiIGluIERhdGVwaWNrZXIubGFuZ3VhZ2UsIHdpbGwgdXNlIFwicnVcIiBpbnN0ZWFkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2MgPSAkLmV4dGVuZCh0cnVlLCB7fSwgJC5mbi5kYXRlcGlja2VyLmxhbmd1YWdlLnJ1KVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMubG9jID0gJC5leHRlbmQodHJ1ZSwge30sICQuZm4uZGF0ZXBpY2tlci5sYW5ndWFnZS5ydSwgJC5mbi5kYXRlcGlja2VyLmxhbmd1YWdlW2xhbmddKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2MgPSAkLmV4dGVuZCh0cnVlLCB7fSwgJC5mbi5kYXRlcGlja2VyLmxhbmd1YWdlLnJ1LCBsYW5nKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmRhdGVGb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9jLmRhdGVGb3JtYXQgPSB0aGlzLm9wdHMuZGF0ZUZvcm1hdFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnRpbWVGb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9jLnRpbWVGb3JtYXQgPSB0aGlzLm9wdHMudGltZUZvcm1hdFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmZpcnN0RGF5ICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2MuZmlyc3REYXkgPSB0aGlzLm9wdHMuZmlyc3REYXlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy50aW1lcGlja2VyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYy5kYXRlRm9ybWF0ID0gW3RoaXMubG9jLmRhdGVGb3JtYXQsIHRoaXMubG9jLnRpbWVGb3JtYXRdLmpvaW4odGhpcy5vcHRzLmRhdGVUaW1lU2VwYXJhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5vbmx5VGltZXBpY2tlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2MuZGF0ZUZvcm1hdCA9IHRoaXMubG9jLnRpbWVGb3JtYXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBib3VuZGFyeSA9IHRoaXMuX2dldFdvcmRCb3VuZGFyeVJlZ0V4cDtcclxuICAgICAgICAgICAgaWYgKHRoaXMubG9jLnRpbWVGb3JtYXQubWF0Y2goYm91bmRhcnkoJ2FhJykpIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYy50aW1lRm9ybWF0Lm1hdGNoKGJvdW5kYXJ5KCdBQScpKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgdGhpcy5hbXBtID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9idWlsZERhdGVwaWNrZXJzQ29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lckJ1aWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgJGJvZHkuYXBwZW5kKCc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlcnMtY29udGFpbmVyXCIgaWQ9XCJkYXRlcGlja2Vycy1jb250YWluZXJcIj48L2Rpdj4nKTtcclxuICAgICAgICAgICAgJGRhdGVwaWNrZXJzQ29udGFpbmVyID0gJCgnI2RhdGVwaWNrZXJzLWNvbnRhaW5lcicpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9idWlsZEJhc2VIdG1sOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciAkYXBwZW5kVGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgJGlubGluZSA9ICQoJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWlubGluZVwiPicpO1xyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5lbC5ub2RlTmFtZSA9PSAnSU5QVVQnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0cy5pbmxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAkYXBwZW5kVGFyZ2V0ID0gJGRhdGVwaWNrZXJzQ29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAkYXBwZW5kVGFyZ2V0ID0gJGlubGluZS5pbnNlcnRBZnRlcih0aGlzLiRlbClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICRhcHBlbmRUYXJnZXQgPSAkaW5saW5lLmFwcGVuZFRvKHRoaXMuJGVsKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLiRkYXRlcGlja2VyID0gJChiYXNlVGVtcGxhdGUpLmFwcGVuZFRvKCRhcHBlbmRUYXJnZXQpO1xyXG4gICAgICAgICAgICB0aGlzLiRjb250ZW50ID0gJCgnLmRhdGVwaWNrZXItLWNvbnRlbnQnLCB0aGlzLiRkYXRlcGlja2VyKTtcclxuICAgICAgICAgICAgdGhpcy4kbmF2ID0gJCgnLmRhdGVwaWNrZXItLW5hdicsIHRoaXMuJGRhdGVwaWNrZXIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF90cmlnZ2VyT25DaGFuZ2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGVkRGF0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGZyb20gdHJpZ2dlcmluZyBtdWx0aXBsZSBvblNlbGVjdCBjYWxsYmFjayB3aXRoIHNhbWUgYXJndW1lbnQgKGVtcHR5IHN0cmluZykgaW4gSUUxMC0xMVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXZPblNlbGVjdFZhbHVlID09PSAnJykgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldk9uU2VsZWN0VmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdHMub25TZWxlY3QoJycsICcnLCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNlbGVjdGVkRGF0ZXMgPSB0aGlzLnNlbGVjdGVkRGF0ZXMsXHJcbiAgICAgICAgICAgICAgICBwYXJzZWRTZWxlY3RlZCA9IGRhdGVwaWNrZXIuZ2V0UGFyc2VkRGF0ZShzZWxlY3RlZERhdGVzWzBdKSxcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZERhdGVzLFxyXG4gICAgICAgICAgICAgICAgX3RoaXMgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgZGF0ZXMgPSBuZXcgRGF0ZShcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRTZWxlY3RlZC55ZWFyLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFNlbGVjdGVkLm1vbnRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFNlbGVjdGVkLmRhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkU2VsZWN0ZWQuaG91cnMsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkU2VsZWN0ZWQubWludXRlc1xyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWREYXRlcyA9IHNlbGVjdGVkRGF0ZXMubWFwKGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZvcm1hdERhdGUoX3RoaXMubG9jLmRhdGVGb3JtYXQsIGRhdGUpXHJcbiAgICAgICAgICAgICAgICB9KS5qb2luKHRoaXMub3B0cy5tdWx0aXBsZURhdGVzU2VwYXJhdG9yKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgZGF0ZXMgYXJyYXksIHRvIHNlcGFyYXRlIGl0IGZyb20gb3JpZ2luYWwgc2VsZWN0ZWREYXRlc1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLm11bHRpcGxlRGF0ZXMgfHwgdGhpcy5vcHRzLnJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlcyA9IHNlbGVjdGVkRGF0ZXMubWFwKGZ1bmN0aW9uKGRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkRGF0ZSA9IGRhdGVwaWNrZXIuZ2V0UGFyc2VkRGF0ZShkYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGUueWVhcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZS5tb250aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZS5kYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlLmhvdXJzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlLm1pbnV0ZXNcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fcHJldk9uU2VsZWN0VmFsdWUgPSBmb3JtYXR0ZWREYXRlcztcclxuICAgICAgICAgICAgdGhpcy5vcHRzLm9uU2VsZWN0KGZvcm1hdHRlZERhdGVzLCBkYXRlcywgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMucGFyc2VkRGF0ZSxcclxuICAgICAgICAgICAgICAgIG8gPSB0aGlzLm9wdHM7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy52aWV3KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdkYXlzJzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUgPSBuZXcgRGF0ZShkLnllYXIsIGQubW9udGggKyAxLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoby5vbkNoYW5nZU1vbnRoKSBvLm9uQ2hhbmdlTW9udGgodGhpcy5wYXJzZWREYXRlLm1vbnRoLCB0aGlzLnBhcnNlZERhdGUueWVhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aHMnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKGQueWVhciArIDEsIGQubW9udGgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvLm9uQ2hhbmdlWWVhcikgby5vbkNoYW5nZVllYXIodGhpcy5wYXJzZWREYXRlLnllYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAneWVhcnMnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKGQueWVhciArIDEwLCAwLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoby5vbkNoYW5nZURlY2FkZSkgby5vbkNoYW5nZURlY2FkZSh0aGlzLmN1ckRlY2FkZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwcmV2OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5wYXJzZWREYXRlLFxyXG4gICAgICAgICAgICAgICAgbyA9IHRoaXMub3B0cztcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnZpZXcpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2RheXMnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKGQueWVhciwgZC5tb250aCAtIDEsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvLm9uQ2hhbmdlTW9udGgpIG8ub25DaGFuZ2VNb250aCh0aGlzLnBhcnNlZERhdGUubW9udGgsIHRoaXMucGFyc2VkRGF0ZS55ZWFyKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ21vbnRocyc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlID0gbmV3IERhdGUoZC55ZWFyIC0gMSwgZC5tb250aCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8ub25DaGFuZ2VZZWFyKSBvLm9uQ2hhbmdlWWVhcih0aGlzLnBhcnNlZERhdGUueWVhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd5ZWFycyc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlID0gbmV3IERhdGUoZC55ZWFyIC0gMTAsIDAsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvLm9uQ2hhbmdlRGVjYWRlKSBvLm9uQ2hhbmdlRGVjYWRlKHRoaXMuY3VyRGVjYWRlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGZvcm1hdERhdGU6IGZ1bmN0aW9uIChzdHJpbmcsIGRhdGUpIHtcclxuICAgICAgICAgICAgZGF0ZSA9IGRhdGUgfHwgdGhpcy5kYXRlO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgYm91bmRhcnkgPSB0aGlzLl9nZXRXb3JkQm91bmRhcnlSZWdFeHAsXHJcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSB0aGlzLmxvYyxcclxuICAgICAgICAgICAgICAgIGxlYWRpbmdaZXJvID0gZGF0ZXBpY2tlci5nZXRMZWFkaW5nWmVyb051bSxcclxuICAgICAgICAgICAgICAgIGRlY2FkZSA9IGRhdGVwaWNrZXIuZ2V0RGVjYWRlKGRhdGUpLFxyXG4gICAgICAgICAgICAgICAgZCA9IGRhdGVwaWNrZXIuZ2V0UGFyc2VkRGF0ZShkYXRlKSxcclxuICAgICAgICAgICAgICAgIGZ1bGxIb3VycyA9IGQuZnVsbEhvdXJzLFxyXG4gICAgICAgICAgICAgICAgaG91cnMgPSBkLmhvdXJzLFxyXG4gICAgICAgICAgICAgICAgYW1wbSA9IHN0cmluZy5tYXRjaChib3VuZGFyeSgnYWEnKSkgfHwgc3RyaW5nLm1hdGNoKGJvdW5kYXJ5KCdBQScpKSxcclxuICAgICAgICAgICAgICAgIGRheVBlcmlvZCA9ICdhbScsXHJcbiAgICAgICAgICAgICAgICByZXBsYWNlciA9IHRoaXMuX3JlcGxhY2VyLFxyXG4gICAgICAgICAgICAgICAgdmFsaWRIb3VycztcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMudGltZXBpY2tlciAmJiB0aGlzLnRpbWVwaWNrZXIgJiYgYW1wbSkge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRIb3VycyA9IHRoaXMudGltZXBpY2tlci5fZ2V0VmFsaWRIb3Vyc0Zyb21EYXRlKGRhdGUsIGFtcG0pO1xyXG4gICAgICAgICAgICAgICAgZnVsbEhvdXJzID0gbGVhZGluZ1plcm8odmFsaWRIb3Vycy5ob3Vycyk7XHJcbiAgICAgICAgICAgICAgICBob3VycyA9IHZhbGlkSG91cnMuaG91cnM7XHJcbiAgICAgICAgICAgICAgICBkYXlQZXJpb2QgPSB2YWxpZEhvdXJzLmRheVBlcmlvZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIC9ALy50ZXN0KHJlc3VsdCk6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL0AvLCBkYXRlLmdldFRpbWUoKSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIC9hYS8udGVzdChyZXN1bHQpOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlcGxhY2VyKHJlc3VsdCwgYm91bmRhcnkoJ2FhJyksIGRheVBlcmlvZCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIC9BQS8udGVzdChyZXN1bHQpOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlcGxhY2VyKHJlc3VsdCwgYm91bmRhcnkoJ0FBJyksIGRheVBlcmlvZC50b1VwcGVyQ2FzZSgpKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgL2RkLy50ZXN0KHJlc3VsdCk6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVwbGFjZXIocmVzdWx0LCBib3VuZGFyeSgnZGQnKSwgZC5mdWxsRGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIC9kLy50ZXN0KHJlc3VsdCk6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVwbGFjZXIocmVzdWx0LCBib3VuZGFyeSgnZCcpLCBkLmRhdGUpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAvREQvLnRlc3QocmVzdWx0KTpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXBsYWNlcihyZXN1bHQsIGJvdW5kYXJ5KCdERCcpLCBsb2NhbGUuZGF5c1tkLmRheV0pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAvRC8udGVzdChyZXN1bHQpOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlcGxhY2VyKHJlc3VsdCwgYm91bmRhcnkoJ0QnKSwgbG9jYWxlLmRheXNTaG9ydFtkLmRheV0pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAvbW0vLnRlc3QocmVzdWx0KTpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXBsYWNlcihyZXN1bHQsIGJvdW5kYXJ5KCdtbScpLCBkLmZ1bGxNb250aCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIC9tLy50ZXN0KHJlc3VsdCk6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVwbGFjZXIocmVzdWx0LCBib3VuZGFyeSgnbScpLCBkLm1vbnRoICsgMSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIC9NTS8udGVzdChyZXN1bHQpOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlcGxhY2VyKHJlc3VsdCwgYm91bmRhcnkoJ01NJyksIHRoaXMubG9jLm1vbnRoc1tkLm1vbnRoXSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIC9NLy50ZXN0KHJlc3VsdCk6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVwbGFjZXIocmVzdWx0LCBib3VuZGFyeSgnTScpLCBsb2NhbGUubW9udGhzU2hvcnRbZC5tb250aF0pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAvaWkvLnRlc3QocmVzdWx0KTpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXBsYWNlcihyZXN1bHQsIGJvdW5kYXJ5KCdpaScpLCBkLmZ1bGxNaW51dGVzKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgL2kvLnRlc3QocmVzdWx0KTpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXBsYWNlcihyZXN1bHQsIGJvdW5kYXJ5KCdpJyksIGQubWludXRlcyk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIC9oaC8udGVzdChyZXN1bHQpOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlcGxhY2VyKHJlc3VsdCwgYm91bmRhcnkoJ2hoJyksIGZ1bGxIb3Vycyk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIC9oLy50ZXN0KHJlc3VsdCk6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVwbGFjZXIocmVzdWx0LCBib3VuZGFyeSgnaCcpLCBob3Vycyk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIC95eXl5Ly50ZXN0KHJlc3VsdCk6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVwbGFjZXIocmVzdWx0LCBib3VuZGFyeSgneXl5eScpLCBkLnllYXIpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAveXl5eTEvLnRlc3QocmVzdWx0KTpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXBsYWNlcihyZXN1bHQsIGJvdW5kYXJ5KCd5eXl5MScpLCBkZWNhZGVbMF0pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAveXl5eTIvLnRlc3QocmVzdWx0KTpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXBsYWNlcihyZXN1bHQsIGJvdW5kYXJ5KCd5eXl5MicpLCBkZWNhZGVbMV0pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAveXkvLnRlc3QocmVzdWx0KTpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXBsYWNlcihyZXN1bHQsIGJvdW5kYXJ5KCd5eScpLCBkLnllYXIudG9TdHJpbmcoKS5zbGljZSgtMikpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9yZXBsYWNlcjogZnVuY3Rpb24gKHN0ciwgcmVnLCBkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZShyZWcsIGZ1bmN0aW9uIChtYXRjaCwgcDEscDIscDMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwMSArIGRhdGEgKyBwMztcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0V29yZEJvdW5kYXJ5UmVnRXhwOiBmdW5jdGlvbiAoc2lnbikge1xyXG4gICAgICAgICAgICB2YXIgc3ltYm9scyA9ICdcXFxcc3xcXFxcLnwtfC98XFxcXFxcXFx8LHxcXFxcJHxcXFxcIXxcXFxcP3w6fDsnO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJyhefD58JyArIHN5bWJvbHMgKyAnKSgnICsgc2lnbiArICcpKCR8PHwnICsgc3ltYm9scyArICcpJywgJ2cnKTtcclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgc2VsZWN0RGF0ZTogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIG9wdHMgPSBfdGhpcy5vcHRzLFxyXG4gICAgICAgICAgICAgICAgZCA9IF90aGlzLnBhcnNlZERhdGUsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZERhdGVzID0gX3RoaXMuc2VsZWN0ZWREYXRlcyxcclxuICAgICAgICAgICAgICAgIGxlbiA9IHNlbGVjdGVkRGF0ZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgbmV3RGF0ZSA9ICcnO1xyXG5cclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIGRhdGUuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbGVjdERhdGUoZClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIShkYXRlIGluc3RhbmNlb2YgRGF0ZSkpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGFzdFNlbGVjdGVkRGF0ZSA9IGRhdGU7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgbmV3IHRpbWUgdmFsdWVzIGZyb20gRGF0ZVxyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lcGlja2VyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVwaWNrZXIuX3NldFRpbWUoZGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE9uIHRoaXMgc3RlcCB0aW1lcGlja2VyIHdpbGwgc2V0IHZhbGlkIHZhbHVlcyBpbiBpdCdzIGluc3RhbmNlXHJcbiAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyKCdzZWxlY3REYXRlJywgZGF0ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgY29ycmVjdCB0aW1lIHZhbHVlcyBhZnRlciB0aW1lcGlja2VyJ3MgdmFsaWRhdGlvblxyXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGZyb20gc2V0dGluZyBob3VycyBvciBtaW51dGVzIHdoaWNoIHZhbHVlcyBhcmUgbGVzc2VyIHRoZW4gYG1pbmAgdmFsdWUgb3JcclxuICAgICAgICAgICAgLy8gZ3JlYXRlciB0aGVuIGBtYXhgIHZhbHVlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVwaWNrZXIpIHtcclxuICAgICAgICAgICAgICAgIGRhdGUuc2V0SG91cnModGhpcy50aW1lcGlja2VyLmhvdXJzKTtcclxuICAgICAgICAgICAgICAgIGRhdGUuc2V0TWludXRlcyh0aGlzLnRpbWVwaWNrZXIubWludXRlcylcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF90aGlzLnZpZXcgPT0gJ2RheXMnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZS5nZXRNb250aCgpICE9IGQubW9udGggJiYgb3B0cy5tb3ZlVG9PdGhlck1vbnRoc09uU2VsZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF90aGlzLnZpZXcgPT0gJ3llYXJzJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGUuZ2V0RnVsbFllYXIoKSAhPSBkLnllYXIgJiYgb3B0cy5tb3ZlVG9PdGhlclllYXJzT25TZWxlY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG5ld0RhdGUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNpbGVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXRlID0gbmV3RGF0ZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNpbGVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubmF2Ll9yZW5kZXIoKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0cy5tdWx0aXBsZURhdGVzICYmICFvcHRzLnJhbmdlKSB7IC8vIFNldCBwcmlvcml0eSB0byByYW5nZSBmdW5jdGlvbmFsaXR5XHJcbiAgICAgICAgICAgICAgICBpZiAobGVuID09PSBvcHRzLm11bHRpcGxlRGF0ZXMpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2lzU2VsZWN0ZWQoZGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZWxlY3RlZERhdGVzLnB1c2goZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0cy5yYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlbiA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VsZWN0ZWREYXRlcyA9IFtkYXRlXTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5taW5SYW5nZSA9IGRhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWF4UmFuZ2UgPSAnJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVuID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZWxlY3RlZERhdGVzLnB1c2goZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5tYXhSYW5nZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1heFJhbmdlID0gZGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5taW5SYW5nZSA9IGRhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN3YXAgZGF0ZXMgaWYgdGhleSB3ZXJlIHNlbGVjdGVkIHZpYSBkcC5zZWxlY3REYXRlKCkgYW5kIHNlY29uZCBkYXRlIHdhcyBzbWFsbGVyIHRoZW4gZmlyc3RcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZXBpY2tlci5iaWdnZXIoX3RoaXMubWF4UmFuZ2UsIF90aGlzLm1pblJhbmdlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXhSYW5nZSA9IF90aGlzLm1pblJhbmdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5taW5SYW5nZSA9IGRhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbGVjdGVkRGF0ZXMgPSBbX3RoaXMubWluUmFuZ2UsIF90aGlzLm1heFJhbmdlXVxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VsZWN0ZWREYXRlcyA9IFtkYXRlXTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5taW5SYW5nZSA9IGRhdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWxlY3RlZERhdGVzID0gW2RhdGVdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfdGhpcy5fc2V0SW5wdXRWYWx1ZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9wdHMub25TZWxlY3QpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyT25DaGFuZ2UoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdHMuYXV0b0Nsb3NlICYmICF0aGlzLnRpbWVwaWNrZXJJc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvcHRzLm11bHRpcGxlRGF0ZXMgJiYgIW9wdHMucmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMucmFuZ2UgJiYgX3RoaXMuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX3RoaXMudmlld3NbdGhpcy5jdXJyZW50Vmlld10uX3JlbmRlcigpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVtb3ZlRGF0ZTogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZERhdGVzLFxyXG4gICAgICAgICAgICAgICAgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgaWYgKCEoZGF0ZSBpbnN0YW5jZW9mIERhdGUpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQuc29tZShmdW5jdGlvbiAoY3VyRGF0ZSwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGVwaWNrZXIuaXNTYW1lKGN1ckRhdGUsIGRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQuc3BsaWNlKGksIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnNlbGVjdGVkRGF0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1pblJhbmdlID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1heFJhbmdlID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxhc3RTZWxlY3RlZERhdGUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sYXN0U2VsZWN0ZWREYXRlID0gX3RoaXMuc2VsZWN0ZWREYXRlc1tfdGhpcy5zZWxlY3RlZERhdGVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlld3NbX3RoaXMuY3VycmVudFZpZXddLl9yZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0SW5wdXRWYWx1ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0cy5vblNlbGVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdHJpZ2dlck9uQ2hhbmdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRvZGF5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2lsZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy52aWV3ID0gdGhpcy5vcHRzLm1pblZpZXc7XHJcbiAgICAgICAgICAgIHRoaXMuc2lsZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnRvZGF5QnV0dG9uIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3REYXRlKHRoaXMub3B0cy50b2RheUJ1dHRvbilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLm1pblJhbmdlID0gJyc7XHJcbiAgICAgICAgICAgIHRoaXMubWF4UmFuZ2UgPSAnJztcclxuICAgICAgICAgICAgdGhpcy52aWV3c1t0aGlzLmN1cnJlbnRWaWV3XS5fcmVuZGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldElucHV0VmFsdWUoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5vblNlbGVjdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlck9uQ2hhbmdlKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgZGF0ZXBpY2tlciBvcHRpb25zXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBwYXJhbSAtIHBhcmFtZXRlcidzIG5hbWUgdG8gdXBkYXRlLiBJZiBvYmplY3QgdGhlbiBpdCB3aWxsIGV4dGVuZCBjdXJyZW50IG9wdGlvbnNcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8T2JqZWN0fSBbdmFsdWVdIC0gbmV3IHBhcmFtIHZhbHVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAocGFyYW0sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgbGFzdFNlbGVjdGVkRGF0ZSA9IHRoaXMubGFzdFNlbGVjdGVkRGF0ZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChsZW4gPT0gMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzW3BhcmFtXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxlbiA9PSAxICYmIHR5cGVvZiBwYXJhbSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzID0gJC5leHRlbmQodHJ1ZSwgdGhpcy5vcHRzLCBwYXJhbSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2hvcnRDdXRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3N5bmNXaXRoTWluTWF4RGF0ZXMoKTtcclxuICAgICAgICAgICAgdGhpcy5fZGVmaW5lTG9jYWxlKHRoaXMub3B0cy5sYW5ndWFnZSk7XHJcbiAgICAgICAgICAgIHRoaXMubmF2Ll9hZGRCdXR0b25zSWZOZWVkKCk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRzLm9ubHlUaW1lcGlja2VyKSB0aGlzLm5hdi5fcmVuZGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlld3NbdGhpcy5jdXJyZW50Vmlld10uX3JlbmRlcigpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZWxJc0lucHV0ICYmICF0aGlzLm9wdHMuaW5saW5lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbkNsYXNzZXModGhpcy5vcHRzLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHRoaXMub3B0cy5wb3NpdGlvbilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5jbGFzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRkYXRlcGlja2VyLmFkZENsYXNzKHRoaXMub3B0cy5jbGFzc2VzKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLm9ubHlUaW1lcGlja2VyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRkYXRlcGlja2VyLmFkZENsYXNzKCctb25seS10aW1lcGlja2VyLScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnRpbWVwaWNrZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0U2VsZWN0ZWREYXRlKSB0aGlzLnRpbWVwaWNrZXIuX2hhbmRsZURhdGUobGFzdFNlbGVjdGVkRGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVwaWNrZXIuX3VwZGF0ZVJhbmdlcygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lcGlja2VyLl91cGRhdGVDdXJyZW50VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hhbmdlIGhvdXJzIGFuZCBtaW51dGVzIGlmIGl0J3MgdmFsdWVzIGhhdmUgYmVlbiBjaGFuZ2VkIHRocm91Z2ggbWluL21heCBob3Vycy9taW51dGVzXHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdFNlbGVjdGVkRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RTZWxlY3RlZERhdGUuc2V0SG91cnModGhpcy50aW1lcGlja2VyLmhvdXJzKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0U2VsZWN0ZWREYXRlLnNldE1pbnV0ZXModGhpcy50aW1lcGlja2VyLm1pbnV0ZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9zZXRJbnB1dFZhbHVlKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfc3luY1dpdGhNaW5NYXhEYXRlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY3VyVGltZSA9IHRoaXMuZGF0ZS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2lsZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWluVGltZSA+IGN1clRpbWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSA9IHRoaXMubWluRGF0ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMubWF4VGltZSA8IGN1clRpbWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSA9IHRoaXMubWF4RGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNpbGVudCA9IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9pc1NlbGVjdGVkOiBmdW5jdGlvbiAoY2hlY2tEYXRlLCBjZWxsVHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlcy5zb21lKGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZXBpY2tlci5pc1NhbWUoZGF0ZSwgY2hlY2tEYXRlLCBjZWxsVHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBkYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfc2V0SW5wdXRWYWx1ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgb3B0cyA9IF90aGlzLm9wdHMsXHJcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBfdGhpcy5sb2MuZGF0ZUZvcm1hdCxcclxuICAgICAgICAgICAgICAgIGFsdEZvcm1hdCA9IG9wdHMuYWx0RmllbGREYXRlRm9ybWF0LFxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy5zZWxlY3RlZERhdGVzLm1hcChmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5mb3JtYXREYXRlKGZvcm1hdCwgZGF0ZSlcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgYWx0VmFsdWVzO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9wdHMuYWx0RmllbGQgJiYgX3RoaXMuJGFsdEZpZWxkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgYWx0VmFsdWVzID0gdGhpcy5zZWxlY3RlZERhdGVzLm1hcChmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5mb3JtYXREYXRlKGFsdEZvcm1hdCwgZGF0ZSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYWx0VmFsdWVzID0gYWx0VmFsdWVzLmpvaW4odGhpcy5vcHRzLm11bHRpcGxlRGF0ZXNTZXBhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kYWx0RmllbGQudmFsKGFsdFZhbHVlcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuam9pbih0aGlzLm9wdHMubXVsdGlwbGVEYXRlc1NlcGFyYXRvcik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLiRlbC52YWwodmFsdWUpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2sgaWYgZGF0ZSBpcyBiZXR3ZWVuIG1pbkRhdGUgYW5kIG1heERhdGVcclxuICAgICAgICAgKiBAcGFyYW0gZGF0ZSB7b2JqZWN0fSAtIGRhdGUgb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHR5cGUge3N0cmluZ30gLSBjZWxsIHR5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9pc0luUmFuZ2U6IGZ1bmN0aW9uIChkYXRlLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIHZhciB0aW1lID0gZGF0ZS5nZXRUaW1lKCksXHJcbiAgICAgICAgICAgICAgICBkID0gZGF0ZXBpY2tlci5nZXRQYXJzZWREYXRlKGRhdGUpLFxyXG4gICAgICAgICAgICAgICAgbWluID0gZGF0ZXBpY2tlci5nZXRQYXJzZWREYXRlKHRoaXMubWluRGF0ZSksXHJcbiAgICAgICAgICAgICAgICBtYXggPSBkYXRlcGlja2VyLmdldFBhcnNlZERhdGUodGhpcy5tYXhEYXRlKSxcclxuICAgICAgICAgICAgICAgIGRNaW5UaW1lID0gbmV3IERhdGUoZC55ZWFyLCBkLm1vbnRoLCBtaW4uZGF0ZSkuZ2V0VGltZSgpLFxyXG4gICAgICAgICAgICAgICAgZE1heFRpbWUgPSBuZXcgRGF0ZShkLnllYXIsIGQubW9udGgsIG1heC5kYXRlKS5nZXRUaW1lKCksXHJcbiAgICAgICAgICAgICAgICB0eXBlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBkYXk6IHRpbWUgPj0gdGhpcy5taW5UaW1lICYmIHRpbWUgPD0gdGhpcy5tYXhUaW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoOiBkTWluVGltZSA+PSB0aGlzLm1pblRpbWUgJiYgZE1heFRpbWUgPD0gdGhpcy5tYXhUaW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHllYXI6IGQueWVhciA+PSBtaW4ueWVhciAmJiBkLnllYXIgPD0gbWF4LnllYXJcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlID8gdHlwZXNbdHlwZV0gOiB0eXBlcy5kYXlcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0RGltZW5zaW9uczogZnVuY3Rpb24gKCRlbCkge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gJGVsLm9mZnNldCgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAkZWwub3V0ZXJXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAkZWwub3V0ZXJIZWlnaHQoKSxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgdG9wOiBvZmZzZXQudG9wXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0RGF0ZUZyb21DZWxsOiBmdW5jdGlvbiAoY2VsbCkge1xyXG4gICAgICAgICAgICB2YXIgY3VyRGF0ZSA9IHRoaXMucGFyc2VkRGF0ZSxcclxuICAgICAgICAgICAgICAgIHllYXIgPSBjZWxsLmRhdGEoJ3llYXInKSB8fCBjdXJEYXRlLnllYXIsXHJcbiAgICAgICAgICAgICAgICBtb250aCA9IGNlbGwuZGF0YSgnbW9udGgnKSA9PSB1bmRlZmluZWQgPyBjdXJEYXRlLm1vbnRoIDogY2VsbC5kYXRhKCdtb250aCcpLFxyXG4gICAgICAgICAgICAgICAgZGF0ZSA9IGNlbGwuZGF0YSgnZGF0ZScpIHx8IDE7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGgsIGRhdGUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9zZXRQb3NpdGlvbkNsYXNzZXM6IGZ1bmN0aW9uIChwb3MpIHtcclxuICAgICAgICAgICAgcG9zID0gcG9zLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgIHZhciBtYWluID0gcG9zWzBdLFxyXG4gICAgICAgICAgICAgICAgc2VjID0gcG9zWzFdLFxyXG4gICAgICAgICAgICAgICAgY2xhc3NlcyA9ICdkYXRlcGlja2VyIC0nICsgbWFpbiArICctJyArIHNlYyArICctIC1mcm9tLScgKyBtYWluICsgJy0nO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkgY2xhc3NlcyArPSAnIGFjdGl2ZSc7XHJcblxyXG4gICAgICAgICAgICB0aGlzLiRkYXRlcGlja2VyXHJcbiAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignY2xhc3MnKVxyXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKGNsYXNzZXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiB8fCB0aGlzLm9wdHMucG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICB2YXIgZGltcyA9IHRoaXMuX2dldERpbWVuc2lvbnModGhpcy4kZWwpLFxyXG4gICAgICAgICAgICAgICAgc2VsZkRpbXMgPSB0aGlzLl9nZXREaW1lbnNpb25zKHRoaXMuJGRhdGVwaWNrZXIpLFxyXG4gICAgICAgICAgICAgICAgcG9zID0gcG9zaXRpb24uc3BsaXQoJyAnKSxcclxuICAgICAgICAgICAgICAgIHRvcCwgbGVmdCxcclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMub3B0cy5vZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBtYWluID0gcG9zWzBdLFxyXG4gICAgICAgICAgICAgICAgc2Vjb25kYXJ5ID0gcG9zWzFdO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChtYWluKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IGRpbXMudG9wIC0gc2VsZkRpbXMuaGVpZ2h0IC0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBkaW1zLmxlZnQgKyBkaW1zLndpZHRoICsgb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgICAgICAgICAgICB0b3AgPSBkaW1zLnRvcCArIGRpbXMuaGVpZ2h0ICsgb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGRpbXMubGVmdCAtIHNlbGZEaW1zLndpZHRoIC0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2goc2Vjb25kYXJ5KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IGRpbXMudG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBkaW1zLmxlZnQgKyBkaW1zLndpZHRoIC0gc2VsZkRpbXMud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IGRpbXMudG9wICsgZGltcy5oZWlnaHQgLSBzZWxmRGltcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gZGltcy5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoL2xlZnR8cmlnaHQvLnRlc3QobWFpbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gZGltcy50b3AgKyBkaW1zLmhlaWdodC8yIC0gc2VsZkRpbXMuaGVpZ2h0LzI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGRpbXMubGVmdCArIGRpbXMud2lkdGgvMiAtIHNlbGZEaW1zLndpZHRoLzI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLiRkYXRlcGlja2VyXHJcbiAgICAgICAgICAgICAgICAuY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogdG9wXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG9uU2hvdyA9IHRoaXMub3B0cy5vblNob3c7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHRoaXMub3B0cy5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuJGRhdGVwaWNrZXIuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9uU2hvdykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZFZpc2lvbkV2ZW50cyhvblNob3cpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBvbkhpZGUgPSB0aGlzLm9wdHMub25IaWRlO1xyXG5cclxuICAgICAgICAgICAgdGhpcy4kZGF0ZXBpY2tlclxyXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxyXG4gICAgICAgICAgICAgICAgLmNzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogJy0xMDAwMDBweCdcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gJyc7XHJcbiAgICAgICAgICAgIHRoaXMua2V5cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5pbkZvY3VzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLiRlbC5ibHVyKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAob25IaWRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kVmlzaW9uRXZlbnRzKG9uSGlkZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRvd246IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZVZpZXcoZGF0ZSwgJ2Rvd24nKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB1cDogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlVmlldyhkYXRlLCAndXAnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYmluZFZpc2lvbkV2ZW50czogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGRhdGVwaWNrZXIub2ZmKCd0cmFuc2l0aW9uZW5kLmRwJyk7XHJcbiAgICAgICAgICAgIGV2ZW50KHRoaXMsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy4kZGF0ZXBpY2tlci5vbmUoJ3RyYW5zaXRpb25lbmQuZHAnLCBldmVudC5iaW5kKHRoaXMsIHRoaXMsIHRydWUpKVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9jaGFuZ2VWaWV3OiBmdW5jdGlvbiAoZGF0ZSwgZGlyKSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSBkYXRlIHx8IHRoaXMuZm9jdXNlZCB8fCB0aGlzLmRhdGU7XHJcblxyXG4gICAgICAgICAgICB2YXIgbmV4dFZpZXcgPSBkaXIgPT0gJ3VwJyA/IHRoaXMudmlld0luZGV4ICsgMSA6IHRoaXMudmlld0luZGV4IC0gMTtcclxuICAgICAgICAgICAgaWYgKG5leHRWaWV3ID4gMikgbmV4dFZpZXcgPSAyO1xyXG4gICAgICAgICAgICBpZiAobmV4dFZpZXcgPCAwKSBuZXh0VmlldyA9IDA7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNpbGVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zaWxlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy52aWV3ID0gdGhpcy52aWV3SW5kZXhlc1tuZXh0Vmlld107XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9oYW5kbGVIb3RLZXk6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGUgPSBkYXRlcGlja2VyLmdldFBhcnNlZERhdGUodGhpcy5fZ2V0Rm9jdXNlZERhdGUoKSksXHJcbiAgICAgICAgICAgICAgICBmb2N1c2VkUGFyc2VkLFxyXG4gICAgICAgICAgICAgICAgbyA9IHRoaXMub3B0cyxcclxuICAgICAgICAgICAgICAgIG5ld0RhdGUsXHJcbiAgICAgICAgICAgICAgICB0b3RhbERheXNJbk5leHRNb250aCxcclxuICAgICAgICAgICAgICAgIG1vbnRoQ2hhbmdlZCA9IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgeWVhckNoYW5nZWQgPSBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGRlY2FkZUNoYW5nZWQgPSBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHkgPSBkYXRlLnllYXIsXHJcbiAgICAgICAgICAgICAgICBtID0gZGF0ZS5tb250aCxcclxuICAgICAgICAgICAgICAgIGQgPSBkYXRlLmRhdGU7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY3RybFJpZ2h0JzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2N0cmxVcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgbSArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjdHJsTGVmdCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjdHJsRG93bic6XHJcbiAgICAgICAgICAgICAgICAgICAgbSAtPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzaGlmdFJpZ2h0JzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3NoaWZ0VXAnOlxyXG4gICAgICAgICAgICAgICAgICAgIHllYXJDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB5ICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzaGlmdExlZnQnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnc2hpZnREb3duJzpcclxuICAgICAgICAgICAgICAgICAgICB5ZWFyQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgeSAtPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnYWx0UmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnYWx0VXAnOlxyXG4gICAgICAgICAgICAgICAgICAgIGRlY2FkZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgKz0gMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdhbHRMZWZ0JzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2FsdERvd24nOlxyXG4gICAgICAgICAgICAgICAgICAgIGRlY2FkZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgLT0gMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjdHJsU2hpZnRVcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0b3RhbERheXNJbk5leHRNb250aCA9IGRhdGVwaWNrZXIuZ2V0RGF5c0NvdW50KG5ldyBEYXRlKHksbSkpO1xyXG4gICAgICAgICAgICBuZXdEYXRlID0gbmV3IERhdGUoeSxtLGQpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgbmV4dCBtb250aCBoYXMgbGVzcyBkYXlzIHRoYW4gY3VycmVudCwgc2V0IGRhdGUgdG8gdG90YWwgZGF5cyBpbiB0aGF0IG1vbnRoXHJcbiAgICAgICAgICAgIGlmICh0b3RhbERheXNJbk5leHRNb250aCA8IGQpIGQgPSB0b3RhbERheXNJbk5leHRNb250aDtcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIG5ld0RhdGUgaXMgaW4gdmFsaWQgcmFuZ2VcclxuICAgICAgICAgICAgaWYgKG5ld0RhdGUuZ2V0VGltZSgpIDwgdGhpcy5taW5UaW1lKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdEYXRlID0gdGhpcy5taW5EYXRlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5ld0RhdGUuZ2V0VGltZSgpID4gdGhpcy5tYXhUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdEYXRlID0gdGhpcy5tYXhEYXRlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZvY3VzZWQgPSBuZXdEYXRlO1xyXG5cclxuICAgICAgICAgICAgZm9jdXNlZFBhcnNlZCA9IGRhdGVwaWNrZXIuZ2V0UGFyc2VkRGF0ZShuZXdEYXRlKTtcclxuICAgICAgICAgICAgaWYgKG1vbnRoQ2hhbmdlZCAmJiBvLm9uQ2hhbmdlTW9udGgpIHtcclxuICAgICAgICAgICAgICAgIG8ub25DaGFuZ2VNb250aChmb2N1c2VkUGFyc2VkLm1vbnRoLCBmb2N1c2VkUGFyc2VkLnllYXIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHllYXJDaGFuZ2VkICYmIG8ub25DaGFuZ2VZZWFyKSB7XHJcbiAgICAgICAgICAgICAgICBvLm9uQ2hhbmdlWWVhcihmb2N1c2VkUGFyc2VkLnllYXIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRlY2FkZUNoYW5nZWQgJiYgby5vbkNoYW5nZURlY2FkZSkge1xyXG4gICAgICAgICAgICAgICAgby5vbkNoYW5nZURlY2FkZSh0aGlzLmN1ckRlY2FkZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9yZWdpc3RlcktleTogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgZXhpc3RzID0gdGhpcy5rZXlzLnNvbWUoZnVuY3Rpb24gKGN1cktleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cktleSA9PSBrZXk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFleGlzdHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF91blJlZ2lzdGVyS2V5OiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMua2V5cy5pbmRleE9mKGtleSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmtleXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfaXNIb3RLZXlQcmVzc2VkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50SG90S2V5LFxyXG4gICAgICAgICAgICAgICAgZm91bmQgPSBmYWxzZSxcclxuICAgICAgICAgICAgICAgIF90aGlzID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzID0gdGhpcy5rZXlzLnNvcnQoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGhvdEtleSBpbiBob3RLZXlzKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50SG90S2V5ID0gaG90S2V5c1tob3RLZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXNzZWRLZXlzLmxlbmd0aCAhPSBjdXJyZW50SG90S2V5Lmxlbmd0aCkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRIb3RLZXkuZXZlcnkoZnVuY3Rpb24gKGtleSwgaSkgeyByZXR1cm4ga2V5ID09IHByZXNzZWRLZXlzW2ldfSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdHJpZ2dlcignaG90S2V5JywgaG90S2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfdHJpZ2dlcjogZnVuY3Rpb24gKGV2ZW50LCBhcmdzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGVsLnRyaWdnZXIoZXZlbnQsIGFyZ3MpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2ZvY3VzTmV4dENlbGw6IGZ1bmN0aW9uIChrZXlDb2RlLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IHRoaXMuY2VsbFR5cGU7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGF0ZSA9IGRhdGVwaWNrZXIuZ2V0UGFyc2VkRGF0ZSh0aGlzLl9nZXRGb2N1c2VkRGF0ZSgpKSxcclxuICAgICAgICAgICAgICAgIHkgPSBkYXRlLnllYXIsXHJcbiAgICAgICAgICAgICAgICBtID0gZGF0ZS5tb250aCxcclxuICAgICAgICAgICAgICAgIGQgPSBkYXRlLmRhdGU7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNIb3RLZXlQcmVzc2VkKCkpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2goa2V5Q29kZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzNzogLy8gbGVmdFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPT0gJ2RheScgPyAoZCAtPSAxKSA6ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPT0gJ21vbnRoJyA/IChtIC09IDEpIDogJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9PSAneWVhcicgPyAoeSAtPSAxKSA6ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzODogLy8gdXBcclxuICAgICAgICAgICAgICAgICAgICB0eXBlID09ICdkYXknID8gKGQgLT0gNykgOiAnJztcclxuICAgICAgICAgICAgICAgICAgICB0eXBlID09ICdtb250aCcgPyAobSAtPSAzKSA6ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPT0gJ3llYXInID8gKHkgLT0gNCkgOiAnJztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMzk6IC8vIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9PSAnZGF5JyA/IChkICs9IDEpIDogJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9PSAnbW9udGgnID8gKG0gKz0gMSkgOiAnJztcclxuICAgICAgICAgICAgICAgICAgICB0eXBlID09ICd5ZWFyJyA/ICh5ICs9IDEpIDogJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQwOiAvLyBkb3duXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9PSAnZGF5JyA/IChkICs9IDcpIDogJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9PSAnbW9udGgnID8gKG0gKz0gMykgOiAnJztcclxuICAgICAgICAgICAgICAgICAgICB0eXBlID09ICd5ZWFyJyA/ICh5ICs9IDQpIDogJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBuZCA9IG5ldyBEYXRlKHksbSxkKTtcclxuICAgICAgICAgICAgaWYgKG5kLmdldFRpbWUoKSA8IHRoaXMubWluVGltZSkge1xyXG4gICAgICAgICAgICAgICAgbmQgPSB0aGlzLm1pbkRhdGU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmQuZ2V0VGltZSgpID4gdGhpcy5tYXhUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICBuZCA9IHRoaXMubWF4RGF0ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gbmQ7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRGb2N1c2VkRGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZm9jdXNlZCAgPSB0aGlzLmZvY3VzZWQgfHwgdGhpcy5zZWxlY3RlZERhdGVzW3RoaXMuc2VsZWN0ZWREYXRlcy5sZW5ndGggLSAxXSxcclxuICAgICAgICAgICAgICAgIGQgPSB0aGlzLnBhcnNlZERhdGU7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWZvY3VzZWQpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy52aWV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGF5cyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzZWQgPSBuZXcgRGF0ZShkLnllYXIsIGQubW9udGgsIG5ldyBEYXRlKCkuZ2V0RGF0ZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbW9udGhzJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNlZCA9IG5ldyBEYXRlKGQueWVhciwgZC5tb250aCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3llYXJzJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNlZCA9IG5ldyBEYXRlKGQueWVhciwgMCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZm9jdXNlZDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0Q2VsbDogZnVuY3Rpb24gKGRhdGUsIHR5cGUpIHtcclxuICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgdGhpcy5jZWxsVHlwZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkID0gZGF0ZXBpY2tlci5nZXRQYXJzZWREYXRlKGRhdGUpLFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSAnLmRhdGVwaWNrZXItLWNlbGxbZGF0YS15ZWFyPVwiJyArIGQueWVhciArICdcIl0nLFxyXG4gICAgICAgICAgICAgICAgJGNlbGw7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICdbZGF0YS1tb250aD1cIicgKyBkLm1vbnRoICsgJ1wiXSc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknOlxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yICs9ICdbZGF0YS1tb250aD1cIicgKyBkLm1vbnRoICsgJ1wiXVtkYXRhLWRhdGU9XCInICsgZC5kYXRlICsgJ1wiXSc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJGNlbGwgPSB0aGlzLnZpZXdzW3RoaXMuY3VycmVudFZpZXddLiRlbC5maW5kKHNlbGVjdG9yKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAkY2VsbC5sZW5ndGggPyAkY2VsbCA6ICQoJycpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuJGVsXHJcbiAgICAgICAgICAgICAgICAub2ZmKCcuYWRwJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKCdkYXRlcGlja2VyJywgJycpO1xyXG5cclxuICAgICAgICAgICAgX3RoaXMuc2VsZWN0ZWREYXRlcyA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5mb2N1c2VkID0gJyc7XHJcbiAgICAgICAgICAgIF90aGlzLnZpZXdzID0ge307XHJcbiAgICAgICAgICAgIF90aGlzLmtleXMgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMubWluUmFuZ2UgPSAnJztcclxuICAgICAgICAgICAgX3RoaXMubWF4UmFuZ2UgPSAnJztcclxuXHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRzLmlubGluZSB8fCAhX3RoaXMuZWxJc0lucHV0KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy4kZGF0ZXBpY2tlci5jbG9zZXN0KCcuZGF0ZXBpY2tlci1pbmxpbmUnKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLiRkYXRlcGlja2VyLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2hhbmRsZUFscmVhZHlTZWxlY3RlZERhdGVzOiBmdW5jdGlvbiAoYWxyZWFkeVNlbGVjdGVkLCBzZWxlY3RlZERhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5yYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdHMudG9nZ2xlU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgcG9zc2liaWxpdHkgdG8gc2VsZWN0IHNhbWUgZGF0ZSB3aGVuIHJhbmdlIGlzIHRydWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZERhdGVzLmxlbmd0aCAhPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoJ2NsaWNrQ2VsbCcsIHNlbGVjdGVkRGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURhdGUoc2VsZWN0ZWREYXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdHMudG9nZ2xlU2VsZWN0ZWQpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEYXRlKHNlbGVjdGVkRGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENoYW5nZSBsYXN0IHNlbGVjdGVkIGRhdGUgdG8gYmUgYWJsZSB0byBjaGFuZ2UgdGltZSB3aGVuIGNsaWNraW5nIG9uIHRoaXMgY2VsbFxyXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0cy50b2dnbGVTZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0U2VsZWN0ZWREYXRlID0gYWxyZWFkeVNlbGVjdGVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy50aW1lcGlja2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lcGlja2VyLl9zZXRUaW1lKGFscmVhZHlTZWxlY3RlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lcGlja2VyLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX29uU2hvd0V2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfb25CbHVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pbkZvY3VzICYmIHRoaXMudmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfb25Nb3VzZURvd25EYXRlcGlja2VyOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmluRm9jdXMgPSB0cnVlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9vbk1vdXNlVXBEYXRlcGlja2VyOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmluRm9jdXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50LmluRm9jdXMgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoIWUub3JpZ2luYWxFdmVudC50aW1lcGlja2VyRm9jdXMpIHRoaXMuJGVsLmZvY3VzKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX29uS2V5VXBHZW5lcmFsOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpcy4kZWwudmFsKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXZhbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9vbk1vdXNlVXBCb2R5OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAoZS5vcmlnaW5hbEV2ZW50LmluRm9jdXMpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc2libGUgJiYgIXRoaXMuaW5Gb2N1cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfb25Nb3VzZVVwRWw6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGUub3JpZ2luYWxFdmVudC5pbkZvY3VzID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLl9vbktleVVwR2VuZXJhbC5iaW5kKHRoaXMpLDQpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2RlID0gZS53aGljaDtcclxuICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJLZXkoY29kZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBcnJvd3NcclxuICAgICAgICAgICAgaWYgKGNvZGUgPj0gMzcgJiYgY29kZSA8PSA0MCkge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNOZXh0Q2VsbChjb2RlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRW50ZXJcclxuICAgICAgICAgICAgaWYgKGNvZGUgPT0gMTMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvY3VzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZ2V0Q2VsbCh0aGlzLmZvY3VzZWQpLmhhc0NsYXNzKCctZGlzYWJsZWQtJykpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3ICE9IHRoaXMub3B0cy5taW5WaWV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG93bigpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFscmVhZHlTZWxlY3RlZCA9IHRoaXMuX2lzU2VsZWN0ZWQodGhpcy5mb2N1c2VkLCB0aGlzLmNlbGxUeXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWxyZWFkeVNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50aW1lcGlja2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1c2VkLnNldEhvdXJzKHRoaXMudGltZXBpY2tlci5ob3Vycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1c2VkLnNldE1pbnV0ZXModGhpcy50aW1lcGlja2VyLm1pbnV0ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3REYXRlKHRoaXMuZm9jdXNlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlQWxyZWFkeVNlbGVjdGVkRGF0ZXMoYWxyZWFkeVNlbGVjdGVkLCB0aGlzLmZvY3VzZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBFc2NcclxuICAgICAgICAgICAgaWYgKGNvZGUgPT0gMjcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX29uS2V5VXA6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2RlID0gZS53aGljaDtcclxuICAgICAgICAgICAgdGhpcy5fdW5SZWdpc3RlcktleShjb2RlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfb25Ib3RLZXk6IGZ1bmN0aW9uIChlLCBob3RLZXkpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlSG90S2V5KGhvdEtleSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX29uTW91c2VFbnRlckNlbGw6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZhciAkY2VsbCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5kYXRlcGlja2VyLS1jZWxsJyksXHJcbiAgICAgICAgICAgICAgICBkYXRlID0gdGhpcy5fZ2V0RGF0ZUZyb21DZWxsKCRjZWxsKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFByZXZlbnQgZnJvbSB1bm5lY2Vzc2FyeSByZW5kZXJpbmcgYW5kIHNldHRpbmcgbmV3IGN1cnJlbnREYXRlXHJcbiAgICAgICAgICAgIHRoaXMuc2lsZW50ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvY3VzZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNlZCA9ICcnXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICRjZWxsLmFkZENsYXNzKCctZm9jdXMtJyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZvY3VzZWQgPSBkYXRlO1xyXG4gICAgICAgICAgICB0aGlzLnNpbGVudCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5yYW5nZSAmJiB0aGlzLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWluUmFuZ2UgPSB0aGlzLnNlbGVjdGVkRGF0ZXNbMF07XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heFJhbmdlID0gJyc7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZXBpY2tlci5sZXNzKHRoaXMubWluUmFuZ2UsIHRoaXMuZm9jdXNlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heFJhbmdlID0gdGhpcy5taW5SYW5nZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pblJhbmdlID0gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdzW3RoaXMuY3VycmVudFZpZXddLl91cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9vbk1vdXNlTGVhdmVDZWxsOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIgJGNlbGwgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KCcuZGF0ZXBpY2tlci0tY2VsbCcpO1xyXG5cclxuICAgICAgICAgICAgJGNlbGwucmVtb3ZlQ2xhc3MoJy1mb2N1cy0nKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2lsZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gJyc7XHJcbiAgICAgICAgICAgIHRoaXMuc2lsZW50ID0gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX29uVGltZUNoYW5nZTogZnVuY3Rpb24gKGUsIGgsIG0pIHtcclxuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWREYXRlcyA9IHRoaXMuc2VsZWN0ZWREYXRlcyxcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWREYXRlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGRhdGUgPSB0aGlzLmxhc3RTZWxlY3RlZERhdGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRhdGUuc2V0SG91cnMoaCk7XHJcbiAgICAgICAgICAgIGRhdGUuc2V0TWludXRlcyhtKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWQgJiYgIXRoaXMuX2dldENlbGwoZGF0ZSkuaGFzQ2xhc3MoJy1kaXNhYmxlZC0nKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3REYXRlKGRhdGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0SW5wdXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5vblNlbGVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJPbkNoYW5nZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX29uQ2xpY2tDZWxsOiBmdW5jdGlvbiAoZSwgZGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lcGlja2VyKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlLnNldEhvdXJzKHRoaXMudGltZXBpY2tlci5ob3Vycyk7XHJcbiAgICAgICAgICAgICAgICBkYXRlLnNldE1pbnV0ZXModGhpcy50aW1lcGlja2VyLm1pbnV0ZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0RGF0ZShkYXRlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQgZm9jdXNlZCh2YWwpIHtcclxuICAgICAgICAgICAgaWYgKCF2YWwgJiYgdGhpcy5mb2N1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgJGNlbGwgPSB0aGlzLl9nZXRDZWxsKHRoaXMuZm9jdXNlZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCRjZWxsLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICRjZWxsLnJlbW92ZUNsYXNzKCctZm9jdXMtJylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9mb2N1c2VkID0gdmFsO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnJhbmdlICYmIHRoaXMuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taW5SYW5nZSA9IHRoaXMuc2VsZWN0ZWREYXRlc1swXTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF4UmFuZ2UgPSAnJztcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlcGlja2VyLmxlc3ModGhpcy5taW5SYW5nZSwgdGhpcy5fZm9jdXNlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heFJhbmdlID0gdGhpcy5taW5SYW5nZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pblJhbmdlID0gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuc2lsZW50KSByZXR1cm47XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZSA9IHZhbDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXQgZm9jdXNlZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvY3VzZWQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0IHBhcnNlZERhdGUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlcGlja2VyLmdldFBhcnNlZERhdGUodGhpcy5kYXRlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQgZGF0ZSAodmFsKSB7XHJcbiAgICAgICAgICAgIGlmICghKHZhbCBpbnN0YW5jZW9mIERhdGUpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdmFsO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5pdGVkICYmICF0aGlzLnNpbGVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3c1t0aGlzLnZpZXddLl9yZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubmF2Ll9yZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpc2libGUgJiYgdGhpcy5lbElzSW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXQgZGF0ZSAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnREYXRlXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0IHZpZXcgKHZhbCkge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdJbmRleCA9IHRoaXMudmlld0luZGV4ZXMuaW5kZXhPZih2YWwpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMudmlld0luZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnByZXZWaWV3ID0gdGhpcy5jdXJyZW50VmlldztcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmlldyA9IHZhbDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmluaXRlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZpZXdzW3ZhbF0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdzW3ZhbF0gPSBuZXcgICQuZm4uZGF0ZXBpY2tlci5Cb2R5KHRoaXMsIHZhbCwgdGhpcy5vcHRzKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdzW3ZhbF0uX3JlbmRlcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudmlld3NbdGhpcy5wcmV2Vmlld10uaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3c1t2YWxdLnNob3coKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubmF2Ll9yZW5kZXIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRzLm9uQ2hhbmdlVmlldykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0cy5vbkNoYW5nZVZpZXcodmFsKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZWxJc0lucHV0ICYmIHRoaXMudmlzaWJsZSkgdGhpcy5zZXRQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdmFsXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0IHZpZXcoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRWaWV3O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldCBjZWxsVHlwZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlldy5zdWJzdHJpbmcoMCwgdGhpcy52aWV3Lmxlbmd0aCAtIDEpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0IG1pblRpbWUoKSB7XHJcbiAgICAgICAgICAgIHZhciBtaW4gPSBkYXRlcGlja2VyLmdldFBhcnNlZERhdGUodGhpcy5taW5EYXRlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1pbi55ZWFyLCBtaW4ubW9udGgsIG1pbi5kYXRlKS5nZXRUaW1lKClcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXQgbWF4VGltZSgpIHtcclxuICAgICAgICAgICAgdmFyIG1heCA9IGRhdGVwaWNrZXIuZ2V0UGFyc2VkRGF0ZSh0aGlzLm1heERhdGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobWF4LnllYXIsIG1heC5tb250aCwgbWF4LmRhdGUpLmdldFRpbWUoKVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldCBjdXJEZWNhZGUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlcGlja2VyLmdldERlY2FkZSh0aGlzLmRhdGUpXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyAgVXRpbHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBkYXRlcGlja2VyLmdldERheXNDb3VudCA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpICsgMSwgMCkuZ2V0RGF0ZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBkYXRlcGlja2VyLmdldFBhcnNlZERhdGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHllYXI6IGRhdGUuZ2V0RnVsbFllYXIoKSxcclxuICAgICAgICAgICAgbW9udGg6IGRhdGUuZ2V0TW9udGgoKSxcclxuICAgICAgICAgICAgZnVsbE1vbnRoOiAoZGF0ZS5nZXRNb250aCgpICsgMSkgPCAxMCA/ICcwJyArIChkYXRlLmdldE1vbnRoKCkgKyAxKSA6IGRhdGUuZ2V0TW9udGgoKSArIDEsIC8vIE9uZSBiYXNlZFxyXG4gICAgICAgICAgICBkYXRlOiBkYXRlLmdldERhdGUoKSxcclxuICAgICAgICAgICAgZnVsbERhdGU6IGRhdGUuZ2V0RGF0ZSgpIDwgMTAgPyAnMCcgKyBkYXRlLmdldERhdGUoKSA6IGRhdGUuZ2V0RGF0ZSgpLFxyXG4gICAgICAgICAgICBkYXk6IGRhdGUuZ2V0RGF5KCksXHJcbiAgICAgICAgICAgIGhvdXJzOiBkYXRlLmdldEhvdXJzKCksXHJcbiAgICAgICAgICAgIGZ1bGxIb3VyczogIGRhdGUuZ2V0SG91cnMoKSA8IDEwID8gJzAnICsgZGF0ZS5nZXRIb3VycygpIDogIGRhdGUuZ2V0SG91cnMoKSAsXHJcbiAgICAgICAgICAgIG1pbnV0ZXM6IGRhdGUuZ2V0TWludXRlcygpLFxyXG4gICAgICAgICAgICBmdWxsTWludXRlczogIGRhdGUuZ2V0TWludXRlcygpIDwgMTAgPyAnMCcgKyBkYXRlLmdldE1pbnV0ZXMoKSA6ICBkYXRlLmdldE1pbnV0ZXMoKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZGF0ZXBpY2tlci5nZXREZWNhZGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHZhciBmaXJzdFllYXIgPSBNYXRoLmZsb29yKGRhdGUuZ2V0RnVsbFllYXIoKSAvIDEwKSAqIDEwO1xyXG5cclxuICAgICAgICByZXR1cm4gW2ZpcnN0WWVhciwgZmlyc3RZZWFyICsgOV07XHJcbiAgICB9O1xyXG5cclxuICAgIGRhdGVwaWNrZXIudGVtcGxhdGUgPSBmdW5jdGlvbiAoc3RyLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8jXFx7KFtcXHddKylcXH0vZywgZnVuY3Rpb24gKHNvdXJjZSwgbWF0Y2gpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGFbbWF0Y2hdIHx8IGRhdGFbbWF0Y2hdID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVttYXRjaF1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBkYXRlcGlja2VyLmlzU2FtZSA9IGZ1bmN0aW9uIChkYXRlMSwgZGF0ZTIsIHR5cGUpIHtcclxuICAgICAgICBpZiAoIWRhdGUxIHx8ICFkYXRlMikgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHZhciBkMSA9IGRhdGVwaWNrZXIuZ2V0UGFyc2VkRGF0ZShkYXRlMSksXHJcbiAgICAgICAgICAgIGQyID0gZGF0ZXBpY2tlci5nZXRQYXJzZWREYXRlKGRhdGUyKSxcclxuICAgICAgICAgICAgX3R5cGUgPSB0eXBlID8gdHlwZSA6ICdkYXknLFxyXG5cclxuICAgICAgICAgICAgY29uZGl0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIGRheTogZDEuZGF0ZSA9PSBkMi5kYXRlICYmIGQxLm1vbnRoID09IGQyLm1vbnRoICYmIGQxLnllYXIgPT0gZDIueWVhcixcclxuICAgICAgICAgICAgICAgIG1vbnRoOiBkMS5tb250aCA9PSBkMi5tb250aCAmJiBkMS55ZWFyID09IGQyLnllYXIsXHJcbiAgICAgICAgICAgICAgICB5ZWFyOiBkMS55ZWFyID09IGQyLnllYXJcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbnNbX3R5cGVdO1xyXG4gICAgfTtcclxuXHJcbiAgICBkYXRlcGlja2VyLmxlc3MgPSBmdW5jdGlvbiAoZGF0ZUNvbXBhcmVUbywgZGF0ZSwgdHlwZSkge1xyXG4gICAgICAgIGlmICghZGF0ZUNvbXBhcmVUbyB8fCAhZGF0ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBkYXRlLmdldFRpbWUoKSA8IGRhdGVDb21wYXJlVG8uZ2V0VGltZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBkYXRlcGlja2VyLmJpZ2dlciA9IGZ1bmN0aW9uIChkYXRlQ29tcGFyZVRvLCBkYXRlLCB0eXBlKSB7XHJcbiAgICAgICAgaWYgKCFkYXRlQ29tcGFyZVRvIHx8ICFkYXRlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpID4gZGF0ZUNvbXBhcmVUby5nZXRUaW1lKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGRhdGVwaWNrZXIuZ2V0TGVhZGluZ1plcm9OdW0gPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bSkgPCAxMCA/ICcwJyArIG51bSA6IG51bTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGNvcHkgb2YgZGF0ZSB3aXRoIGhvdXJzIGFuZCBtaW51dGVzIGVxdWFscyB0byAwXHJcbiAgICAgKiBAcGFyYW0gZGF0ZSB7RGF0ZX1cclxuICAgICAqL1xyXG4gICAgZGF0ZXBpY2tlci5yZXNldFRpbWUgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZGF0ZSAhPSAnb2JqZWN0JykgcmV0dXJuO1xyXG4gICAgICAgIGRhdGUgPSBkYXRlcGlja2VyLmdldFBhcnNlZERhdGUoZGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUueWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXRlKVxyXG4gICAgfTtcclxuXHJcbiAgICAkLmZuLmRhdGVwaWNrZXIgPSBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghJC5kYXRhKHRoaXMsIHBsdWdpbk5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAkLmRhdGEodGhpcywgIHBsdWdpbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGVwaWNrZXIoIHRoaXMsIG9wdGlvbnMgKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSAkLmRhdGEodGhpcywgcGx1Z2luTmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgX3RoaXMub3B0cyA9ICQuZXh0ZW5kKHRydWUsIF90aGlzLm9wdHMsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgJC5mbi5kYXRlcGlja2VyLkNvbnN0cnVjdG9yID0gRGF0ZXBpY2tlcjtcclxuXHJcbiAgICAkLmZuLmRhdGVwaWNrZXIubGFuZ3VhZ2UgPSB7XHJcbiAgICAgICAgcnU6IHtcclxuICAgICAgICAgICAgZGF5czogWyfQktC+0YHQutGA0LXRgdC10L3RjNC1JywgJ9Cf0L7QvdC10LTQtdC70YzQvdC40LonLCAn0JLRgtC+0YDQvdC40LonLCAn0KHRgNC10LTQsCcsICfQp9C10YLQstC10YDQsycsICfQn9GP0YLQvdC40YbQsCcsICfQodGD0LHQsdC+0YLQsCddLFxyXG4gICAgICAgICAgICBkYXlzU2hvcnQ6IFsn0JLQvtGBJywn0J/QvtC9Jywn0JLRgtC+Jywn0KHRgNC1Jywn0KfQtdGCJywn0J/Rj9GCJywn0KHRg9CxJ10sXHJcbiAgICAgICAgICAgIGRheXNNaW46IFsn0JLRgScsJ9Cf0L0nLCfQktGCJywn0KHRgCcsJ9Cn0YInLCfQn9GCJywn0KHQsSddLFxyXG4gICAgICAgICAgICBtb250aHM6IFsn0K/QvdCy0LDRgNGMJywgJ9Ck0LXQstGA0LDQu9GMJywgJ9Cc0LDRgNGCJywgJ9CQ0L/RgNC10LvRjCcsICfQnNCw0LknLCAn0JjRjtC90YwnLCAn0JjRjtC70YwnLCAn0JDQstCz0YPRgdGCJywgJ9Ch0LXQvdGC0Y/QsdGA0YwnLCAn0J7QutGC0Y/QsdGA0YwnLCAn0J3QvtGP0LHRgNGMJywgJ9CU0LXQutCw0LHRgNGMJ10sXHJcbiAgICAgICAgICAgIG1vbnRoc1Nob3J0OiBbJ9Cv0L3QsicsICfQpNC10LInLCAn0JzQsNGAJywgJ9CQ0L/RgCcsICfQnNCw0LknLCAn0JjRjtC9JywgJ9CY0Y7QuycsICfQkNCy0LMnLCAn0KHQtdC9JywgJ9Ce0LrRgicsICfQndC+0Y8nLCAn0JTQtdC6J10sXHJcbiAgICAgICAgICAgIHRvZGF5OiAn0KHQtdCz0L7QtNC90Y8nLFxyXG4gICAgICAgICAgICBjbGVhcjogJ9Ce0YfQuNGB0YLQuNGC0YwnLFxyXG4gICAgICAgICAgICBkYXRlRm9ybWF0OiAnZGQubW0ueXl5eScsXHJcbiAgICAgICAgICAgIHRpbWVGb3JtYXQ6ICdoaDppaScsXHJcbiAgICAgICAgICAgIGZpcnN0RGF5OiAxXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAkKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAkKGF1dG9Jbml0U2VsZWN0b3IpLmRhdGVwaWNrZXIoKTtcclxuICAgIH0pXHJcblxyXG59KSgpO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/air-datepicker/src/js/datepicker.js\n");

/***/ }),

/***/ "./node_modules/air-datepicker/src/js/navigation.js":
/*!**********************************************************!*\
  !*** ./node_modules/air-datepicker/src/js/navigation.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval(";(function () {\r\n    var template = '' +\r\n        '<div class=\"datepicker--nav-action\" data-action=\"prev\">#{prevHtml}</div>' +\r\n        '<div class=\"datepicker--nav-title\">#{title}</div>' +\r\n        '<div class=\"datepicker--nav-action\" data-action=\"next\">#{nextHtml}</div>',\r\n        buttonsContainerTemplate = '<div class=\"datepicker--buttons\"></div>',\r\n        button = '<span class=\"datepicker--button\" data-action=\"#{action}\">#{label}</span>',\r\n        datepicker = $.fn.datepicker,\r\n        dp = datepicker.Constructor;\r\n\r\n    datepicker.Navigation = function (d, opts) {\r\n        this.d = d;\r\n        this.opts = opts;\r\n\r\n        this.$buttonsContainer = '';\r\n\r\n        this.init();\r\n    };\r\n\r\n    datepicker.Navigation.prototype = {\r\n        init: function () {\r\n            this._buildBaseHtml();\r\n            this._bindEvents();\r\n        },\r\n\r\n        _bindEvents: function () {\r\n            this.d.$nav.on('click', '.datepicker--nav-action', $.proxy(this._onClickNavButton, this));\r\n            this.d.$nav.on('click', '.datepicker--nav-title', $.proxy(this._onClickNavTitle, this));\r\n            this.d.$datepicker.on('click', '.datepicker--button', $.proxy(this._onClickNavButton, this));\r\n        },\r\n\r\n        _buildBaseHtml: function () {\r\n            if (!this.opts.onlyTimepicker) {\r\n                this._render();\r\n            }\r\n            this._addButtonsIfNeed();\r\n        },\r\n\r\n        _addButtonsIfNeed: function () {\r\n            if (this.opts.todayButton) {\r\n                this._addButton('today')\r\n            }\r\n            if (this.opts.clearButton) {\r\n                this._addButton('clear')\r\n            }\r\n        },\r\n\r\n        _render: function () {\r\n            var title = this._getTitle(this.d.currentDate),\r\n                html = dp.template(template, $.extend({title: title}, this.opts));\r\n            this.d.$nav.html(html);\r\n            if (this.d.view == 'years') {\r\n                $('.datepicker--nav-title', this.d.$nav).addClass('-disabled-');\r\n            }\r\n            this.setNavStatus();\r\n        },\r\n\r\n        _getTitle: function (date) {\r\n            return this.d.formatDate(this.opts.navTitles[this.d.view], date)\r\n        },\r\n\r\n        _addButton: function (type) {\r\n            if (!this.$buttonsContainer.length) {\r\n                this._addButtonsContainer();\r\n            }\r\n\r\n            var data = {\r\n                    action: type,\r\n                    label: this.d.loc[type]\r\n                },\r\n                html = dp.template(button, data);\r\n\r\n            if ($('[data-action=' + type + ']', this.$buttonsContainer).length) return;\r\n            this.$buttonsContainer.append(html);\r\n        },\r\n\r\n        _addButtonsContainer: function () {\r\n            this.d.$datepicker.append(buttonsContainerTemplate);\r\n            this.$buttonsContainer = $('.datepicker--buttons', this.d.$datepicker);\r\n        },\r\n\r\n        setNavStatus: function () {\r\n            if (!(this.opts.minDate || this.opts.maxDate) || !this.opts.disableNavWhenOutOfRange) return;\r\n\r\n            var date = this.d.parsedDate,\r\n                m = date.month,\r\n                y = date.year,\r\n                d = date.date;\r\n\r\n            switch (this.d.view) {\r\n                case 'days':\r\n                    if (!this.d._isInRange(new Date(y, m-1, 1), 'month')) {\r\n                        this._disableNav('prev')\r\n                    }\r\n                    if (!this.d._isInRange(new Date(y, m+1, 1), 'month')) {\r\n                        this._disableNav('next')\r\n                    }\r\n                    break;\r\n                case 'months':\r\n                    if (!this.d._isInRange(new Date(y-1, m, d), 'year')) {\r\n                        this._disableNav('prev')\r\n                    }\r\n                    if (!this.d._isInRange(new Date(y+1, m, d), 'year')) {\r\n                        this._disableNav('next')\r\n                    }\r\n                    break;\r\n                case 'years':\r\n                    var decade = dp.getDecade(this.d.date);\r\n                    if (!this.d._isInRange(new Date(decade[0] - 1, 0, 1), 'year')) {\r\n                        this._disableNav('prev')\r\n                    }\r\n                    if (!this.d._isInRange(new Date(decade[1] + 1, 0, 1), 'year')) {\r\n                        this._disableNav('next')\r\n                    }\r\n                    break;\r\n            }\r\n        },\r\n\r\n        _disableNav: function (nav) {\r\n            $('[data-action=\"' + nav + '\"]', this.d.$nav).addClass('-disabled-')\r\n        },\r\n\r\n        _activateNav: function (nav) {\r\n            $('[data-action=\"' + nav + '\"]', this.d.$nav).removeClass('-disabled-')\r\n        },\r\n\r\n        _onClickNavButton: function (e) {\r\n            var $el = $(e.target).closest('[data-action]'),\r\n                action = $el.data('action');\r\n\r\n            this.d[action]();\r\n        },\r\n\r\n        _onClickNavTitle: function (e) {\r\n            if ($(e.target).hasClass('-disabled-')) return;\r\n\r\n            if (this.d.view == 'days') {\r\n                return this.d.view = 'months'\r\n            }\r\n\r\n            this.d.view = 'years';\r\n        }\r\n    }\r\n\r\n})();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWlyLWRhdGVwaWNrZXIvc3JjL2pzL25hdmlnYXRpb24uanM/ZTk3OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxDQUFDO0FBQ0Q7QUFDQSxrRUFBa0UsU0FBUztBQUMzRSw4Q0FBOEMsTUFBTTtBQUNwRCxrRUFBa0UsU0FBUztBQUMzRTtBQUNBLGtFQUFrRSxPQUFPLElBQUksTUFBTTtBQUNuRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSx1REFBdUQsYUFBYTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9haXItZGF0ZXBpY2tlci9zcmMvanMvbmF2aWdhdGlvbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIjsoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHRlbXBsYXRlID0gJycgK1xyXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci0tbmF2LWFjdGlvblwiIGRhdGEtYWN0aW9uPVwicHJldlwiPiN7cHJldkh0bWx9PC9kaXY+JyArXHJcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLS1uYXYtdGl0bGVcIj4je3RpdGxlfTwvZGl2PicgK1xyXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci0tbmF2LWFjdGlvblwiIGRhdGEtYWN0aW9uPVwibmV4dFwiPiN7bmV4dEh0bWx9PC9kaXY+JyxcclxuICAgICAgICBidXR0b25zQ29udGFpbmVyVGVtcGxhdGUgPSAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItLWJ1dHRvbnNcIj48L2Rpdj4nLFxyXG4gICAgICAgIGJ1dHRvbiA9ICc8c3BhbiBjbGFzcz1cImRhdGVwaWNrZXItLWJ1dHRvblwiIGRhdGEtYWN0aW9uPVwiI3thY3Rpb259XCI+I3tsYWJlbH08L3NwYW4+JyxcclxuICAgICAgICBkYXRlcGlja2VyID0gJC5mbi5kYXRlcGlja2VyLFxyXG4gICAgICAgIGRwID0gZGF0ZXBpY2tlci5Db25zdHJ1Y3RvcjtcclxuXHJcbiAgICBkYXRlcGlja2VyLk5hdmlnYXRpb24gPSBmdW5jdGlvbiAoZCwgb3B0cykge1xyXG4gICAgICAgIHRoaXMuZCA9IGQ7XHJcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcclxuXHJcbiAgICAgICAgdGhpcy4kYnV0dG9uc0NvbnRhaW5lciA9ICcnO1xyXG5cclxuICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgIH07XHJcblxyXG4gICAgZGF0ZXBpY2tlci5OYXZpZ2F0aW9uLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1aWxkQmFzZUh0bWwoKTtcclxuICAgICAgICAgICAgdGhpcy5fYmluZEV2ZW50cygpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9iaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZC4kbmF2Lm9uKCdjbGljaycsICcuZGF0ZXBpY2tlci0tbmF2LWFjdGlvbicsICQucHJveHkodGhpcy5fb25DbGlja05hdkJ1dHRvbiwgdGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLmQuJG5hdi5vbignY2xpY2snLCAnLmRhdGVwaWNrZXItLW5hdi10aXRsZScsICQucHJveHkodGhpcy5fb25DbGlja05hdlRpdGxlLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuZC4kZGF0ZXBpY2tlci5vbignY2xpY2snLCAnLmRhdGVwaWNrZXItLWJ1dHRvbicsICQucHJveHkodGhpcy5fb25DbGlja05hdkJ1dHRvbiwgdGhpcykpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9idWlsZEJhc2VIdG1sOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRzLm9ubHlUaW1lcGlja2VyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9hZGRCdXR0b25zSWZOZWVkKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2FkZEJ1dHRvbnNJZk5lZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy50b2RheUJ1dHRvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkQnV0dG9uKCd0b2RheScpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5jbGVhckJ1dHRvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkQnV0dG9uKCdjbGVhcicpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IHRoaXMuX2dldFRpdGxlKHRoaXMuZC5jdXJyZW50RGF0ZSksXHJcbiAgICAgICAgICAgICAgICBodG1sID0gZHAudGVtcGxhdGUodGVtcGxhdGUsICQuZXh0ZW5kKHt0aXRsZTogdGl0bGV9LCB0aGlzLm9wdHMpKTtcclxuICAgICAgICAgICAgdGhpcy5kLiRuYXYuaHRtbChodG1sKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZC52aWV3ID09ICd5ZWFycycpIHtcclxuICAgICAgICAgICAgICAgICQoJy5kYXRlcGlja2VyLS1uYXYtdGl0bGUnLCB0aGlzLmQuJG5hdikuYWRkQ2xhc3MoJy1kaXNhYmxlZC0nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNldE5hdlN0YXR1cygpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRUaXRsZTogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZC5mb3JtYXREYXRlKHRoaXMub3B0cy5uYXZUaXRsZXNbdGhpcy5kLnZpZXddLCBkYXRlKVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9hZGRCdXR0b246IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy4kYnV0dG9uc0NvbnRhaW5lci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEJ1dHRvbnNDb250YWluZXIoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmQubG9jW3R5cGVdXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaHRtbCA9IGRwLnRlbXBsYXRlKGJ1dHRvbiwgZGF0YSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoJCgnW2RhdGEtYWN0aW9uPScgKyB0eXBlICsgJ10nLCB0aGlzLiRidXR0b25zQ29udGFpbmVyKS5sZW5ndGgpIHJldHVybjtcclxuICAgICAgICAgICAgdGhpcy4kYnV0dG9uc0NvbnRhaW5lci5hcHBlbmQoaHRtbCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2FkZEJ1dHRvbnNDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5kLiRkYXRlcGlja2VyLmFwcGVuZChidXR0b25zQ29udGFpbmVyVGVtcGxhdGUpO1xyXG4gICAgICAgICAgICB0aGlzLiRidXR0b25zQ29udGFpbmVyID0gJCgnLmRhdGVwaWNrZXItLWJ1dHRvbnMnLCB0aGlzLmQuJGRhdGVwaWNrZXIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldE5hdlN0YXR1czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoISh0aGlzLm9wdHMubWluRGF0ZSB8fCB0aGlzLm9wdHMubWF4RGF0ZSkgfHwgIXRoaXMub3B0cy5kaXNhYmxlTmF2V2hlbk91dE9mUmFuZ2UpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIHZhciBkYXRlID0gdGhpcy5kLnBhcnNlZERhdGUsXHJcbiAgICAgICAgICAgICAgICBtID0gZGF0ZS5tb250aCxcclxuICAgICAgICAgICAgICAgIHkgPSBkYXRlLnllYXIsXHJcbiAgICAgICAgICAgICAgICBkID0gZGF0ZS5kYXRlO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmQudmlldykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5cyc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmQuX2lzSW5SYW5nZShuZXcgRGF0ZSh5LCBtLTEsIDEpLCAnbW9udGgnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNhYmxlTmF2KCdwcmV2JylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmQuX2lzSW5SYW5nZShuZXcgRGF0ZSh5LCBtKzEsIDEpLCAnbW9udGgnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNhYmxlTmF2KCduZXh0JylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aHMnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5kLl9pc0luUmFuZ2UobmV3IERhdGUoeS0xLCBtLCBkKSwgJ3llYXInKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNhYmxlTmF2KCdwcmV2JylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmQuX2lzSW5SYW5nZShuZXcgRGF0ZSh5KzEsIG0sIGQpLCAneWVhcicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVOYXYoJ25leHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3llYXJzJzpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjYWRlID0gZHAuZ2V0RGVjYWRlKHRoaXMuZC5kYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZC5faXNJblJhbmdlKG5ldyBEYXRlKGRlY2FkZVswXSAtIDEsIDAsIDEpLCAneWVhcicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVOYXYoJ3ByZXYnKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZC5faXNJblJhbmdlKG5ldyBEYXRlKGRlY2FkZVsxXSArIDEsIDAsIDEpLCAneWVhcicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVOYXYoJ25leHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9kaXNhYmxlTmF2OiBmdW5jdGlvbiAobmF2KSB7XHJcbiAgICAgICAgICAgICQoJ1tkYXRhLWFjdGlvbj1cIicgKyBuYXYgKyAnXCJdJywgdGhpcy5kLiRuYXYpLmFkZENsYXNzKCctZGlzYWJsZWQtJylcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYWN0aXZhdGVOYXY6IGZ1bmN0aW9uIChuYXYpIHtcclxuICAgICAgICAgICAgJCgnW2RhdGEtYWN0aW9uPVwiJyArIG5hdiArICdcIl0nLCB0aGlzLmQuJG5hdikucmVtb3ZlQ2xhc3MoJy1kaXNhYmxlZC0nKVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9vbkNsaWNrTmF2QnV0dG9uOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIgJGVsID0gJChlLnRhcmdldCkuY2xvc2VzdCgnW2RhdGEtYWN0aW9uXScpLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uID0gJGVsLmRhdGEoJ2FjdGlvbicpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kW2FjdGlvbl0oKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfb25DbGlja05hdlRpdGxlOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAoJChlLnRhcmdldCkuaGFzQ2xhc3MoJy1kaXNhYmxlZC0nKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZC52aWV3ID09ICdkYXlzJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZC52aWV3ID0gJ21vbnRocydcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5kLnZpZXcgPSAneWVhcnMnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn0pKCk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/air-datepicker/src/js/navigation.js\n");

/***/ }),

/***/ "./node_modules/air-datepicker/src/js/timepicker.js":
/*!**********************************************************!*\
  !*** ./node_modules/air-datepicker/src/js/timepicker.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval(";(function () {\r\n    var template = '<div class=\"datepicker--time\">' +\r\n        '<div class=\"datepicker--time-current\">' +\r\n        '   <span class=\"datepicker--time-current-hours\">#{hourVisible}</span>' +\r\n        '   <span class=\"datepicker--time-current-colon\">:</span>' +\r\n        '   <span class=\"datepicker--time-current-minutes\">#{minValue}</span>' +\r\n        '</div>' +\r\n        '<div class=\"datepicker--time-sliders\">' +\r\n        '   <div class=\"datepicker--time-row\">' +\r\n        '      <input type=\"range\" name=\"hours\" value=\"#{hourValue}\" min=\"#{hourMin}\" max=\"#{hourMax}\" step=\"#{hourStep}\"/>' +\r\n        '   </div>' +\r\n        '   <div class=\"datepicker--time-row\">' +\r\n        '      <input type=\"range\" name=\"minutes\" value=\"#{minValue}\" min=\"#{minMin}\" max=\"#{minMax}\" step=\"#{minStep}\"/>' +\r\n        '   </div>' +\r\n        '</div>' +\r\n        '</div>',\r\n        datepicker = $.fn.datepicker,\r\n        dp = datepicker.Constructor;\r\n\r\n    datepicker.Timepicker = function (inst, opts) {\r\n        this.d = inst;\r\n        this.opts = opts;\r\n\r\n        this.init();\r\n    };\r\n\r\n    datepicker.Timepicker.prototype = {\r\n        init: function () {\r\n            var input = 'input';\r\n            this._setTime(this.d.date);\r\n            this._buildHTML();\r\n\r\n            if (navigator.userAgent.match(/trident/gi)) {\r\n                input = 'change';\r\n            }\r\n\r\n            this.d.$el.on('selectDate', this._onSelectDate.bind(this));\r\n            this.$ranges.on(input, this._onChangeRange.bind(this));\r\n            this.$ranges.on('mouseup', this._onMouseUpRange.bind(this));\r\n            this.$ranges.on('mousemove focus ', this._onMouseEnterRange.bind(this));\r\n            this.$ranges.on('mouseout blur', this._onMouseOutRange.bind(this));\r\n        },\r\n\r\n        _setTime: function (date) {\r\n            var _date = dp.getParsedDate(date);\r\n\r\n            this._handleDate(date);\r\n            this.hours = _date.hours < this.minHours ? this.minHours : _date.hours;\r\n            this.minutes = _date.minutes < this.minMinutes ? this.minMinutes : _date.minutes;\r\n        },\r\n\r\n        /**\r\n         * Sets minHours and minMinutes from date (usually it's a minDate)\r\n         * Also changes minMinutes if current hours are bigger then @date hours\r\n         * @param date {Date}\r\n         * @private\r\n         */\r\n        _setMinTimeFromDate: function (date) {\r\n            this.minHours = date.getHours();\r\n            this.minMinutes = date.getMinutes();\r\n\r\n            // If, for example, min hours are 10, and current hours are 12,\r\n            // update minMinutes to default value, to be able to choose whole range of values\r\n            if (this.d.lastSelectedDate) {\r\n                if (this.d.lastSelectedDate.getHours() > date.getHours()) {\r\n                    this.minMinutes = this.opts.minMinutes;\r\n                }\r\n            }\r\n        },\r\n\r\n        _setMaxTimeFromDate: function (date) {\r\n            this.maxHours = date.getHours();\r\n            this.maxMinutes = date.getMinutes();\r\n\r\n            if (this.d.lastSelectedDate) {\r\n                if (this.d.lastSelectedDate.getHours() < date.getHours()) {\r\n                    this.maxMinutes = this.opts.maxMinutes;\r\n                }\r\n            }\r\n        },\r\n\r\n        _setDefaultMinMaxTime: function () {\r\n            var maxHours = 23,\r\n                maxMinutes = 59,\r\n                opts = this.opts;\r\n\r\n            this.minHours = opts.minHours < 0 || opts.minHours > maxHours ? 0 : opts.minHours;\r\n            this.minMinutes = opts.minMinutes < 0 || opts.minMinutes > maxMinutes ? 0 : opts.minMinutes;\r\n            this.maxHours = opts.maxHours < 0 || opts.maxHours > maxHours ? maxHours : opts.maxHours;\r\n            this.maxMinutes = opts.maxMinutes < 0 || opts.maxMinutes > maxMinutes ? maxMinutes : opts.maxMinutes;\r\n        },\r\n\r\n        /**\r\n         * Looks for min/max hours/minutes and if current values\r\n         * are out of range sets valid values.\r\n         * @private\r\n         */\r\n        _validateHoursMinutes: function (date) {\r\n            if (this.hours < this.minHours) {\r\n                this.hours = this.minHours;\r\n            } else if (this.hours > this.maxHours) {\r\n                this.hours = this.maxHours;\r\n            }\r\n\r\n            if (this.minutes < this.minMinutes) {\r\n                this.minutes = this.minMinutes;\r\n            } else if (this.minutes > this.maxMinutes) {\r\n                this.minutes = this.maxMinutes;\r\n            }\r\n        },\r\n\r\n        _buildHTML: function () {\r\n            var lz = dp.getLeadingZeroNum,\r\n                data = {\r\n                    hourMin: this.minHours,\r\n                    hourMax: lz(this.maxHours),\r\n                    hourStep: this.opts.hoursStep,\r\n                    hourValue: this.hours,\r\n                    hourVisible: lz(this.displayHours),\r\n                    minMin: this.minMinutes,\r\n                    minMax: lz(this.maxMinutes),\r\n                    minStep: this.opts.minutesStep,\r\n                    minValue: lz(this.minutes)\r\n                },\r\n                _template = dp.template(template, data);\r\n\r\n            this.$timepicker = $(_template).appendTo(this.d.$datepicker);\r\n            this.$ranges = $('[type=\"range\"]', this.$timepicker);\r\n            this.$hours = $('[name=\"hours\"]', this.$timepicker);\r\n            this.$minutes = $('[name=\"minutes\"]', this.$timepicker);\r\n            this.$hoursText = $('.datepicker--time-current-hours', this.$timepicker);\r\n            this.$minutesText = $('.datepicker--time-current-minutes', this.$timepicker);\r\n\r\n            if (this.d.ampm) {\r\n                this.$ampm = $('<span class=\"datepicker--time-current-ampm\">')\r\n                    .appendTo($('.datepicker--time-current', this.$timepicker))\r\n                    .html(this.dayPeriod);\r\n\r\n                this.$timepicker.addClass('-am-pm-');\r\n            }\r\n        },\r\n\r\n        _updateCurrentTime: function () {\r\n            var h =  dp.getLeadingZeroNum(this.displayHours),\r\n                m = dp.getLeadingZeroNum(this.minutes);\r\n\r\n            this.$hoursText.html(h);\r\n            this.$minutesText.html(m);\r\n\r\n            if (this.d.ampm) {\r\n                this.$ampm.html(this.dayPeriod);\r\n            }\r\n        },\r\n\r\n        _updateRanges: function () {\r\n            this.$hours.attr({\r\n                min: this.minHours,\r\n                max: this.maxHours\r\n            }).val(this.hours);\r\n\r\n            this.$minutes.attr({\r\n                min: this.minMinutes,\r\n                max: this.maxMinutes\r\n            }).val(this.minutes)\r\n        },\r\n\r\n        /**\r\n         * Sets minHours, minMinutes etc. from date. If date is not passed, than sets\r\n         * values from options\r\n         * @param [date] {object} - Date object, to get values from\r\n         * @private\r\n         */\r\n        _handleDate: function (date) {\r\n            this._setDefaultMinMaxTime();\r\n            if (date) {\r\n                if (dp.isSame(date, this.d.opts.minDate)) {\r\n                    this._setMinTimeFromDate(this.d.opts.minDate);\r\n                } else if (dp.isSame(date, this.d.opts.maxDate)) {\r\n                    this._setMaxTimeFromDate(this.d.opts.maxDate);\r\n                }\r\n            }\r\n\r\n            this._validateHoursMinutes(date);\r\n        },\r\n\r\n        update: function () {\r\n            this._updateRanges();\r\n            this._updateCurrentTime();\r\n        },\r\n\r\n        /**\r\n         * Calculates valid hour value to display in text input and datepicker's body.\r\n         * @param date {Date|Number} - date or hours\r\n         * @param [ampm] {Boolean} - 12 hours mode\r\n         * @returns {{hours: *, dayPeriod: string}}\r\n         * @private\r\n         */\r\n        _getValidHoursFromDate: function (date, ampm) {\r\n            var d = date,\r\n                hours = date;\r\n\r\n            if (date instanceof Date) {\r\n                d = dp.getParsedDate(date);\r\n                hours = d.hours;\r\n            }\r\n\r\n            var _ampm = ampm || this.d.ampm,\r\n                dayPeriod = 'am';\r\n\r\n            if (_ampm) {\r\n                switch(true) {\r\n                    case hours == 0:\r\n                        hours = 12;\r\n                        break;\r\n                    case hours == 12:\r\n                        dayPeriod = 'pm';\r\n                        break;\r\n                    case hours > 11:\r\n                        hours = hours - 12;\r\n                        dayPeriod = 'pm';\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return {\r\n                hours: hours,\r\n                dayPeriod: dayPeriod\r\n            }\r\n        },\r\n\r\n        set hours (val) {\r\n            this._hours = val;\r\n\r\n            var displayHours = this._getValidHoursFromDate(val);\r\n\r\n            this.displayHours = displayHours.hours;\r\n            this.dayPeriod = displayHours.dayPeriod;\r\n        },\r\n\r\n        get hours() {\r\n            return this._hours;\r\n        },\r\n\r\n        //  Events\r\n        // -------------------------------------------------\r\n\r\n        _onChangeRange: function (e) {\r\n            var $target = $(e.target),\r\n                name = $target.attr('name');\r\n            \r\n            this.d.timepickerIsActive = true;\r\n\r\n            this[name] = $target.val();\r\n            this._updateCurrentTime();\r\n            this.d._trigger('timeChange', [this.hours, this.minutes]);\r\n\r\n            this._handleDate(this.d.lastSelectedDate);\r\n            this.update()\r\n        },\r\n\r\n        _onSelectDate: function (e, data) {\r\n            this._handleDate(data);\r\n            this.update();\r\n        },\r\n\r\n        _onMouseEnterRange: function (e) {\r\n            var name = $(e.target).attr('name');\r\n            $('.datepicker--time-current-' + name, this.$timepicker).addClass('-focus-');\r\n        },\r\n\r\n        _onMouseOutRange: function (e) {\r\n            var name = $(e.target).attr('name');\r\n            if (this.d.inFocus) return; // Prevent removing focus when mouse out of range slider\r\n            $('.datepicker--time-current-' + name, this.$timepicker).removeClass('-focus-');\r\n        },\r\n\r\n        _onMouseUpRange: function (e) {\r\n            this.d.timepickerIsActive = false;\r\n        }\r\n    };\r\n})();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWlyLWRhdGVwaWNrZXIvc3JjL2pzL3RpbWVwaWNrZXIuanM/MTA3NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDJEQUEyRCxZQUFZO0FBQ3ZFO0FBQ0EsNkRBQTZELFNBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0EseURBQXlELFVBQVUsU0FBUyxRQUFRLFNBQVMsUUFBUSxVQUFVLFNBQVM7QUFDeEg7QUFDQTtBQUNBLDJEQUEyRCxTQUFTLFNBQVMsT0FBTyxTQUFTLE9BQU8sVUFBVSxRQUFRO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQywwQkFBMEIsUUFBUTtBQUNsQyxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Fpci1kYXRlcGlja2VyL3NyYy9qcy90aW1lcGlja2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdGVtcGxhdGUgPSAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItLXRpbWVcIj4nICtcclxuICAgICAgICAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItLXRpbWUtY3VycmVudFwiPicgK1xyXG4gICAgICAgICcgICA8c3BhbiBjbGFzcz1cImRhdGVwaWNrZXItLXRpbWUtY3VycmVudC1ob3Vyc1wiPiN7aG91clZpc2libGV9PC9zcGFuPicgK1xyXG4gICAgICAgICcgICA8c3BhbiBjbGFzcz1cImRhdGVwaWNrZXItLXRpbWUtY3VycmVudC1jb2xvblwiPjo8L3NwYW4+JyArXHJcbiAgICAgICAgJyAgIDxzcGFuIGNsYXNzPVwiZGF0ZXBpY2tlci0tdGltZS1jdXJyZW50LW1pbnV0ZXNcIj4je21pblZhbHVlfTwvc3Bhbj4nICtcclxuICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLS10aW1lLXNsaWRlcnNcIj4nICtcclxuICAgICAgICAnICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItLXRpbWUtcm93XCI+JyArXHJcbiAgICAgICAgJyAgICAgIDxpbnB1dCB0eXBlPVwicmFuZ2VcIiBuYW1lPVwiaG91cnNcIiB2YWx1ZT1cIiN7aG91clZhbHVlfVwiIG1pbj1cIiN7aG91ck1pbn1cIiBtYXg9XCIje2hvdXJNYXh9XCIgc3RlcD1cIiN7aG91clN0ZXB9XCIvPicgK1xyXG4gICAgICAgICcgICA8L2Rpdj4nICtcclxuICAgICAgICAnICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItLXRpbWUtcm93XCI+JyArXHJcbiAgICAgICAgJyAgICAgIDxpbnB1dCB0eXBlPVwicmFuZ2VcIiBuYW1lPVwibWludXRlc1wiIHZhbHVlPVwiI3ttaW5WYWx1ZX1cIiBtaW49XCIje21pbk1pbn1cIiBtYXg9XCIje21pbk1heH1cIiBzdGVwPVwiI3ttaW5TdGVwfVwiLz4nICtcclxuICAgICAgICAnICAgPC9kaXY+JyArXHJcbiAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICc8L2Rpdj4nLFxyXG4gICAgICAgIGRhdGVwaWNrZXIgPSAkLmZuLmRhdGVwaWNrZXIsXHJcbiAgICAgICAgZHAgPSBkYXRlcGlja2VyLkNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGRhdGVwaWNrZXIuVGltZXBpY2tlciA9IGZ1bmN0aW9uIChpbnN0LCBvcHRzKSB7XHJcbiAgICAgICAgdGhpcy5kID0gaW5zdDtcclxuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xyXG5cclxuICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgIH07XHJcblxyXG4gICAgZGF0ZXBpY2tlci5UaW1lcGlja2VyLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dCA9ICdpbnB1dCc7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFRpbWUodGhpcy5kLmRhdGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9idWlsZEhUTUwoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC90cmlkZW50L2dpKSkge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQgPSAnY2hhbmdlJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5kLiRlbC5vbignc2VsZWN0RGF0ZScsIHRoaXMuX29uU2VsZWN0RGF0ZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgdGhpcy4kcmFuZ2VzLm9uKGlucHV0LCB0aGlzLl9vbkNoYW5nZVJhbmdlLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLiRyYW5nZXMub24oJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXBSYW5nZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgdGhpcy4kcmFuZ2VzLm9uKCdtb3VzZW1vdmUgZm9jdXMgJywgdGhpcy5fb25Nb3VzZUVudGVyUmFuZ2UuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuJHJhbmdlcy5vbignbW91c2VvdXQgYmx1cicsIHRoaXMuX29uTW91c2VPdXRSYW5nZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfc2V0VGltZTogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAgICAgdmFyIF9kYXRlID0gZHAuZ2V0UGFyc2VkRGF0ZShkYXRlKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZURhdGUoZGF0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuaG91cnMgPSBfZGF0ZS5ob3VycyA8IHRoaXMubWluSG91cnMgPyB0aGlzLm1pbkhvdXJzIDogX2RhdGUuaG91cnM7XHJcbiAgICAgICAgICAgIHRoaXMubWludXRlcyA9IF9kYXRlLm1pbnV0ZXMgPCB0aGlzLm1pbk1pbnV0ZXMgPyB0aGlzLm1pbk1pbnV0ZXMgOiBfZGF0ZS5taW51dGVzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgbWluSG91cnMgYW5kIG1pbk1pbnV0ZXMgZnJvbSBkYXRlICh1c3VhbGx5IGl0J3MgYSBtaW5EYXRlKVxyXG4gICAgICAgICAqIEFsc28gY2hhbmdlcyBtaW5NaW51dGVzIGlmIGN1cnJlbnQgaG91cnMgYXJlIGJpZ2dlciB0aGVuIEBkYXRlIGhvdXJzXHJcbiAgICAgICAgICogQHBhcmFtIGRhdGUge0RhdGV9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfc2V0TWluVGltZUZyb21EYXRlOiBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm1pbkhvdXJzID0gZGF0ZS5nZXRIb3VycygpO1xyXG4gICAgICAgICAgICB0aGlzLm1pbk1pbnV0ZXMgPSBkYXRlLmdldE1pbnV0ZXMoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmLCBmb3IgZXhhbXBsZSwgbWluIGhvdXJzIGFyZSAxMCwgYW5kIGN1cnJlbnQgaG91cnMgYXJlIDEyLFxyXG4gICAgICAgICAgICAvLyB1cGRhdGUgbWluTWludXRlcyB0byBkZWZhdWx0IHZhbHVlLCB0byBiZSBhYmxlIHRvIGNob29zZSB3aG9sZSByYW5nZSBvZiB2YWx1ZXNcclxuICAgICAgICAgICAgaWYgKHRoaXMuZC5sYXN0U2VsZWN0ZWREYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kLmxhc3RTZWxlY3RlZERhdGUuZ2V0SG91cnMoKSA+IGRhdGUuZ2V0SG91cnMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWluTWludXRlcyA9IHRoaXMub3B0cy5taW5NaW51dGVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3NldE1heFRpbWVGcm9tRGF0ZTogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXhIb3VycyA9IGRhdGUuZ2V0SG91cnMoKTtcclxuICAgICAgICAgICAgdGhpcy5tYXhNaW51dGVzID0gZGF0ZS5nZXRNaW51dGVzKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5kLmxhc3RTZWxlY3RlZERhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmQubGFzdFNlbGVjdGVkRGF0ZS5nZXRIb3VycygpIDwgZGF0ZS5nZXRIb3VycygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhNaW51dGVzID0gdGhpcy5vcHRzLm1heE1pbnV0ZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfc2V0RGVmYXVsdE1pbk1heFRpbWU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG1heEhvdXJzID0gMjMsXHJcbiAgICAgICAgICAgICAgICBtYXhNaW51dGVzID0gNTksXHJcbiAgICAgICAgICAgICAgICBvcHRzID0gdGhpcy5vcHRzO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5taW5Ib3VycyA9IG9wdHMubWluSG91cnMgPCAwIHx8IG9wdHMubWluSG91cnMgPiBtYXhIb3VycyA/IDAgOiBvcHRzLm1pbkhvdXJzO1xyXG4gICAgICAgICAgICB0aGlzLm1pbk1pbnV0ZXMgPSBvcHRzLm1pbk1pbnV0ZXMgPCAwIHx8IG9wdHMubWluTWludXRlcyA+IG1heE1pbnV0ZXMgPyAwIDogb3B0cy5taW5NaW51dGVzO1xyXG4gICAgICAgICAgICB0aGlzLm1heEhvdXJzID0gb3B0cy5tYXhIb3VycyA8IDAgfHwgb3B0cy5tYXhIb3VycyA+IG1heEhvdXJzID8gbWF4SG91cnMgOiBvcHRzLm1heEhvdXJzO1xyXG4gICAgICAgICAgICB0aGlzLm1heE1pbnV0ZXMgPSBvcHRzLm1heE1pbnV0ZXMgPCAwIHx8IG9wdHMubWF4TWludXRlcyA+IG1heE1pbnV0ZXMgPyBtYXhNaW51dGVzIDogb3B0cy5tYXhNaW51dGVzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvb2tzIGZvciBtaW4vbWF4IGhvdXJzL21pbnV0ZXMgYW5kIGlmIGN1cnJlbnQgdmFsdWVzXHJcbiAgICAgICAgICogYXJlIG91dCBvZiByYW5nZSBzZXRzIHZhbGlkIHZhbHVlcy5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF92YWxpZGF0ZUhvdXJzTWludXRlczogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaG91cnMgPCB0aGlzLm1pbkhvdXJzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXJzID0gdGhpcy5taW5Ib3VycztcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhvdXJzID4gdGhpcy5tYXhIb3Vycykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ob3VycyA9IHRoaXMubWF4SG91cnM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1pbnV0ZXMgPCB0aGlzLm1pbk1pbnV0ZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWludXRlcyA9IHRoaXMubWluTWludXRlcztcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1pbnV0ZXMgPiB0aGlzLm1heE1pbnV0ZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWludXRlcyA9IHRoaXMubWF4TWludXRlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9idWlsZEhUTUw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGx6ID0gZHAuZ2V0TGVhZGluZ1plcm9OdW0sXHJcbiAgICAgICAgICAgICAgICBkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvdXJNaW46IHRoaXMubWluSG91cnMsXHJcbiAgICAgICAgICAgICAgICAgICAgaG91ck1heDogbHoodGhpcy5tYXhIb3VycyksXHJcbiAgICAgICAgICAgICAgICAgICAgaG91clN0ZXA6IHRoaXMub3B0cy5ob3Vyc1N0ZXAsXHJcbiAgICAgICAgICAgICAgICAgICAgaG91clZhbHVlOiB0aGlzLmhvdXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIGhvdXJWaXNpYmxlOiBseih0aGlzLmRpc3BsYXlIb3VycyksXHJcbiAgICAgICAgICAgICAgICAgICAgbWluTWluOiB0aGlzLm1pbk1pbnV0ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgbWluTWF4OiBseih0aGlzLm1heE1pbnV0ZXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pblN0ZXA6IHRoaXMub3B0cy5taW51dGVzU3RlcCxcclxuICAgICAgICAgICAgICAgICAgICBtaW5WYWx1ZTogbHoodGhpcy5taW51dGVzKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF90ZW1wbGF0ZSA9IGRwLnRlbXBsYXRlKHRlbXBsYXRlLCBkYXRhKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuJHRpbWVwaWNrZXIgPSAkKF90ZW1wbGF0ZSkuYXBwZW5kVG8odGhpcy5kLiRkYXRlcGlja2VyKTtcclxuICAgICAgICAgICAgdGhpcy4kcmFuZ2VzID0gJCgnW3R5cGU9XCJyYW5nZVwiXScsIHRoaXMuJHRpbWVwaWNrZXIpO1xyXG4gICAgICAgICAgICB0aGlzLiRob3VycyA9ICQoJ1tuYW1lPVwiaG91cnNcIl0nLCB0aGlzLiR0aW1lcGlja2VyKTtcclxuICAgICAgICAgICAgdGhpcy4kbWludXRlcyA9ICQoJ1tuYW1lPVwibWludXRlc1wiXScsIHRoaXMuJHRpbWVwaWNrZXIpO1xyXG4gICAgICAgICAgICB0aGlzLiRob3Vyc1RleHQgPSAkKCcuZGF0ZXBpY2tlci0tdGltZS1jdXJyZW50LWhvdXJzJywgdGhpcy4kdGltZXBpY2tlcik7XHJcbiAgICAgICAgICAgIHRoaXMuJG1pbnV0ZXNUZXh0ID0gJCgnLmRhdGVwaWNrZXItLXRpbWUtY3VycmVudC1taW51dGVzJywgdGhpcy4kdGltZXBpY2tlcik7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5kLmFtcG0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGFtcG0gPSAkKCc8c3BhbiBjbGFzcz1cImRhdGVwaWNrZXItLXRpbWUtY3VycmVudC1hbXBtXCI+JylcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oJCgnLmRhdGVwaWNrZXItLXRpbWUtY3VycmVudCcsIHRoaXMuJHRpbWVwaWNrZXIpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5odG1sKHRoaXMuZGF5UGVyaW9kKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLiR0aW1lcGlja2VyLmFkZENsYXNzKCctYW0tcG0tJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfdXBkYXRlQ3VycmVudFRpbWU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGggPSAgZHAuZ2V0TGVhZGluZ1plcm9OdW0odGhpcy5kaXNwbGF5SG91cnMpLFxyXG4gICAgICAgICAgICAgICAgbSA9IGRwLmdldExlYWRpbmdaZXJvTnVtKHRoaXMubWludXRlcyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLiRob3Vyc1RleHQuaHRtbChoKTtcclxuICAgICAgICAgICAgdGhpcy4kbWludXRlc1RleHQuaHRtbChtKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmQuYW1wbSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kYW1wbS5odG1sKHRoaXMuZGF5UGVyaW9kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF91cGRhdGVSYW5nZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy4kaG91cnMuYXR0cih7XHJcbiAgICAgICAgICAgICAgICBtaW46IHRoaXMubWluSG91cnMsXHJcbiAgICAgICAgICAgICAgICBtYXg6IHRoaXMubWF4SG91cnNcclxuICAgICAgICAgICAgfSkudmFsKHRoaXMuaG91cnMpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy4kbWludXRlcy5hdHRyKHtcclxuICAgICAgICAgICAgICAgIG1pbjogdGhpcy5taW5NaW51dGVzLFxyXG4gICAgICAgICAgICAgICAgbWF4OiB0aGlzLm1heE1pbnV0ZXNcclxuICAgICAgICAgICAgfSkudmFsKHRoaXMubWludXRlcylcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIG1pbkhvdXJzLCBtaW5NaW51dGVzIGV0Yy4gZnJvbSBkYXRlLiBJZiBkYXRlIGlzIG5vdCBwYXNzZWQsIHRoYW4gc2V0c1xyXG4gICAgICAgICAqIHZhbHVlcyBmcm9tIG9wdGlvbnNcclxuICAgICAgICAgKiBAcGFyYW0gW2RhdGVdIHtvYmplY3R9IC0gRGF0ZSBvYmplY3QsIHRvIGdldCB2YWx1ZXMgZnJvbVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2hhbmRsZURhdGU6IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldERlZmF1bHRNaW5NYXhUaW1lKCk7XHJcbiAgICAgICAgICAgIGlmIChkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZHAuaXNTYW1lKGRhdGUsIHRoaXMuZC5vcHRzLm1pbkRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0TWluVGltZUZyb21EYXRlKHRoaXMuZC5vcHRzLm1pbkRhdGUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkcC5pc1NhbWUoZGF0ZSwgdGhpcy5kLm9wdHMubWF4RGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRNYXhUaW1lRnJvbURhdGUodGhpcy5kLm9wdHMubWF4RGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlSG91cnNNaW51dGVzKGRhdGUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVSYW5nZXMoKTtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ3VycmVudFRpbWUoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIHZhbGlkIGhvdXIgdmFsdWUgdG8gZGlzcGxheSBpbiB0ZXh0IGlucHV0IGFuZCBkYXRlcGlja2VyJ3MgYm9keS5cclxuICAgICAgICAgKiBAcGFyYW0gZGF0ZSB7RGF0ZXxOdW1iZXJ9IC0gZGF0ZSBvciBob3Vyc1xyXG4gICAgICAgICAqIEBwYXJhbSBbYW1wbV0ge0Jvb2xlYW59IC0gMTIgaG91cnMgbW9kZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt7aG91cnM6ICosIGRheVBlcmlvZDogc3RyaW5nfX1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9nZXRWYWxpZEhvdXJzRnJvbURhdGU6IGZ1bmN0aW9uIChkYXRlLCBhbXBtKSB7XHJcbiAgICAgICAgICAgIHZhciBkID0gZGF0ZSxcclxuICAgICAgICAgICAgICAgIGhvdXJzID0gZGF0ZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgZCA9IGRwLmdldFBhcnNlZERhdGUoZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBob3VycyA9IGQuaG91cnM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBfYW1wbSA9IGFtcG0gfHwgdGhpcy5kLmFtcG0sXHJcbiAgICAgICAgICAgICAgICBkYXlQZXJpb2QgPSAnYW0nO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9hbXBtKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2godHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaG91cnMgPT0gMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG91cnMgPSAxMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBob3VycyA9PSAxMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF5UGVyaW9kID0gJ3BtJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBob3VycyA+IDExOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3VycyA9IGhvdXJzIC0gMTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheVBlcmlvZCA9ICdwbSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgaG91cnM6IGhvdXJzLFxyXG4gICAgICAgICAgICAgICAgZGF5UGVyaW9kOiBkYXlQZXJpb2RcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldCBob3VycyAodmFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hvdXJzID0gdmFsO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRpc3BsYXlIb3VycyA9IHRoaXMuX2dldFZhbGlkSG91cnNGcm9tRGF0ZSh2YWwpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kaXNwbGF5SG91cnMgPSBkaXNwbGF5SG91cnMuaG91cnM7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5UGVyaW9kID0gZGlzcGxheUhvdXJzLmRheVBlcmlvZDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXQgaG91cnMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ob3VycztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyAgRXZlbnRzXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgICAgICBfb25DaGFuZ2VSYW5nZTogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdmFyICR0YXJnZXQgPSAkKGUudGFyZ2V0KSxcclxuICAgICAgICAgICAgICAgIG5hbWUgPSAkdGFyZ2V0LmF0dHIoJ25hbWUnKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuZC50aW1lcGlja2VySXNBY3RpdmUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgdGhpc1tuYW1lXSA9ICR0YXJnZXQudmFsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUN1cnJlbnRUaW1lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZC5fdHJpZ2dlcigndGltZUNoYW5nZScsIFt0aGlzLmhvdXJzLCB0aGlzLm1pbnV0ZXNdKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZURhdGUodGhpcy5kLmxhc3RTZWxlY3RlZERhdGUpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX29uU2VsZWN0RGF0ZTogZnVuY3Rpb24gKGUsIGRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlRGF0ZShkYXRhKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfb25Nb3VzZUVudGVyUmFuZ2U6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gJChlLnRhcmdldCkuYXR0cignbmFtZScpO1xyXG4gICAgICAgICAgICAkKCcuZGF0ZXBpY2tlci0tdGltZS1jdXJyZW50LScgKyBuYW1lLCB0aGlzLiR0aW1lcGlja2VyKS5hZGRDbGFzcygnLWZvY3VzLScpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9vbk1vdXNlT3V0UmFuZ2U6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gJChlLnRhcmdldCkuYXR0cignbmFtZScpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kLmluRm9jdXMpIHJldHVybjsgLy8gUHJldmVudCByZW1vdmluZyBmb2N1cyB3aGVuIG1vdXNlIG91dCBvZiByYW5nZSBzbGlkZXJcclxuICAgICAgICAgICAgJCgnLmRhdGVwaWNrZXItLXRpbWUtY3VycmVudC0nICsgbmFtZSwgdGhpcy4kdGltZXBpY2tlcikucmVtb3ZlQ2xhc3MoJy1mb2N1cy0nKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfb25Nb3VzZVVwUmFuZ2U6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZC50aW1lcGlja2VySXNBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59KSgpO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/air-datepicker/src/js/timepicker.js\n");

/***/ }),

/***/ "./node_modules/inputmask/dist/inputmask.js":
/*!**************************************************!*\
  !*** ./node_modules/inputmask/dist/inputmask.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * dist/inputmask\n * https://github.com/RobinHerbots/Inputmask\n * Copyright (c) 2010 - 2021 Robin Herbots\n * Licensed under the MIT license\n * Version: 5.0.6\n */\n!function(e, t) {\n    if (true) module.exports = t(); else { var i, a; }\n}(this, (function() {\n    return function() {\n        \"use strict\";\n        var e = {\n            4528: function(e) {\n                e.exports = JSON.parse('{\"BACKSPACE\":8,\"BACKSPACE_SAFARI\":127,\"DELETE\":46,\"DOWN\":40,\"END\":35,\"ENTER\":13,\"ESCAPE\":27,\"HOME\":36,\"INSERT\":45,\"LEFT\":37,\"PAGE_DOWN\":34,\"PAGE_UP\":33,\"RIGHT\":39,\"SPACE\":32,\"TAB\":9,\"UP\":38,\"X\":88,\"Z\":90,\"CONTROL\":17,\"PAUSE/BREAK\":19,\"WINDOWS_LEFT\":91,\"WINDOWS_RIGHT\":92,\"KEY_229\":229}');\n            },\n            8741: function(e, t) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = void 0;\n                var a = !(\"undefined\" == typeof window || !window.document || !window.document.createElement);\n                t.default = a;\n            },\n            3976: function(e, t, a) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = void 0;\n                var i, n = (i = a(4528)) && i.__esModule ? i : {\n                    default: i\n                };\n                var r = {\n                    _maxTestPos: 500,\n                    placeholder: \"_\",\n                    optionalmarker: [ \"[\", \"]\" ],\n                    quantifiermarker: [ \"{\", \"}\" ],\n                    groupmarker: [ \"(\", \")\" ],\n                    alternatormarker: \"|\",\n                    escapeChar: \"\\\\\",\n                    mask: null,\n                    regex: null,\n                    oncomplete: function() {},\n                    onincomplete: function() {},\n                    oncleared: function() {},\n                    repeat: 0,\n                    greedy: !1,\n                    autoUnmask: !1,\n                    removeMaskOnSubmit: !1,\n                    clearMaskOnLostFocus: !0,\n                    insertMode: !0,\n                    insertModeVisual: !0,\n                    clearIncomplete: !1,\n                    alias: null,\n                    onKeyDown: function() {},\n                    onBeforeMask: null,\n                    onBeforePaste: function(e, t) {\n                        return \"function\" == typeof t.onBeforeMask ? t.onBeforeMask.call(this, e, t) : e;\n                    },\n                    onBeforeWrite: null,\n                    onUnMask: null,\n                    showMaskOnFocus: !0,\n                    showMaskOnHover: !0,\n                    onKeyValidation: function() {},\n                    skipOptionalPartCharacter: \" \",\n                    numericInput: !1,\n                    rightAlign: !1,\n                    undoOnEscape: !0,\n                    radixPoint: \"\",\n                    _radixDance: !1,\n                    groupSeparator: \"\",\n                    keepStatic: null,\n                    positionCaretOnTab: !0,\n                    tabThrough: !1,\n                    supportsInputType: [ \"text\", \"tel\", \"url\", \"password\", \"search\" ],\n                    ignorables: [ n.default.BACKSPACE, n.default.TAB, n.default[\"PAUSE/BREAK\"], n.default.ESCAPE, n.default.PAGE_UP, n.default.PAGE_DOWN, n.default.END, n.default.HOME, n.default.LEFT, n.default.UP, n.default.RIGHT, n.default.DOWN, n.default.INSERT, n.default.DELETE, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229 ],\n                    isComplete: null,\n                    preValidation: null,\n                    postValidation: null,\n                    staticDefinitionSymbol: void 0,\n                    jitMasking: !1,\n                    nullable: !0,\n                    inputEventOnly: !1,\n                    noValuePatching: !1,\n                    positionCaretOnClick: \"lvp\",\n                    casing: null,\n                    inputmode: \"text\",\n                    importDataAttributes: !0,\n                    shiftPositions: !0,\n                    usePrototypeDefinitions: !0,\n                    validationEventTimeOut: 3e3\n                };\n                t.default = r;\n            },\n            7392: function(e, t) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = void 0;\n                t.default = {\n                    9: {\n                        validator: \"[0-9\\uff10-\\uff19]\",\n                        definitionSymbol: \"*\"\n                    },\n                    a: {\n                        validator: \"[A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\",\n                        definitionSymbol: \"*\"\n                    },\n                    \"*\": {\n                        validator: \"[0-9\\uff10-\\uff19A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\"\n                    }\n                };\n            },\n            253: function(e, t) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = function(e, t, a) {\n                    if (void 0 === a) return e.__data ? e.__data[t] : null;\n                    e.__data = e.__data || {}, e.__data[t] = a;\n                };\n            },\n            3776: function(e, t, a) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.on = function(e, t) {\n                    function a(e, a) {\n                        n.addEventListener ? n.addEventListener(e, t, !1) : n.attachEvent && n.attachEvent(\"on\" + e, t), \n                        i[e] = i[e] || {}, i[e][a] = i[e][a] || [], i[e][a].push(t);\n                    }\n                    if (u(this[0])) for (var i = this[0].eventRegistry, n = this[0], r = e.split(\" \"), o = 0; o < r.length; o++) {\n                        var s = r[o].split(\".\"), l = s[0], c = s[1] || \"global\";\n                        a(l, c);\n                    }\n                    return this;\n                }, t.off = function(e, t) {\n                    var a, i;\n                    function n(e, t, n) {\n                        if (e in a == !0) if (i.removeEventListener ? i.removeEventListener(e, n, !1) : i.detachEvent && i.detachEvent(\"on\" + e, n), \n                        \"global\" === t) for (var r in a[e]) a[e][r].splice(a[e][r].indexOf(n), 1); else a[e][t].splice(a[e][t].indexOf(n), 1);\n                    }\n                    function r(e, i) {\n                        var n, r, o = [];\n                        if (e.length > 0) if (void 0 === t) for (n = 0, r = a[e][i].length; n < r; n++) o.push({\n                            ev: e,\n                            namespace: i && i.length > 0 ? i : \"global\",\n                            handler: a[e][i][n]\n                        }); else o.push({\n                            ev: e,\n                            namespace: i && i.length > 0 ? i : \"global\",\n                            handler: t\n                        }); else if (i.length > 0) for (var s in a) for (var l in a[s]) if (l === i) if (void 0 === t) for (n = 0, \n                        r = a[s][l].length; n < r; n++) o.push({\n                            ev: s,\n                            namespace: l,\n                            handler: a[s][l][n]\n                        }); else o.push({\n                            ev: s,\n                            namespace: l,\n                            handler: t\n                        });\n                        return o;\n                    }\n                    if (u(this[0]) && e) {\n                        a = this[0].eventRegistry, i = this[0];\n                        for (var o = e.split(\" \"), s = 0; s < o.length; s++) for (var l = o[s].split(\".\"), c = r(l[0], l[1]), f = 0, d = c.length; f < d; f++) n(c[f].ev, c[f].namespace, c[f].handler);\n                    }\n                    return this;\n                }, t.trigger = function(e) {\n                    if (u(this[0])) for (var t = this[0].eventRegistry, a = this[0], i = \"string\" == typeof e ? e.split(\" \") : [ e.type ], r = 0; r < i.length; r++) {\n                        var s = i[r].split(\".\"), l = s[0], c = s[1] || \"global\";\n                        if (void 0 !== document && \"global\" === c) {\n                            var f, d, p = {\n                                bubbles: !0,\n                                cancelable: !0,\n                                detail: arguments[1]\n                            };\n                            if (document.createEvent) {\n                                try {\n                                    switch (l) {\n                                      case \"input\":\n                                        p.inputType = \"insertText\", f = new InputEvent(l, p);\n                                        break;\n\n                                      default:\n                                        f = new CustomEvent(l, p);\n                                    }\n                                } catch (e) {\n                                    (f = document.createEvent(\"CustomEvent\")).initCustomEvent(l, p.bubbles, p.cancelable, p.detail);\n                                }\n                                e.type && (0, n.default)(f, e), a.dispatchEvent(f);\n                            } else (f = document.createEventObject()).eventType = l, f.detail = arguments[1], \n                            e.type && (0, n.default)(f, e), a.fireEvent(\"on\" + f.eventType, f);\n                        } else if (void 0 !== t[l]) if (arguments[0] = arguments[0].type ? arguments[0] : o.default.Event(arguments[0]), \n                        arguments[0].detail = arguments.slice(1), \"global\" === c) for (var h in t[l]) for (d = 0; d < t[l][h].length; d++) t[l][h][d].apply(a, arguments); else for (d = 0; d < t[l][c].length; d++) t[l][c][d].apply(a, arguments);\n                    }\n                    return this;\n                }, t.Event = void 0;\n                var i, n = l(a(600)), r = l(a(9380)), o = l(a(4963)), s = l(a(8741));\n                function l(e) {\n                    return e && e.__esModule ? e : {\n                        default: e\n                    };\n                }\n                function u(e) {\n                    return e instanceof Element;\n                }\n                t.Event = i, \"function\" == typeof r.default.CustomEvent ? t.Event = i = r.default.CustomEvent : s.default && (t.Event = i = function(e, t) {\n                    t = t || {\n                        bubbles: !1,\n                        cancelable: !1,\n                        detail: void 0\n                    };\n                    var a = document.createEvent(\"CustomEvent\");\n                    return a.initCustomEvent(e, t.bubbles, t.cancelable, t.detail), a;\n                }, i.prototype = r.default.Event.prototype);\n            },\n            600: function(e, t) {\n                function a(e) {\n                    return (a = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e) {\n                        return typeof e;\n                    } : function(e) {\n                        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n                    })(e);\n                }\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = function e() {\n                    var t, i, n, r, o, s, l = arguments[0] || {}, u = 1, c = arguments.length, f = !1;\n                    \"boolean\" == typeof l && (f = l, l = arguments[u] || {}, u++);\n                    \"object\" !== a(l) && \"function\" != typeof l && (l = {});\n                    for (;u < c; u++) if (null != (t = arguments[u])) for (i in t) n = l[i], r = t[i], \n                    l !== r && (f && r && (\"[object Object]\" === Object.prototype.toString.call(r) || (o = Array.isArray(r))) ? (o ? (o = !1, \n                    s = n && Array.isArray(n) ? n : []) : s = n && \"[object Object]\" === Object.prototype.toString.call(n) ? n : {}, \n                    l[i] = e(f, s, r)) : void 0 !== r && (l[i] = r));\n                    return l;\n                };\n            },\n            4963: function(e, t, a) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = void 0;\n                var i = s(a(600)), n = s(a(9380)), r = s(a(253)), o = a(3776);\n                function s(e) {\n                    return e && e.__esModule ? e : {\n                        default: e\n                    };\n                }\n                var l = n.default.document;\n                function u(e) {\n                    return e instanceof u ? e : this instanceof u ? void (null != e && e !== n.default && (this[0] = e.nodeName ? e : void 0 !== e[0] && e[0].nodeName ? e[0] : l.querySelector(e), \n                    void 0 !== this[0] && null !== this[0] && (this[0].eventRegistry = this[0].eventRegistry || {}))) : new u(e);\n                }\n                u.prototype = {\n                    on: o.on,\n                    off: o.off,\n                    trigger: o.trigger\n                }, u.extend = i.default, u.data = r.default, u.Event = o.Event;\n                var c = u;\n                t.default = c;\n            },\n            9845: function(e, t, a) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.iphone = t.iemobile = t.mobile = t.ie = t.ua = void 0;\n                var i, n = (i = a(9380)) && i.__esModule ? i : {\n                    default: i\n                };\n                var r = n.default.navigator && n.default.navigator.userAgent || \"\", o = r.indexOf(\"MSIE \") > 0 || r.indexOf(\"Trident/\") > 0, s = \"ontouchstart\" in n.default, l = /iemobile/i.test(r), u = /iphone/i.test(r) && !l;\n                t.iphone = u, t.iemobile = l, t.mobile = s, t.ie = o, t.ua = r;\n            },\n            7184: function(e, t) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = function(e) {\n                    return e.replace(a, \"\\\\$1\");\n                };\n                var a = new RegExp(\"(\\\\\" + [ \"/\", \".\", \"*\", \"+\", \"?\", \"|\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", \"\\\\\", \"$\", \"^\" ].join(\"|\\\\\") + \")\", \"gim\");\n            },\n            6030: function(e, t, a) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.EventHandlers = void 0;\n                var i, n = a(8711), r = (i = a(4528)) && i.__esModule ? i : {\n                    default: i\n                }, o = a(9845), s = a(7215), l = a(7760), u = a(4713);\n                var c = {\n                    keydownEvent: function(e) {\n                        var t = this.inputmask, a = t.opts, i = t.dependencyLib, c = t.maskset, f = this, d = i(f), p = e.keyCode, h = n.caret.call(t, f), v = a.onKeyDown.call(this, e, n.getBuffer.call(t), h, a);\n                        if (void 0 !== v) return v;\n                        if (p === r.default.BACKSPACE || p === r.default.DELETE || o.iphone && p === r.default.BACKSPACE_SAFARI || e.ctrlKey && p === r.default.X && !(\"oncut\" in f)) e.preventDefault(), \n                        s.handleRemove.call(t, f, p, h), (0, l.writeBuffer)(f, n.getBuffer.call(t, !0), c.p, e, f.inputmask._valueGet() !== n.getBuffer.call(t).join(\"\")); else if (p === r.default.END || p === r.default.PAGE_DOWN) {\n                            e.preventDefault();\n                            var m = n.seekNext.call(t, n.getLastValidPosition.call(t));\n                            n.caret.call(t, f, e.shiftKey ? h.begin : m, m, !0);\n                        } else p === r.default.HOME && !e.shiftKey || p === r.default.PAGE_UP ? (e.preventDefault(), \n                        n.caret.call(t, f, 0, e.shiftKey ? h.begin : 0, !0)) : a.undoOnEscape && p === r.default.ESCAPE && !0 !== e.altKey ? ((0, \n                        l.checkVal)(f, !0, !1, t.undoValue.split(\"\")), d.trigger(\"click\")) : !0 === a.tabThrough && p === r.default.TAB ? !0 === e.shiftKey ? (h.end = n.seekPrevious.call(t, h.end, !0), \n                        !0 === u.getTest.call(t, h.end - 1).match.static && h.end--, h.begin = n.seekPrevious.call(t, h.end, !0), \n                        h.begin >= 0 && h.end > 0 && (e.preventDefault(), n.caret.call(t, f, h.begin, h.end))) : (h.begin = n.seekNext.call(t, h.begin, !0), \n                        h.end = n.seekNext.call(t, h.begin, !0), h.end < c.maskLength && h.end--, h.begin <= c.maskLength && (e.preventDefault(), \n                        n.caret.call(t, f, h.begin, h.end))) : e.shiftKey || a.insertModeVisual && !1 === a.insertMode && (p === r.default.RIGHT ? setTimeout((function() {\n                            var e = n.caret.call(t, f);\n                            n.caret.call(t, f, e.begin);\n                        }), 0) : p === r.default.LEFT && setTimeout((function() {\n                            var e = n.translatePosition.call(t, f.inputmask.caretPos.begin);\n                            n.translatePosition.call(t, f.inputmask.caretPos.end);\n                            t.isRTL ? n.caret.call(t, f, e + (e === c.maskLength ? 0 : 1)) : n.caret.call(t, f, e - (0 === e ? 0 : 1));\n                        }), 0));\n                        t.ignorable = a.ignorables.includes(p);\n                    },\n                    keypressEvent: function(e, t, a, i, o) {\n                        var u = this.inputmask || this, c = u.opts, f = u.dependencyLib, d = u.maskset, p = u.el, h = f(p), v = e.which || e.charCode || e.keyCode;\n                        if (!(!0 === t || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || u.ignorable)) return v === r.default.ENTER && u.undoValue !== u._valueGet(!0) && (u.undoValue = u._valueGet(!0), \n                        setTimeout((function() {\n                            h.trigger(\"change\");\n                        }), 0)), u.skipInputEvent = !0, !0;\n                        if (v) {\n                            44 !== v && 46 !== v || 3 !== e.location || \"\" === c.radixPoint || (v = c.radixPoint.charCodeAt(0));\n                            var m, g = t ? {\n                                begin: o,\n                                end: o\n                            } : n.caret.call(u, p), k = String.fromCharCode(v);\n                            d.writeOutBuffer = !0;\n                            var y = s.isValid.call(u, g, k, i, void 0, void 0, void 0, t);\n                            if (!1 !== y && (n.resetMaskSet.call(u, !0), m = void 0 !== y.caret ? y.caret : n.seekNext.call(u, y.pos.begin ? y.pos.begin : y.pos), \n                            d.p = m), m = c.numericInput && void 0 === y.caret ? n.seekPrevious.call(u, m) : m, \n                            !1 !== a && (setTimeout((function() {\n                                c.onKeyValidation.call(p, v, y);\n                            }), 0), d.writeOutBuffer && !1 !== y)) {\n                                var b = n.getBuffer.call(u);\n                                (0, l.writeBuffer)(p, b, m, e, !0 !== t);\n                            }\n                            if (e.preventDefault(), t) return !1 !== y && (y.forwardPosition = m), y;\n                        }\n                    },\n                    keyupEvent: function(e) {\n                        var t = this.inputmask;\n                        !t.isComposing || e.keyCode !== r.default.KEY_229 && e.keyCode !== r.default.ENTER || t.$el.trigger(\"input\");\n                    },\n                    pasteEvent: function(e) {\n                        var t, a = this.inputmask, i = a.opts, r = a._valueGet(!0), o = n.caret.call(a, this);\n                        a.isRTL && (t = o.end, o.end = o.begin, o.begin = t);\n                        var s = r.substr(0, o.begin), u = r.substr(o.end, r.length);\n                        if (s == (a.isRTL ? n.getBufferTemplate.call(a).slice().reverse() : n.getBufferTemplate.call(a)).slice(0, o.begin).join(\"\") && (s = \"\"), \n                        u == (a.isRTL ? n.getBufferTemplate.call(a).slice().reverse() : n.getBufferTemplate.call(a)).slice(o.end).join(\"\") && (u = \"\"), \n                        window.clipboardData && window.clipboardData.getData) r = s + window.clipboardData.getData(\"Text\") + u; else {\n                            if (!e.clipboardData || !e.clipboardData.getData) return !0;\n                            r = s + e.clipboardData.getData(\"text/plain\") + u;\n                        }\n                        var c = r;\n                        if (\"function\" == typeof i.onBeforePaste) {\n                            if (!1 === (c = i.onBeforePaste.call(a, r, i))) return e.preventDefault();\n                            c || (c = r);\n                        }\n                        return (0, l.checkVal)(this, !0, !1, c.toString().split(\"\"), e), e.preventDefault();\n                    },\n                    inputFallBackEvent: function(e) {\n                        var t = this.inputmask, a = t.opts, i = t.dependencyLib;\n                        var s = this, f = s.inputmask._valueGet(!0), d = (t.isRTL ? n.getBuffer.call(t).slice().reverse() : n.getBuffer.call(t)).join(\"\"), p = n.caret.call(t, s, void 0, void 0, !0);\n                        if (d !== f) {\n                            var h = function(e, i, r) {\n                                for (var o, s, l, c = e.substr(0, r.begin).split(\"\"), f = e.substr(r.begin).split(\"\"), d = i.substr(0, r.begin).split(\"\"), p = i.substr(r.begin).split(\"\"), h = c.length >= d.length ? c.length : d.length, v = f.length >= p.length ? f.length : p.length, m = \"\", g = [], k = \"~\"; c.length < h; ) c.push(k);\n                                for (;d.length < h; ) d.push(k);\n                                for (;f.length < v; ) f.unshift(k);\n                                for (;p.length < v; ) p.unshift(k);\n                                var y = c.concat(f), b = d.concat(p);\n                                for (s = 0, o = y.length; s < o; s++) switch (l = u.getPlaceholder.call(t, n.translatePosition.call(t, s)), \n                                m) {\n                                  case \"insertText\":\n                                    b[s - 1] === y[s] && r.begin == y.length - 1 && g.push(y[s]), s = o;\n                                    break;\n\n                                  case \"insertReplacementText\":\n                                  case \"deleteContentBackward\":\n                                    y[s] === k ? r.end++ : s = o;\n                                    break;\n\n                                  default:\n                                    y[s] !== b[s] && (y[s + 1] !== k && y[s + 1] !== l && void 0 !== y[s + 1] || (b[s] !== l || b[s + 1] !== k) && b[s] !== k ? b[s + 1] === k && b[s] === y[s + 1] ? (m = \"insertText\", \n                                    g.push(y[s]), r.begin--, r.end--) : y[s] !== l && y[s] !== k && (y[s + 1] === k || b[s] !== y[s] && b[s + 1] === y[s + 1]) ? (m = \"insertReplacementText\", \n                                    g.push(y[s]), r.begin--) : y[s] === k ? (m = \"deleteContentBackward\", (n.isMask.call(t, n.translatePosition.call(t, s), !0) || b[s] === a.radixPoint) && r.end++) : s = o : (m = \"insertText\", \n                                    g.push(y[s]), r.begin--, r.end--));\n                                }\n                                return {\n                                    action: m,\n                                    data: g,\n                                    caret: r\n                                };\n                            }(f = function(e, a, i) {\n                                if (o.iemobile) {\n                                    var r = a.replace(n.getBuffer.call(t).join(\"\"), \"\");\n                                    if (1 === r.length) {\n                                        var s = a.split(\"\");\n                                        s.splice(i.begin, 0, r), a = s.join(\"\");\n                                    }\n                                }\n                                return a;\n                            }(0, f, p), d, p);\n                            switch ((s.inputmask.shadowRoot || s.ownerDocument).activeElement !== s && s.focus(), \n                            (0, l.writeBuffer)(s, n.getBuffer.call(t)), n.caret.call(t, s, p.begin, p.end, !0), \n                            h.action) {\n                              case \"insertText\":\n                              case \"insertReplacementText\":\n                                h.data.forEach((function(e, a) {\n                                    var n = new i.Event(\"keypress\");\n                                    n.which = e.charCodeAt(0), t.ignorable = !1, c.keypressEvent.call(s, n);\n                                })), setTimeout((function() {\n                                    t.$el.trigger(\"keyup\");\n                                }), 0);\n                                break;\n\n                              case \"deleteContentBackward\":\n                                var v = new i.Event(\"keydown\");\n                                v.keyCode = r.default.BACKSPACE, c.keydownEvent.call(s, v);\n                                break;\n\n                              default:\n                                (0, l.applyInputValue)(s, f);\n                            }\n                            e.preventDefault();\n                        }\n                    },\n                    compositionendEvent: function(e) {\n                        var t = this.inputmask;\n                        t.isComposing = !1, t.$el.trigger(\"input\");\n                    },\n                    setValueEvent: function(e) {\n                        var t = this.inputmask, a = this, i = e && e.detail ? e.detail[0] : arguments[1];\n                        void 0 === i && (i = a.inputmask._valueGet(!0)), (0, l.applyInputValue)(a, i), (e.detail && void 0 !== e.detail[1] || void 0 !== arguments[2]) && n.caret.call(t, a, e.detail ? e.detail[1] : arguments[2]);\n                    },\n                    focusEvent: function(e) {\n                        var t = this.inputmask, a = t.opts, i = this, r = i.inputmask._valueGet();\n                        a.showMaskOnFocus && r !== n.getBuffer.call(t).join(\"\") && (0, l.writeBuffer)(i, n.getBuffer.call(t), n.seekNext.call(t, n.getLastValidPosition.call(t))), \n                        !0 !== a.positionCaretOnTab || !1 !== t.mouseEnter || s.isComplete.call(t, n.getBuffer.call(t)) && -1 !== n.getLastValidPosition.call(t) || c.clickEvent.apply(i, [ e, !0 ]), \n                        t.undoValue = t._valueGet(!0);\n                    },\n                    invalidEvent: function(e) {\n                        this.inputmask.validationEvent = !0;\n                    },\n                    mouseleaveEvent: function() {\n                        var e = this.inputmask, t = e.opts, a = this;\n                        e.mouseEnter = !1, t.clearMaskOnLostFocus && (a.inputmask.shadowRoot || a.ownerDocument).activeElement !== a && (0, \n                        l.HandleNativePlaceholder)(a, e.originalPlaceholder);\n                    },\n                    clickEvent: function(e, t) {\n                        var a = this.inputmask, i = this;\n                        if ((i.inputmask.shadowRoot || i.ownerDocument).activeElement === i) {\n                            var r = n.determineNewCaretPosition.call(a, n.caret.call(a, i), t);\n                            void 0 !== r && n.caret.call(a, i, r);\n                        }\n                    },\n                    cutEvent: function(e) {\n                        var t = this.inputmask, a = t.maskset, i = this, o = n.caret.call(t, i), u = window.clipboardData || e.clipboardData, c = t.isRTL ? n.getBuffer.call(t).slice(o.end, o.begin) : n.getBuffer.call(t).slice(o.begin, o.end);\n                        u.setData(\"text\", t.isRTL ? c.reverse().join(\"\") : c.join(\"\")), document.execCommand && document.execCommand(\"copy\"), \n                        s.handleRemove.call(t, i, r.default.DELETE, o), (0, l.writeBuffer)(i, n.getBuffer.call(t), a.p, e, t.undoValue !== t._valueGet(!0));\n                    },\n                    blurEvent: function(e) {\n                        var t = this.inputmask, a = t.opts, i = (0, t.dependencyLib)(this), r = this;\n                        if (r.inputmask) {\n                            (0, l.HandleNativePlaceholder)(r, t.originalPlaceholder);\n                            var o = r.inputmask._valueGet(), u = n.getBuffer.call(t).slice();\n                            \"\" !== o && (a.clearMaskOnLostFocus && (-1 === n.getLastValidPosition.call(t) && o === n.getBufferTemplate.call(t).join(\"\") ? u = [] : l.clearOptionalTail.call(t, u)), \n                            !1 === s.isComplete.call(t, u) && (setTimeout((function() {\n                                i.trigger(\"incomplete\");\n                            }), 0), a.clearIncomplete && (n.resetMaskSet.call(t), u = a.clearMaskOnLostFocus ? [] : n.getBufferTemplate.call(t).slice())), \n                            (0, l.writeBuffer)(r, u, void 0, e)), t.undoValue !== t._valueGet(!0) && (t.undoValue = t._valueGet(!0), \n                            i.trigger(\"change\"));\n                        }\n                    },\n                    mouseenterEvent: function() {\n                        var e = this.inputmask, t = e.opts, a = this;\n                        if (e.mouseEnter = !0, (a.inputmask.shadowRoot || a.ownerDocument).activeElement !== a) {\n                            var i = (e.isRTL ? n.getBufferTemplate.call(e).slice().reverse() : n.getBufferTemplate.call(e)).join(\"\");\n                            e.placeholder !== i && a.placeholder !== e.originalPlaceholder && (e.originalPlaceholder = a.placeholder), \n                            t.showMaskOnHover && (0, l.HandleNativePlaceholder)(a, i);\n                        }\n                    },\n                    submitEvent: function() {\n                        var e = this.inputmask, t = e.opts;\n                        e.undoValue !== e._valueGet(!0) && e.$el.trigger(\"change\"), t.clearMaskOnLostFocus && -1 === n.getLastValidPosition.call(e) && e._valueGet && e._valueGet() === n.getBufferTemplate.call(e).join(\"\") && e._valueSet(\"\"), \n                        t.clearIncomplete && !1 === s.isComplete.call(e, n.getBuffer.call(e)) && e._valueSet(\"\"), \n                        t.removeMaskOnSubmit && (e._valueSet(e.unmaskedvalue(), !0), setTimeout((function() {\n                            (0, l.writeBuffer)(e.el, n.getBuffer.call(e));\n                        }), 0));\n                    },\n                    resetEvent: function() {\n                        var e = this.inputmask;\n                        e.refreshValue = !0, setTimeout((function() {\n                            (0, l.applyInputValue)(e.el, e._valueGet(!0));\n                        }), 0);\n                    }\n                };\n                t.EventHandlers = c;\n            },\n            9716: function(e, t, a) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.EventRuler = void 0;\n                var i = s(a(2394)), n = s(a(4528)), r = a(8711), o = a(7760);\n                function s(e) {\n                    return e && e.__esModule ? e : {\n                        default: e\n                    };\n                }\n                var l = {\n                    on: function(e, t, a) {\n                        var s = e.inputmask.dependencyLib, l = function(t) {\n                            t.originalEvent && (t = t.originalEvent || t, arguments[0] = t);\n                            var l, u = this, c = u.inputmask, f = c ? c.opts : void 0;\n                            if (void 0 === c && \"FORM\" !== this.nodeName) {\n                                var d = s.data(u, \"_inputmask_opts\");\n                                s(u).off(), d && new i.default(d).mask(u);\n                            } else {\n                                if ([ \"submit\", \"reset\", \"setvalue\" ].includes(t.type) || \"FORM\" === this.nodeName || !(u.disabled || u.readOnly && !(\"keydown\" === t.type && t.ctrlKey && 67 === t.keyCode || !1 === f.tabThrough && t.keyCode === n.default.TAB))) {\n                                    switch (t.type) {\n                                      case \"input\":\n                                        if (!0 === c.skipInputEvent || t.inputType && \"insertCompositionText\" === t.inputType) return c.skipInputEvent = !1, \n                                        t.preventDefault();\n                                        break;\n\n                                      case \"keydown\":\n                                        c.skipKeyPressEvent = !1, c.skipInputEvent = c.isComposing = t.keyCode === n.default.KEY_229;\n                                        break;\n\n                                      case \"keyup\":\n                                      case \"compositionend\":\n                                        c.isComposing && (c.skipInputEvent = !1);\n                                        break;\n\n                                      case \"keypress\":\n                                        if (!0 === c.skipKeyPressEvent) return t.preventDefault();\n                                        c.skipKeyPressEvent = !0;\n                                        break;\n\n                                      case \"click\":\n                                      case \"focus\":\n                                        return c.validationEvent ? (c.validationEvent = !1, e.blur(), (0, o.HandleNativePlaceholder)(e, (c.isRTL ? r.getBufferTemplate.call(c).slice().reverse() : r.getBufferTemplate.call(c)).join(\"\")), \n                                        setTimeout((function() {\n                                            e.focus();\n                                        }), f.validationEventTimeOut), !1) : (l = arguments, setTimeout((function() {\n                                            e.inputmask && a.apply(u, l);\n                                        }), 0), !1);\n                                    }\n                                    var p = a.apply(u, arguments);\n                                    return !1 === p && (t.preventDefault(), t.stopPropagation()), p;\n                                }\n                                t.preventDefault();\n                            }\n                        };\n                        [ \"submit\", \"reset\" ].includes(t) ? (l = l.bind(e), null !== e.form && s(e.form).on(t, l)) : s(e).on(t, l), \n                        e.inputmask.events[t] = e.inputmask.events[t] || [], e.inputmask.events[t].push(l);\n                    },\n                    off: function(e, t) {\n                        if (e.inputmask && e.inputmask.events) {\n                            var a = e.inputmask.dependencyLib, i = e.inputmask.events;\n                            for (var n in t && ((i = [])[t] = e.inputmask.events[t]), i) {\n                                for (var r = i[n]; r.length > 0; ) {\n                                    var o = r.pop();\n                                    [ \"submit\", \"reset\" ].includes(n) ? null !== e.form && a(e.form).off(n, o) : a(e).off(n, o);\n                                }\n                                delete e.inputmask.events[n];\n                            }\n                        }\n                    }\n                };\n                t.EventRuler = l;\n            },\n            219: function(e, t, a) {\n                var i = l(a(2394)), n = l(a(4528)), r = l(a(7184)), o = a(8711);\n                function s(e) {\n                    return (s = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e) {\n                        return typeof e;\n                    } : function(e) {\n                        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n                    })(e);\n                }\n                function l(e) {\n                    return e && e.__esModule ? e : {\n                        default: e\n                    };\n                }\n                var u = i.default.dependencyLib, c = (new Date).getFullYear(), f = {\n                    d: [ \"[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", Date.prototype.getDate ],\n                    dd: [ \"0[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", function() {\n                        return y(Date.prototype.getDate.call(this), 2);\n                    } ],\n                    ddd: [ \"\" ],\n                    dddd: [ \"\" ],\n                    m: [ \"[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function() {\n                        return Date.prototype.getMonth.call(this) + 1;\n                    } ],\n                    mm: [ \"0[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function() {\n                        return y(Date.prototype.getMonth.call(this) + 1, 2);\n                    } ],\n                    mmm: [ \"\" ],\n                    mmmm: [ \"\" ],\n                    yy: [ \"[0-9]{2}\", Date.prototype.setFullYear, \"year\", function() {\n                        return y(Date.prototype.getFullYear.call(this), 2);\n                    } ],\n                    yyyy: [ \"[0-9]{4}\", Date.prototype.setFullYear, \"year\", function() {\n                        return y(Date.prototype.getFullYear.call(this), 4);\n                    } ],\n                    h: [ \"[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours ],\n                    hh: [ \"0[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", function() {\n                        return y(Date.prototype.getHours.call(this), 2);\n                    } ],\n                    hx: [ function(e) {\n                        return \"[0-9]{\".concat(e, \"}\");\n                    }, Date.prototype.setHours, \"hours\", function(e) {\n                        return Date.prototype.getHours;\n                    } ],\n                    H: [ \"1?[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours ],\n                    HH: [ \"0[0-9]|1[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", function() {\n                        return y(Date.prototype.getHours.call(this), 2);\n                    } ],\n                    Hx: [ function(e) {\n                        return \"[0-9]{\".concat(e, \"}\");\n                    }, Date.prototype.setHours, \"hours\", function(e) {\n                        return function() {\n                            return y(Date.prototype.getHours.call(this), e);\n                        };\n                    } ],\n                    M: [ \"[1-5]?[0-9]\", Date.prototype.setMinutes, \"minutes\", Date.prototype.getMinutes ],\n                    MM: [ \"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setMinutes, \"minutes\", function() {\n                        return y(Date.prototype.getMinutes.call(this), 2);\n                    } ],\n                    s: [ \"[1-5]?[0-9]\", Date.prototype.setSeconds, \"seconds\", Date.prototype.getSeconds ],\n                    ss: [ \"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setSeconds, \"seconds\", function() {\n                        return y(Date.prototype.getSeconds.call(this), 2);\n                    } ],\n                    l: [ \"[0-9]{3}\", Date.prototype.setMilliseconds, \"milliseconds\", function() {\n                        return y(Date.prototype.getMilliseconds.call(this), 3);\n                    } ],\n                    L: [ \"[0-9]{2}\", Date.prototype.setMilliseconds, \"milliseconds\", function() {\n                        return y(Date.prototype.getMilliseconds.call(this), 2);\n                    } ],\n                    t: [ \"[ap]\", p, \"ampm\", h, 1 ],\n                    tt: [ \"[ap]m\", p, \"ampm\", h, 2 ],\n                    T: [ \"[AP]\", p, \"ampm\", h, 1 ],\n                    TT: [ \"[AP]M\", p, \"ampm\", h, 2 ],\n                    Z: [ \"\" ],\n                    o: [ \"\" ],\n                    S: [ \"\" ]\n                }, d = {\n                    isoDate: \"yyyy-mm-dd\",\n                    isoTime: \"HH:MM:ss\",\n                    isoDateTime: \"yyyy-mm-dd'T'HH:MM:ss\",\n                    isoUtcDateTime: \"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'\"\n                };\n                function p(e) {\n                    e.toLowerCase().includes(\"p\") && this.setHours(this.getHours() + 12);\n                }\n                function h() {}\n                function v(e) {\n                    var t = new RegExp(\"\\\\d+$\").exec(e[0]);\n                    if (t && void 0 !== t[0]) {\n                        var a = f[e[0][0] + \"x\"].slice(\"\");\n                        return a[0] = a[0](t[0]), a[3] = a[3](t[0]), a;\n                    }\n                    if (f[e[0]]) return f[e[0]];\n                }\n                function m(e) {\n                    if (!e.tokenizer) {\n                        var t = [], a = [];\n                        for (var i in f) if (/\\.*x$/.test(i)) {\n                            var n = i[0] + \"\\\\d+\";\n                            -1 === a.indexOf(n) && a.push(n);\n                        } else -1 === t.indexOf(i[0]) && t.push(i[0]);\n                        e.tokenizer = \"(\" + (a.length > 0 ? a.join(\"|\") + \"|\" : \"\") + t.join(\"+|\") + \")+?|.\", \n                        e.tokenizer = new RegExp(e.tokenizer, \"g\");\n                    }\n                    return e.tokenizer;\n                }\n                function g(e, t, a) {\n                    if (void 0 === e.rawday || !isFinite(e.rawday) && new Date(e.date.getFullYear(), isFinite(e.rawmonth) ? e.month : e.date.getMonth() + 1, 0).getDate() >= e.day || \"29\" == e.day && !Number.isFinite(e.rawyear) || new Date(e.date.getFullYear(), isFinite(e.rawmonth) ? e.month : e.date.getMonth() + 1, 0).getDate() >= e.day) return t;\n                    if (\"29\" == e.day) {\n                        var i = P(t.pos, a);\n                        if (\"yyyy\" === i.targetMatch[0] && t.pos - i.targetMatchIndex == 2) return t.remove = t.pos + 1, \n                        t;\n                    } else if (\"02\" == e.month && \"30\" == e.day && void 0 !== t.c) return e.day = \"03\", \n                    e.date.setDate(3), e.date.setMonth(1), t.insert = [ {\n                        pos: t.pos,\n                        c: \"0\"\n                    }, {\n                        pos: t.pos + 1,\n                        c: t.c\n                    } ], t.caret = o.seekNext.call(this, t.pos + 1), t;\n                    return !1;\n                }\n                function k(e, t, a, i) {\n                    var n, o, s = \"\";\n                    for (m(a).lastIndex = 0; n = m(a).exec(e); ) {\n                        if (void 0 === t) if (o = v(n)) s += \"(\" + o[0] + \")\"; else switch (n[0]) {\n                          case \"[\":\n                            s += \"(\";\n                            break;\n\n                          case \"]\":\n                            s += \")?\";\n                            break;\n\n                          default:\n                            s += (0, r.default)(n[0]);\n                        } else if (o = v(n)) if (!0 !== i && o[3]) s += o[3].call(t.date); else o[2] ? s += t[\"raw\" + o[2]] : s += n[0]; else s += n[0];\n                    }\n                    return s;\n                }\n                function y(e, t, a) {\n                    for (e = String(e), t = t || 2; e.length < t; ) e = a ? e + \"0\" : \"0\" + e;\n                    return e;\n                }\n                function b(e, t, a) {\n                    var i, n, r, o = {\n                        date: new Date(1, 0, 1)\n                    }, l = e;\n                    function u(e, t, a) {\n                        if (e[i] = \"ampm\" === i ? t : t.replace(/[^0-9]/g, \"0\"), e[\"raw\" + i] = t, void 0 !== r) {\n                            var n = e[i];\n                            (\"day\" === i && 29 === parseInt(n) || \"month\" === i && 2 === parseInt(n)) && (29 !== parseInt(e.day) || 2 !== parseInt(e.month) || \"\" !== e.year && void 0 !== e.year || e.date.setFullYear(2012, 1, 29)), \n                            \"day\" === i && 0 === parseInt(n) && (n = 1), \"month\" === i && (n = parseInt(n)) > 0 && (n -= 1), \n                            \"year\" === i && n.length < 4 && (n = y(n, 4, !0)), \"\" === n || isNaN(n) || r.call(e.date, n), \n                            \"ampm\" === i && r.call(e.date, n);\n                        }\n                    }\n                    if (\"string\" == typeof l) {\n                        for (m(a).lastIndex = 0; n = m(a).exec(t); ) {\n                            var c = new RegExp(\"\\\\d+$\").exec(n[0]), d = c ? n[0][0] + \"x\" : n[0], p = void 0;\n                            if (c) {\n                                var h = m(a).lastIndex, v = P(n.index, a);\n                                m(a).lastIndex = h, p = l.slice(0, l.indexOf(v.nextMatch[0]));\n                            } else p = l.slice(0, d.length);\n                            Object.prototype.hasOwnProperty.call(f, d) && (i = f[d][2], r = f[d][1], u(o, p)), \n                            l = l.slice(p.length);\n                        }\n                        return o;\n                    }\n                    if (l && \"object\" === s(l) && Object.prototype.hasOwnProperty.call(l, \"date\")) return l;\n                }\n                function x(e, t) {\n                    return k(t.inputFormat, {\n                        date: e\n                    }, t);\n                }\n                function P(e, t) {\n                    var a, i, n = 0, r = 0;\n                    for (m(t).lastIndex = 0; i = m(t).exec(t.inputFormat); ) {\n                        var o = new RegExp(\"\\\\d+$\").exec(i[0]);\n                        if ((n += r = o ? parseInt(o[0]) : i[0].length) >= e) {\n                            a = i, i = m(t).exec(t.inputFormat);\n                            break;\n                        }\n                    }\n                    return {\n                        targetMatchIndex: n - r,\n                        nextMatch: i,\n                        targetMatch: a\n                    };\n                }\n                i.default.extendAliases({\n                    datetime: {\n                        mask: function(e) {\n                            return e.numericInput = !1, f.S = e.i18n.ordinalSuffix.join(\"|\"), e.inputFormat = d[e.inputFormat] || e.inputFormat, \n                            e.displayFormat = d[e.displayFormat] || e.displayFormat || e.inputFormat, e.outputFormat = d[e.outputFormat] || e.outputFormat || e.inputFormat, \n                            e.placeholder = \"\" !== e.placeholder ? e.placeholder : e.inputFormat.replace(/[[\\]]/, \"\"), \n                            e.regex = k(e.inputFormat, void 0, e), e.min = b(e.min, e.inputFormat, e), e.max = b(e.max, e.inputFormat, e), \n                            null;\n                        },\n                        placeholder: \"\",\n                        inputFormat: \"isoDateTime\",\n                        displayFormat: void 0,\n                        outputFormat: void 0,\n                        min: null,\n                        max: null,\n                        skipOptionalPartCharacter: \"\",\n                        i18n: {\n                            dayNames: [ \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\" ],\n                            monthNames: [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" ],\n                            ordinalSuffix: [ \"st\", \"nd\", \"rd\", \"th\" ]\n                        },\n                        preValidation: function(e, t, a, i, n, r, o, s) {\n                            if (s) return !0;\n                            if (isNaN(a) && e[t] !== a) {\n                                var l = P(t, n);\n                                if (l.nextMatch && l.nextMatch[0] === a && l.targetMatch[0].length > 1) {\n                                    var u = f[l.targetMatch[0]][0];\n                                    if (new RegExp(u).test(\"0\" + e[t - 1])) return e[t] = e[t - 1], e[t - 1] = \"0\", \n                                    {\n                                        fuzzy: !0,\n                                        buffer: e,\n                                        refreshFromBuffer: {\n                                            start: t - 1,\n                                            end: t + 1\n                                        },\n                                        pos: t + 1\n                                    };\n                                }\n                            }\n                            return !0;\n                        },\n                        postValidation: function(e, t, a, i, n, r, o, s) {\n                            var l, u;\n                            if (o) return !0;\n                            if (!1 === i && (((l = P(t + 1, n)).targetMatch && l.targetMatchIndex === t && l.targetMatch[0].length > 1 && void 0 !== f[l.targetMatch[0]] || (l = P(t + 2, n)).targetMatch && l.targetMatchIndex === t + 1 && l.targetMatch[0].length > 1 && void 0 !== f[l.targetMatch[0]]) && (u = f[l.targetMatch[0]][0]), \n                            void 0 !== u && (void 0 !== r.validPositions[t + 1] && new RegExp(u).test(a + \"0\") ? (e[t] = a, \n                            e[t + 1] = \"0\", i = {\n                                pos: t + 2,\n                                caret: t\n                            }) : new RegExp(u).test(\"0\" + a) && (e[t] = \"0\", e[t + 1] = a, i = {\n                                pos: t + 2\n                            })), !1 === i)) return i;\n                            if (i.fuzzy && (e = i.buffer, t = i.pos), (l = P(t, n)).targetMatch && l.targetMatch[0] && void 0 !== f[l.targetMatch[0]]) {\n                                u = f[l.targetMatch[0]][0];\n                                var d = e.slice(l.targetMatchIndex, l.targetMatchIndex + l.targetMatch[0].length);\n                                !1 === new RegExp(u).test(d.join(\"\")) && 2 === l.targetMatch[0].length && r.validPositions[l.targetMatchIndex] && r.validPositions[l.targetMatchIndex + 1] && (r.validPositions[l.targetMatchIndex + 1].input = \"0\");\n                            }\n                            var p = i, h = b(e.join(\"\"), n.inputFormat, n);\n                            return p && h.date.getTime() == h.date.getTime() && (n.prefillYear && (p = function(e, t, a) {\n                                if (e.year !== e.rawyear) {\n                                    var i = c.toString(), n = e.rawyear.replace(/[^0-9]/g, \"\"), r = i.slice(0, n.length), o = i.slice(n.length);\n                                    if (2 === n.length && n === r) {\n                                        var s = new Date(c, e.month - 1, e.day);\n                                        e.day == s.getDate() && (!a.max || a.max.date.getTime() >= s.getTime()) && (e.date.setFullYear(c), \n                                        e.year = i, t.insert = [ {\n                                            pos: t.pos + 1,\n                                            c: o[0]\n                                        }, {\n                                            pos: t.pos + 2,\n                                            c: o[1]\n                                        } ]);\n                                    }\n                                }\n                                return t;\n                            }(h, p, n)), p = function(e, t, a, i, n) {\n                                if (!t) return t;\n                                if (a.min) {\n                                    if (e.rawyear) {\n                                        var r, o = e.rawyear.replace(/[^0-9]/g, \"\"), s = a.min.year.substr(0, o.length);\n                                        if (o < s) {\n                                            var l = P(t.pos, a);\n                                            if (o = e.rawyear.substr(0, t.pos - l.targetMatchIndex + 1).replace(/[^0-9]/g, \"0\"), \n                                            (s = a.min.year.substr(0, o.length)) <= o) return t.remove = l.targetMatchIndex + o.length, \n                                            t;\n                                            if (o = \"yyyy\" === l.targetMatch[0] ? e.rawyear.substr(1, 1) : e.rawyear.substr(0, 1), \n                                            s = a.min.year.substr(2, 1), r = a.max ? a.max.year.substr(2, 1) : o, 1 === o.length && s <= o && o <= r && !0 !== n) return \"yyyy\" === l.targetMatch[0] ? (t.insert = [ {\n                                                pos: t.pos + 1,\n                                                c: o,\n                                                strict: !0\n                                            } ], t.caret = t.pos + 2, i.validPositions[t.pos].input = a.min.year[1]) : (t.insert = [ {\n                                                pos: t.pos + 1,\n                                                c: a.min.year[1],\n                                                strict: !0\n                                            }, {\n                                                pos: t.pos + 2,\n                                                c: o,\n                                                strict: !0\n                                            } ], t.caret = t.pos + 3, i.validPositions[t.pos].input = a.min.year[0]), t;\n                                            t = !1;\n                                        }\n                                    }\n                                    for (var u in e) -1 === u.indexOf(\"raw\") && e[\"raw\".concat(u)] && (e[u], e[\"raw\".concat(u)]);\n                                    t && e.year && e.year === e.rawyear && a.min.date.getTime() == a.min.date.getTime() && (t = a.min.date.getTime() <= e.date.getTime());\n                                }\n                                return t && a.max && a.max.date.getTime() == a.max.date.getTime() && (t = a.max.date.getTime() >= e.date.getTime()), \n                                t;\n                            }(h, p = g.call(this, h, p, n), n, r, s)), void 0 !== t && p && i.pos !== t ? {\n                                buffer: k(n.inputFormat, h, n).split(\"\"),\n                                refreshFromBuffer: {\n                                    start: t,\n                                    end: i.pos\n                                },\n                                pos: i.caret || i.pos\n                            } : p;\n                        },\n                        onKeyDown: function(e, t, a, i) {\n                            e.ctrlKey && e.keyCode === n.default.RIGHT && (this.inputmask._valueSet(x(new Date, i)), \n                            u(this).trigger(\"setvalue\"));\n                        },\n                        onUnMask: function(e, t, a) {\n                            return t ? k(a.outputFormat, b(e, a.inputFormat, a), a, !0) : t;\n                        },\n                        casing: function(e, t, a, i) {\n                            return 0 == t.nativeDef.indexOf(\"[ap]\") ? e.toLowerCase() : 0 == t.nativeDef.indexOf(\"[AP]\") ? e.toUpperCase() : e;\n                        },\n                        onBeforeMask: function(e, t) {\n                            return \"[object Date]\" === Object.prototype.toString.call(e) && (e = x(e, t)), e;\n                        },\n                        insertMode: !1,\n                        shiftPositions: !1,\n                        keepStatic: !1,\n                        inputmode: \"numeric\",\n                        prefillYear: !0\n                    }\n                });\n            },\n            3851: function(e, t, a) {\n                var i, n = (i = a(2394)) && i.__esModule ? i : {\n                    default: i\n                }, r = a(8711), o = a(4713);\n                n.default.extendDefinitions({\n                    A: {\n                        validator: \"[A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\",\n                        casing: \"upper\"\n                    },\n                    \"&\": {\n                        validator: \"[0-9A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\",\n                        casing: \"upper\"\n                    },\n                    \"#\": {\n                        validator: \"[0-9A-Fa-f]\",\n                        casing: \"upper\"\n                    }\n                });\n                var s = new RegExp(\"25[0-5]|2[0-4][0-9]|[01][0-9][0-9]\");\n                function l(e, t, a, i, n) {\n                    return a - 1 > -1 && \".\" !== t.buffer[a - 1] ? (e = t.buffer[a - 1] + e, e = a - 2 > -1 && \".\" !== t.buffer[a - 2] ? t.buffer[a - 2] + e : \"0\" + e) : e = \"00\" + e, \n                    s.test(e);\n                }\n                n.default.extendAliases({\n                    cssunit: {\n                        regex: \"[+-]?[0-9]+\\\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)\"\n                    },\n                    url: {\n                        regex: \"(https?|ftp)://.*\",\n                        autoUnmask: !1,\n                        keepStatic: !1,\n                        tabThrough: !0\n                    },\n                    ip: {\n                        mask: \"i[i[i]].j[j[j]].k[k[k]].l[l[l]]\",\n                        definitions: {\n                            i: {\n                                validator: l\n                            },\n                            j: {\n                                validator: l\n                            },\n                            k: {\n                                validator: l\n                            },\n                            l: {\n                                validator: l\n                            }\n                        },\n                        onUnMask: function(e, t, a) {\n                            return e;\n                        },\n                        inputmode: \"numeric\"\n                    },\n                    email: {\n                        mask: \"*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]\",\n                        greedy: !1,\n                        casing: \"lower\",\n                        onBeforePaste: function(e, t) {\n                            return (e = e.toLowerCase()).replace(\"mailto:\", \"\");\n                        },\n                        definitions: {\n                            \"*\": {\n                                validator: \"[0-9\\uff11-\\uff19A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5!#$%&'*+/=?^_`{|}~-]\"\n                            },\n                            \"-\": {\n                                validator: \"[0-9A-Za-z-]\"\n                            }\n                        },\n                        onUnMask: function(e, t, a) {\n                            return e;\n                        },\n                        inputmode: \"email\"\n                    },\n                    mac: {\n                        mask: \"##:##:##:##:##:##\"\n                    },\n                    vin: {\n                        mask: \"V{13}9{4}\",\n                        definitions: {\n                            V: {\n                                validator: \"[A-HJ-NPR-Za-hj-npr-z\\\\d]\",\n                                casing: \"upper\"\n                            }\n                        },\n                        clearIncomplete: !0,\n                        autoUnmask: !0\n                    },\n                    ssn: {\n                        mask: \"999-99-9999\",\n                        postValidation: function(e, t, a, i, n, s, l) {\n                            var u = o.getMaskTemplate.call(this, !0, r.getLastValidPosition.call(this), !0, !0);\n                            return /^(?!219-09-9999|078-05-1120)(?!666|000|9.{2}).{3}-(?!00).{2}-(?!0{4}).{4}$/.test(u.join(\"\"));\n                        }\n                    }\n                });\n            },\n            207: function(e, t, a) {\n                var i = s(a(2394)), n = s(a(4528)), r = s(a(7184)), o = a(8711);\n                function s(e) {\n                    return e && e.__esModule ? e : {\n                        default: e\n                    };\n                }\n                var l = i.default.dependencyLib;\n                function u(e, t) {\n                    for (var a = \"\", n = 0; n < e.length; n++) i.default.prototype.definitions[e.charAt(n)] || t.definitions[e.charAt(n)] || t.optionalmarker[0] === e.charAt(n) || t.optionalmarker[1] === e.charAt(n) || t.quantifiermarker[0] === e.charAt(n) || t.quantifiermarker[1] === e.charAt(n) || t.groupmarker[0] === e.charAt(n) || t.groupmarker[1] === e.charAt(n) || t.alternatormarker === e.charAt(n) ? a += \"\\\\\" + e.charAt(n) : a += e.charAt(n);\n                    return a;\n                }\n                function c(e, t, a, i) {\n                    if (e.length > 0 && t > 0 && (!a.digitsOptional || i)) {\n                        var n = e.indexOf(a.radixPoint), r = !1;\n                        a.negationSymbol.back === e[e.length - 1] && (r = !0, e.length--), -1 === n && (e.push(a.radixPoint), \n                        n = e.length - 1);\n                        for (var o = 1; o <= t; o++) isFinite(e[n + o]) || (e[n + o] = \"0\");\n                    }\n                    return r && e.push(a.negationSymbol.back), e;\n                }\n                function f(e, t) {\n                    var a = 0;\n                    if (\"+\" === e) {\n                        for (a in t.validPositions) ;\n                        a = o.seekNext.call(this, parseInt(a));\n                    }\n                    for (var i in t.tests) if ((i = parseInt(i)) >= a) for (var n = 0, r = t.tests[i].length; n < r; n++) if ((void 0 === t.validPositions[i] || \"-\" === e) && t.tests[i][n].match.def === e) return i + (void 0 !== t.validPositions[i] && \"-\" !== e ? 1 : 0);\n                    return a;\n                }\n                function d(e, t) {\n                    var a = -1;\n                    for (var i in t.validPositions) {\n                        var n = t.validPositions[i];\n                        if (n && n.match.def === e) {\n                            a = parseInt(i);\n                            break;\n                        }\n                    }\n                    return a;\n                }\n                function p(e, t, a, i, n) {\n                    var r = t.buffer ? t.buffer.indexOf(n.radixPoint) : -1, o = (-1 !== r || i && n.jitMasking) && new RegExp(n.definitions[9].validator).test(e);\n                    return n._radixDance && -1 !== r && o && null == t.validPositions[r] ? {\n                        insert: {\n                            pos: r === a ? r + 1 : r,\n                            c: n.radixPoint\n                        },\n                        pos: a\n                    } : o;\n                }\n                i.default.extendAliases({\n                    numeric: {\n                        mask: function(e) {\n                            e.repeat = 0, e.groupSeparator === e.radixPoint && e.digits && \"0\" !== e.digits && (\".\" === e.radixPoint ? e.groupSeparator = \",\" : \",\" === e.radixPoint ? e.groupSeparator = \".\" : e.groupSeparator = \"\"), \n                            \" \" === e.groupSeparator && (e.skipOptionalPartCharacter = void 0), e.placeholder.length > 1 && (e.placeholder = e.placeholder.charAt(0)), \n                            \"radixFocus\" === e.positionCaretOnClick && \"\" === e.placeholder && (e.positionCaretOnClick = \"lvp\");\n                            var t = \"0\", a = e.radixPoint;\n                            !0 === e.numericInput && void 0 === e.__financeInput ? (t = \"1\", e.positionCaretOnClick = \"radixFocus\" === e.positionCaretOnClick ? \"lvp\" : e.positionCaretOnClick, \n                            e.digitsOptional = !1, isNaN(e.digits) && (e.digits = 2), e._radixDance = !1, a = \",\" === e.radixPoint ? \"?\" : \"!\", \n                            \"\" !== e.radixPoint && void 0 === e.definitions[a] && (e.definitions[a] = {}, e.definitions[a].validator = \"[\" + e.radixPoint + \"]\", \n                            e.definitions[a].placeholder = e.radixPoint, e.definitions[a].static = !0, e.definitions[a].generated = !0)) : (e.__financeInput = !1, \n                            e.numericInput = !0);\n                            var i, n = \"[+]\";\n                            if (n += u(e.prefix, e), \"\" !== e.groupSeparator ? (void 0 === e.definitions[e.groupSeparator] && (e.definitions[e.groupSeparator] = {}, \n                            e.definitions[e.groupSeparator].validator = \"[\" + e.groupSeparator + \"]\", e.definitions[e.groupSeparator].placeholder = e.groupSeparator, \n                            e.definitions[e.groupSeparator].static = !0, e.definitions[e.groupSeparator].generated = !0), \n                            n += e._mask(e)) : n += \"9{+}\", void 0 !== e.digits && 0 !== e.digits) {\n                                var o = e.digits.toString().split(\",\");\n                                isFinite(o[0]) && o[1] && isFinite(o[1]) ? n += a + t + \"{\" + e.digits + \"}\" : (isNaN(e.digits) || parseInt(e.digits) > 0) && (e.digitsOptional || e.jitMasking ? (i = n + a + t + \"{0,\" + e.digits + \"}\", \n                                e.keepStatic = !0) : n += a + t + \"{\" + e.digits + \"}\");\n                            } else e.inputmode = \"numeric\";\n                            return n += u(e.suffix, e), n += \"[-]\", i && (n = [ i + u(e.suffix, e) + \"[-]\", n ]), \n                            e.greedy = !1, function(e) {\n                                void 0 === e.parseMinMaxOptions && (null !== e.min && (e.min = e.min.toString().replace(new RegExp((0, \n                                r.default)(e.groupSeparator), \"g\"), \"\"), \",\" === e.radixPoint && (e.min = e.min.replace(e.radixPoint, \".\")), \n                                e.min = isFinite(e.min) ? parseFloat(e.min) : NaN, isNaN(e.min) && (e.min = Number.MIN_VALUE)), \n                                null !== e.max && (e.max = e.max.toString().replace(new RegExp((0, r.default)(e.groupSeparator), \"g\"), \"\"), \n                                \",\" === e.radixPoint && (e.max = e.max.replace(e.radixPoint, \".\")), e.max = isFinite(e.max) ? parseFloat(e.max) : NaN, \n                                isNaN(e.max) && (e.max = Number.MAX_VALUE)), e.parseMinMaxOptions = \"done\");\n                            }(e), n;\n                        },\n                        _mask: function(e) {\n                            return \"(\" + e.groupSeparator + \"999){+|1}\";\n                        },\n                        digits: \"*\",\n                        digitsOptional: !0,\n                        enforceDigitsOnBlur: !1,\n                        radixPoint: \".\",\n                        positionCaretOnClick: \"radixFocus\",\n                        _radixDance: !0,\n                        groupSeparator: \"\",\n                        allowMinus: !0,\n                        negationSymbol: {\n                            front: \"-\",\n                            back: \"\"\n                        },\n                        prefix: \"\",\n                        suffix: \"\",\n                        min: null,\n                        max: null,\n                        SetMaxOnOverflow: !1,\n                        step: 1,\n                        inputType: \"text\",\n                        unmaskAsNumber: !1,\n                        roundingFN: Math.round,\n                        inputmode: \"decimal\",\n                        shortcuts: {\n                            k: \"000\",\n                            m: \"000000\"\n                        },\n                        placeholder: \"0\",\n                        greedy: !1,\n                        rightAlign: !0,\n                        insertMode: !0,\n                        autoUnmask: !1,\n                        skipOptionalPartCharacter: \"\",\n                        usePrototypeDefinitions: !1,\n                        definitions: {\n                            0: {\n                                validator: p\n                            },\n                            1: {\n                                validator: p,\n                                definitionSymbol: \"9\"\n                            },\n                            9: {\n                                validator: \"[0-9\\uff10-\\uff19\\u0660-\\u0669\\u06f0-\\u06f9]\",\n                                definitionSymbol: \"*\"\n                            },\n                            \"+\": {\n                                validator: function(e, t, a, i, n) {\n                                    return n.allowMinus && (\"-\" === e || e === n.negationSymbol.front);\n                                }\n                            },\n                            \"-\": {\n                                validator: function(e, t, a, i, n) {\n                                    return n.allowMinus && e === n.negationSymbol.back;\n                                }\n                            }\n                        },\n                        preValidation: function(e, t, a, i, n, r, o, s) {\n                            var l;\n                            if (!1 !== n.__financeInput && a === n.radixPoint) return !1;\n                            if (l = n.shortcuts && n.shortcuts[a]) {\n                                if (l.length > 1) for (var u = [], c = 0; c < l.length; c++) u.push({\n                                    pos: t + c,\n                                    c: l[c],\n                                    strict: !1\n                                });\n                                return {\n                                    insert: u\n                                };\n                            }\n                            var p = e.indexOf(n.radixPoint), h = t;\n                            if (t = function(e, t, a, i, n) {\n                                return n._radixDance && n.numericInput && t !== n.negationSymbol.back && e <= a && (a > 0 || t == n.radixPoint) && (void 0 === i.validPositions[e - 1] || i.validPositions[e - 1].input !== n.negationSymbol.back) && (e -= 1), \n                                e;\n                            }(t, a, p, r, n), \"-\" === a || a === n.negationSymbol.front) {\n                                if (!0 !== n.allowMinus) return !1;\n                                var v = !1, m = d(\"+\", r), g = d(\"-\", r);\n                                return -1 !== m && (v = [ m, g ]), !1 !== v ? {\n                                    remove: v,\n                                    caret: h - n.negationSymbol.back.length\n                                } : {\n                                    insert: [ {\n                                        pos: f.call(this, \"+\", r),\n                                        c: n.negationSymbol.front,\n                                        fromIsValid: !0\n                                    }, {\n                                        pos: f.call(this, \"-\", r),\n                                        c: n.negationSymbol.back,\n                                        fromIsValid: void 0\n                                    } ],\n                                    caret: h + n.negationSymbol.back.length\n                                };\n                            }\n                            if (a === n.groupSeparator) return {\n                                caret: h\n                            };\n                            if (s) return !0;\n                            if (-1 !== p && !0 === n._radixDance && !1 === i && a === n.radixPoint && void 0 !== n.digits && (isNaN(n.digits) || parseInt(n.digits) > 0) && p !== t) return {\n                                caret: n._radixDance && t === p - 1 ? p + 1 : p\n                            };\n                            if (!1 === n.__financeInput) if (i) {\n                                if (n.digitsOptional) return {\n                                    rewritePosition: o.end\n                                };\n                                if (!n.digitsOptional) {\n                                    if (o.begin > p && o.end <= p) return a === n.radixPoint ? {\n                                        insert: {\n                                            pos: p + 1,\n                                            c: \"0\",\n                                            fromIsValid: !0\n                                        },\n                                        rewritePosition: p\n                                    } : {\n                                        rewritePosition: p + 1\n                                    };\n                                    if (o.begin < p) return {\n                                        rewritePosition: o.begin - 1\n                                    };\n                                }\n                            } else if (!n.showMaskOnHover && !n.showMaskOnFocus && !n.digitsOptional && n.digits > 0 && \"\" === this.__valueGet.call(this.el)) return {\n                                rewritePosition: p\n                            };\n                            return {\n                                rewritePosition: t\n                            };\n                        },\n                        postValidation: function(e, t, a, i, n, r, o) {\n                            if (!1 === i) return i;\n                            if (o) return !0;\n                            if (null !== n.min || null !== n.max) {\n                                var s = n.onUnMask(e.slice().reverse().join(\"\"), void 0, l.extend({}, n, {\n                                    unmaskAsNumber: !0\n                                }));\n                                if (null !== n.min && s < n.min && (s.toString().length > n.min.toString().length || s < 0)) return !1;\n                                if (null !== n.max && s > n.max) return !!n.SetMaxOnOverflow && {\n                                    refreshFromBuffer: !0,\n                                    buffer: c(n.max.toString().replace(\".\", n.radixPoint).split(\"\"), n.digits, n).reverse()\n                                };\n                            }\n                            return i;\n                        },\n                        onUnMask: function(e, t, a) {\n                            if (\"\" === t && !0 === a.nullable) return t;\n                            var i = e.replace(a.prefix, \"\");\n                            return i = (i = i.replace(a.suffix, \"\")).replace(new RegExp((0, r.default)(a.groupSeparator), \"g\"), \"\"), \n                            \"\" !== a.placeholder.charAt(0) && (i = i.replace(new RegExp(a.placeholder.charAt(0), \"g\"), \"0\")), \n                            a.unmaskAsNumber ? (\"\" !== a.radixPoint && -1 !== i.indexOf(a.radixPoint) && (i = i.replace(r.default.call(this, a.radixPoint), \".\")), \n                            i = (i = i.replace(new RegExp(\"^\" + (0, r.default)(a.negationSymbol.front)), \"-\")).replace(new RegExp((0, \n                            r.default)(a.negationSymbol.back) + \"$\"), \"\"), Number(i)) : i;\n                        },\n                        isComplete: function(e, t) {\n                            var a = (t.numericInput ? e.slice().reverse() : e).join(\"\");\n                            return a = (a = (a = (a = (a = a.replace(new RegExp(\"^\" + (0, r.default)(t.negationSymbol.front)), \"-\")).replace(new RegExp((0, \n                            r.default)(t.negationSymbol.back) + \"$\"), \"\")).replace(t.prefix, \"\")).replace(t.suffix, \"\")).replace(new RegExp((0, \n                            r.default)(t.groupSeparator) + \"([0-9]{3})\", \"g\"), \"$1\"), \",\" === t.radixPoint && (a = a.replace((0, \n                            r.default)(t.radixPoint), \".\")), isFinite(a);\n                        },\n                        onBeforeMask: function(e, t) {\n                            var a = t.radixPoint || \",\";\n                            isFinite(t.digits) && (t.digits = parseInt(t.digits)), \"number\" != typeof e && \"number\" !== t.inputType || \"\" === a || (e = e.toString().replace(\".\", a));\n                            var i = \"-\" === e.charAt(0) || e.charAt(0) === t.negationSymbol.front, n = e.split(a), o = n[0].replace(/[^\\-0-9]/g, \"\"), s = n.length > 1 ? n[1].replace(/[^0-9]/g, \"\") : \"\", l = n.length > 1;\n                            e = o + (\"\" !== s ? a + s : s);\n                            var u = 0;\n                            if (\"\" !== a && (u = t.digitsOptional ? t.digits < s.length ? t.digits : s.length : t.digits, \n                            \"\" !== s || !t.digitsOptional)) {\n                                var f = Math.pow(10, u || 1);\n                                e = e.replace((0, r.default)(a), \".\"), isNaN(parseFloat(e)) || (e = (t.roundingFN(parseFloat(e) * f) / f).toFixed(u)), \n                                e = e.toString().replace(\".\", a);\n                            }\n                            if (0 === t.digits && -1 !== e.indexOf(a) && (e = e.substring(0, e.indexOf(a))), \n                            null !== t.min || null !== t.max) {\n                                var d = e.toString().replace(a, \".\");\n                                null !== t.min && d < t.min ? e = t.min.toString().replace(\".\", a) : null !== t.max && d > t.max && (e = t.max.toString().replace(\".\", a));\n                            }\n                            return i && \"-\" !== e.charAt(0) && (e = \"-\" + e), c(e.toString().split(\"\"), u, t, l).join(\"\");\n                        },\n                        onBeforeWrite: function(e, t, a, i) {\n                            function n(e, t) {\n                                if (!1 !== i.__financeInput || t) {\n                                    var a = e.indexOf(i.radixPoint);\n                                    -1 !== a && e.splice(a, 1);\n                                }\n                                if (\"\" !== i.groupSeparator) for (;-1 !== (a = e.indexOf(i.groupSeparator)); ) e.splice(a, 1);\n                                return e;\n                            }\n                            var o, s = function(e, t) {\n                                var a = new RegExp(\"(^\" + (\"\" !== t.negationSymbol.front ? (0, r.default)(t.negationSymbol.front) + \"?\" : \"\") + (0, \n                                r.default)(t.prefix) + \")(.*)(\" + (0, r.default)(t.suffix) + (\"\" != t.negationSymbol.back ? (0, \n                                r.default)(t.negationSymbol.back) + \"?\" : \"\") + \"$)\").exec(e.slice().reverse().join(\"\")), i = a ? a[2] : \"\", n = !1;\n                                return i && (i = i.split(t.radixPoint.charAt(0))[0], n = new RegExp(\"^[0\" + t.groupSeparator + \"]*\").exec(i)), \n                                !(!n || !(n[0].length > 1 || n[0].length > 0 && n[0].length < i.length)) && n;\n                            }(t, i);\n                            if (s) for (var u = t.join(\"\").lastIndexOf(s[0].split(\"\").reverse().join(\"\")) - (s[0] == s.input ? 0 : 1), f = s[0] == s.input ? 1 : 0, d = s[0].length - f; d > 0; d--) delete this.maskset.validPositions[u + d], \n                            delete t[u + d];\n                            if (e) switch (e.type) {\n                              case \"blur\":\n                              case \"checkval\":\n                                if (null !== i.min) {\n                                    var p = i.onUnMask(t.slice().reverse().join(\"\"), void 0, l.extend({}, i, {\n                                        unmaskAsNumber: !0\n                                    }));\n                                    if (null !== i.min && p < i.min) return {\n                                        refreshFromBuffer: !0,\n                                        buffer: c(i.min.toString().replace(\".\", i.radixPoint).split(\"\"), i.digits, i).reverse()\n                                    };\n                                }\n                                if (t[t.length - 1] === i.negationSymbol.front) {\n                                    var h = new RegExp(\"(^\" + (\"\" != i.negationSymbol.front ? (0, r.default)(i.negationSymbol.front) + \"?\" : \"\") + (0, \n                                    r.default)(i.prefix) + \")(.*)(\" + (0, r.default)(i.suffix) + (\"\" != i.negationSymbol.back ? (0, \n                                    r.default)(i.negationSymbol.back) + \"?\" : \"\") + \"$)\").exec(n(t.slice(), !0).reverse().join(\"\"));\n                                    0 == (h ? h[2] : \"\") && (o = {\n                                        refreshFromBuffer: !0,\n                                        buffer: [ 0 ]\n                                    });\n                                } else \"\" !== i.radixPoint && t[0] === i.radixPoint && (o && o.buffer ? o.buffer.shift() : (t.shift(), \n                                o = {\n                                    refreshFromBuffer: !0,\n                                    buffer: n(t)\n                                }));\n                                if (i.enforceDigitsOnBlur) {\n                                    var v = (o = o || {}) && o.buffer || t.slice().reverse();\n                                    o.refreshFromBuffer = !0, o.buffer = c(v, i.digits, i, !0).reverse();\n                                }\n                            }\n                            return o;\n                        },\n                        onKeyDown: function(e, t, a, i) {\n                            var r, o = l(this);\n                            if (e.ctrlKey) switch (e.keyCode) {\n                              case n.default.UP:\n                                return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(i.step)), \n                                o.trigger(\"setvalue\"), !1;\n\n                              case n.default.DOWN:\n                                return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(i.step)), \n                                o.trigger(\"setvalue\"), !1;\n                            }\n                            if (!e.shiftKey && (e.keyCode === n.default.DELETE || e.keyCode === n.default.BACKSPACE || e.keyCode === n.default.BACKSPACE_SAFARI) && a.begin !== t.length) {\n                                if (t[e.keyCode === n.default.DELETE ? a.begin - 1 : a.end] === i.negationSymbol.front) return r = t.slice().reverse(), \n                                \"\" !== i.negationSymbol.front && r.shift(), \"\" !== i.negationSymbol.back && r.pop(), \n                                o.trigger(\"setvalue\", [ r.join(\"\"), a.begin ]), !1;\n                                if (!0 === i._radixDance) {\n                                    var s = t.indexOf(i.radixPoint);\n                                    if (i.digitsOptional) {\n                                        if (0 === s) return (r = t.slice().reverse()).pop(), o.trigger(\"setvalue\", [ r.join(\"\"), a.begin >= r.length ? r.length : a.begin ]), \n                                        !1;\n                                    } else if (-1 !== s && (a.begin < s || a.end < s || e.keyCode === n.default.DELETE && a.begin === s)) return a.begin !== a.end || e.keyCode !== n.default.BACKSPACE && e.keyCode !== n.default.BACKSPACE_SAFARI || a.begin++, \n                                    (r = t.slice().reverse()).splice(r.length - a.begin, a.begin - a.end + 1), r = c(r, i.digits, i).join(\"\"), \n                                    o.trigger(\"setvalue\", [ r, a.begin >= r.length ? s + 1 : a.begin ]), !1;\n                                }\n                            }\n                        }\n                    },\n                    currency: {\n                        prefix: \"\",\n                        groupSeparator: \",\",\n                        alias: \"numeric\",\n                        digits: 2,\n                        digitsOptional: !1\n                    },\n                    decimal: {\n                        alias: \"numeric\"\n                    },\n                    integer: {\n                        alias: \"numeric\",\n                        inputmode: \"numeric\",\n                        digits: 0\n                    },\n                    percentage: {\n                        alias: \"numeric\",\n                        min: 0,\n                        max: 100,\n                        suffix: \" %\",\n                        digits: 0,\n                        allowMinus: !1\n                    },\n                    indianns: {\n                        alias: \"numeric\",\n                        _mask: function(e) {\n                            return \"(\" + e.groupSeparator + \"99){*|1}(\" + e.groupSeparator + \"999){1|1}\";\n                        },\n                        groupSeparator: \",\",\n                        radixPoint: \".\",\n                        placeholder: \"0\",\n                        digits: 2,\n                        digitsOptional: !1\n                    }\n                });\n            },\n            9380: function(e, t, a) {\n                var i;\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = void 0;\n                var n = ((i = a(8741)) && i.__esModule ? i : {\n                    default: i\n                }).default ? window : {};\n                t.default = n;\n            },\n            7760: function(e, t, a) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.applyInputValue = c, t.clearOptionalTail = f, t.checkVal = d, t.HandleNativePlaceholder = function(e, t) {\n                    var a = e ? e.inputmask : this;\n                    if (l.ie) {\n                        if (e.inputmask._valueGet() !== t && (e.placeholder !== t || \"\" === e.placeholder)) {\n                            var i = o.getBuffer.call(a).slice(), n = e.inputmask._valueGet();\n                            if (n !== t) {\n                                var r = o.getLastValidPosition.call(a);\n                                -1 === r && n === o.getBufferTemplate.call(a).join(\"\") ? i = [] : -1 !== r && f.call(a, i), \n                                p(e, i);\n                            }\n                        }\n                    } else e.placeholder !== t && (e.placeholder = t, \"\" === e.placeholder && e.removeAttribute(\"placeholder\"));\n                }, t.unmaskedvalue = function(e) {\n                    var t = e ? e.inputmask : this, a = t.opts, i = t.maskset;\n                    if (e) {\n                        if (void 0 === e.inputmask) return e.value;\n                        e.inputmask && e.inputmask.refreshValue && c(e, e.inputmask._valueGet(!0));\n                    }\n                    var n = [], r = i.validPositions;\n                    for (var s in r) r[s] && r[s].match && (1 != r[s].match.static || Array.isArray(i.metadata) && !0 !== r[s].generatedInput) && n.push(r[s].input);\n                    var l = 0 === n.length ? \"\" : (t.isRTL ? n.reverse() : n).join(\"\");\n                    if (\"function\" == typeof a.onUnMask) {\n                        var u = (t.isRTL ? o.getBuffer.call(t).slice().reverse() : o.getBuffer.call(t)).join(\"\");\n                        l = a.onUnMask.call(t, u, l, a);\n                    }\n                    return l;\n                }, t.writeBuffer = p;\n                var i, n = (i = a(4528)) && i.__esModule ? i : {\n                    default: i\n                }, r = a(4713), o = a(8711), s = a(7215), l = a(9845), u = a(6030);\n                function c(e, t) {\n                    var a = e ? e.inputmask : this, i = a.opts;\n                    e.inputmask.refreshValue = !1, \"function\" == typeof i.onBeforeMask && (t = i.onBeforeMask.call(a, t, i) || t), \n                    d(e, !0, !1, t = t.toString().split(\"\")), a.undoValue = a._valueGet(!0), (i.clearMaskOnLostFocus || i.clearIncomplete) && e.inputmask._valueGet() === o.getBufferTemplate.call(a).join(\"\") && -1 === o.getLastValidPosition.call(a) && e.inputmask._valueSet(\"\");\n                }\n                function f(e) {\n                    e.length = 0;\n                    for (var t, a = r.getMaskTemplate.call(this, !0, 0, !0, void 0, !0); void 0 !== (t = a.shift()); ) e.push(t);\n                    return e;\n                }\n                function d(e, t, a, i, n) {\n                    var l = e ? e.inputmask : this, c = l.maskset, f = l.opts, d = l.dependencyLib, h = i.slice(), v = \"\", m = -1, g = void 0, k = f.skipOptionalPartCharacter;\n                    f.skipOptionalPartCharacter = \"\", o.resetMaskSet.call(l), c.tests = {}, m = f.radixPoint ? o.determineNewCaretPosition.call(l, {\n                        begin: 0,\n                        end: 0\n                    }, !1, !1 === f.__financeInput ? \"radixFocus\" : void 0).begin : 0, c.p = m, l.caretPos = {\n                        begin: m\n                    };\n                    var y = [], b = l.caretPos;\n                    if (h.forEach((function(e, t) {\n                        if (void 0 !== e) {\n                            var i = new d.Event(\"_checkval\");\n                            i.which = e.toString().charCodeAt(0), v += e;\n                            var n = o.getLastValidPosition.call(l, void 0, !0);\n                            !function(e, t) {\n                                for (var a = r.getMaskTemplate.call(l, !0, 0).slice(e, o.seekNext.call(l, e, !1, !1)).join(\"\").replace(/'/g, \"\"), i = a.indexOf(t); i > 0 && \" \" === a[i - 1]; ) i--;\n                                var n = 0 === i && !o.isMask.call(l, e) && (r.getTest.call(l, e).match.nativeDef === t.charAt(0) || !0 === r.getTest.call(l, e).match.static && r.getTest.call(l, e).match.nativeDef === \"'\" + t.charAt(0) || \" \" === r.getTest.call(l, e).match.nativeDef && (r.getTest.call(l, e + 1).match.nativeDef === t.charAt(0) || !0 === r.getTest.call(l, e + 1).match.static && r.getTest.call(l, e + 1).match.nativeDef === \"'\" + t.charAt(0)));\n                                if (!n && i > 0 && !o.isMask.call(l, e, !1, !0)) {\n                                    var s = o.seekNext.call(l, e);\n                                    l.caretPos.begin < s && (l.caretPos = {\n                                        begin: s\n                                    });\n                                }\n                                return n;\n                            }(m, v) ? (g = u.EventHandlers.keypressEvent.call(l, i, !0, !1, a, l.caretPos.begin)) && (m = l.caretPos.begin + 1, \n                            v = \"\") : g = u.EventHandlers.keypressEvent.call(l, i, !0, !1, a, n + 1), g ? (void 0 !== g.pos && c.validPositions[g.pos] && !0 === c.validPositions[g.pos].match.static && void 0 === c.validPositions[g.pos].alternation && (y.push(g.pos), \n                            l.isRTL || (g.forwardPosition = g.pos + 1)), p.call(l, void 0, o.getBuffer.call(l), g.forwardPosition, i, !1), \n                            l.caretPos = {\n                                begin: g.forwardPosition,\n                                end: g.forwardPosition\n                            }, b = l.caretPos) : void 0 === c.validPositions[t] && h[t] === r.getPlaceholder.call(l, t) && o.isMask.call(l, t, !0) ? l.caretPos.begin++ : l.caretPos = b;\n                        }\n                    })), y.length > 0) {\n                        var x, P, E = o.seekNext.call(l, -1, void 0, !1);\n                        if (!s.isComplete.call(l, o.getBuffer.call(l)) && y.length <= E || s.isComplete.call(l, o.getBuffer.call(l)) && y.length > 0 && y.length !== E && 0 === y[0]) for (var S = E; void 0 !== (x = y.shift()); ) {\n                            var _ = new d.Event(\"_checkval\");\n                            if ((P = c.validPositions[x]).generatedInput = !0, _.which = P.input.charCodeAt(0), \n                            (g = u.EventHandlers.keypressEvent.call(l, _, !0, !1, a, S)) && void 0 !== g.pos && g.pos !== x && c.validPositions[g.pos] && !0 === c.validPositions[g.pos].match.static) y.push(g.pos); else if (!g) break;\n                            S++;\n                        }\n                    }\n                    t && p.call(l, e, o.getBuffer.call(l), g ? g.forwardPosition : l.caretPos.begin, n || new d.Event(\"checkval\"), n && \"input\" === n.type && l.undoValue !== l._valueGet(!0)), \n                    f.skipOptionalPartCharacter = k;\n                }\n                function p(e, t, a, i, r) {\n                    var l = e ? e.inputmask : this, u = l.opts, c = l.dependencyLib;\n                    if (i && \"function\" == typeof u.onBeforeWrite) {\n                        var f = u.onBeforeWrite.call(l, i, t, a, u);\n                        if (f) {\n                            if (f.refreshFromBuffer) {\n                                var d = f.refreshFromBuffer;\n                                s.refreshFromBuffer.call(l, !0 === d ? d : d.start, d.end, f.buffer || t), t = o.getBuffer.call(l, !0);\n                            }\n                            void 0 !== a && (a = void 0 !== f.caret ? f.caret : a);\n                        }\n                    }\n                    if (void 0 !== e && (e.inputmask._valueSet(t.join(\"\")), void 0 === a || void 0 !== i && \"blur\" === i.type || o.caret.call(l, e, a, void 0, void 0, void 0 !== i && \"keydown\" === i.type && (i.keyCode === n.default.DELETE || i.keyCode === n.default.BACKSPACE)), \n                    !0 === r)) {\n                        var p = c(e), h = e.inputmask._valueGet();\n                        e.inputmask.skipInputEvent = !0, p.trigger(\"input\"), setTimeout((function() {\n                            h === o.getBufferTemplate.call(l).join(\"\") ? p.trigger(\"cleared\") : !0 === s.isComplete.call(l, t) && p.trigger(\"complete\");\n                        }), 0);\n                    }\n                }\n            },\n            2394: function(e, t, a) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = void 0, a(7149), a(3194);\n                var i = a(157), n = m(a(4963)), r = m(a(9380)), o = a(2391), s = a(4713), l = a(8711), u = a(7215), c = a(7760), f = a(9716), d = m(a(7392)), p = m(a(3976)), h = m(a(8741));\n                function v(e) {\n                    return (v = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e) {\n                        return typeof e;\n                    } : function(e) {\n                        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n                    })(e);\n                }\n                function m(e) {\n                    return e && e.__esModule ? e : {\n                        default: e\n                    };\n                }\n                var g = r.default.document, k = \"_inputmask_opts\";\n                function y(e, t, a) {\n                    if (h.default) {\n                        if (!(this instanceof y)) return new y(e, t, a);\n                        this.dependencyLib = n.default, this.el = void 0, this.events = {}, this.maskset = void 0, \n                        !0 !== a && (\"[object Object]\" === Object.prototype.toString.call(e) ? t = e : (t = t || {}, \n                        e && (t.alias = e)), this.opts = n.default.extend(!0, {}, this.defaults, t), this.noMasksCache = t && void 0 !== t.definitions, \n                        this.userOptions = t || {}, b(this.opts.alias, t, this.opts)), this.refreshValue = !1, \n                        this.undoValue = void 0, this.$el = void 0, this.skipKeyPressEvent = !1, this.skipInputEvent = !1, \n                        this.validationEvent = !1, this.ignorable = !1, this.maxLength, this.mouseEnter = !1, \n                        this.originalPlaceholder = void 0, this.isComposing = !1;\n                    }\n                }\n                function b(e, t, a) {\n                    var i = y.prototype.aliases[e];\n                    return i ? (i.alias && b(i.alias, void 0, a), n.default.extend(!0, a, i), n.default.extend(!0, a, t), \n                    !0) : (null === a.mask && (a.mask = e), !1);\n                }\n                y.prototype = {\n                    dataAttribute: \"data-inputmask\",\n                    defaults: p.default,\n                    definitions: d.default,\n                    aliases: {},\n                    masksCache: {},\n                    get isRTL() {\n                        return this.opts.isRTL || this.opts.numericInput;\n                    },\n                    mask: function(e) {\n                        var t = this;\n                        return \"string\" == typeof e && (e = g.getElementById(e) || g.querySelectorAll(e)), \n                        (e = e.nodeName ? [ e ] : Array.isArray(e) ? e : Array.from(e)).forEach((function(e, a) {\n                            var s = n.default.extend(!0, {}, t.opts);\n                            if (function(e, t, a, i) {\n                                function o(t, n) {\n                                    var o = \"\" === i ? t : i + \"-\" + t;\n                                    null !== (n = void 0 !== n ? n : e.getAttribute(o)) && (\"string\" == typeof n && (0 === t.indexOf(\"on\") ? n = r.default[n] : \"false\" === n ? n = !1 : \"true\" === n && (n = !0)), \n                                    a[t] = n);\n                                }\n                                if (!0 === t.importDataAttributes) {\n                                    var s, l, u, c, f = e.getAttribute(i);\n                                    if (f && \"\" !== f && (f = f.replace(/'/g, '\"'), l = JSON.parse(\"{\" + f + \"}\")), \n                                    l) for (c in u = void 0, l) if (\"alias\" === c.toLowerCase()) {\n                                        u = l[c];\n                                        break;\n                                    }\n                                    for (s in o(\"alias\", u), a.alias && b(a.alias, a, t), t) {\n                                        if (l) for (c in u = void 0, l) if (c.toLowerCase() === s.toLowerCase()) {\n                                            u = l[c];\n                                            break;\n                                        }\n                                        o(s, u);\n                                    }\n                                }\n                                n.default.extend(!0, t, a), (\"rtl\" === e.dir || t.rightAlign) && (e.style.textAlign = \"right\");\n                                (\"rtl\" === e.dir || t.numericInput) && (e.dir = \"ltr\", e.removeAttribute(\"dir\"), \n                                t.isRTL = !0);\n                                return Object.keys(a).length;\n                            }(e, s, n.default.extend(!0, {}, t.userOptions), t.dataAttribute)) {\n                                var l = (0, o.generateMaskSet)(s, t.noMasksCache);\n                                void 0 !== l && (void 0 !== e.inputmask && (e.inputmask.opts.autoUnmask = !0, e.inputmask.remove()), \n                                e.inputmask = new y(void 0, void 0, !0), e.inputmask.opts = s, e.inputmask.noMasksCache = t.noMasksCache, \n                                e.inputmask.userOptions = n.default.extend(!0, {}, t.userOptions), e.inputmask.el = e, \n                                e.inputmask.$el = (0, n.default)(e), e.inputmask.maskset = l, n.default.data(e, k, t.userOptions), \n                                i.mask.call(e.inputmask));\n                            }\n                        })), e && e[0] && e[0].inputmask || this;\n                    },\n                    option: function(e, t) {\n                        return \"string\" == typeof e ? this.opts[e] : \"object\" === v(e) ? (n.default.extend(this.userOptions, e), \n                        this.el && !0 !== t && this.mask(this.el), this) : void 0;\n                    },\n                    unmaskedvalue: function(e) {\n                        if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), \n                        void 0 === this.el || void 0 !== e) {\n                            var t = (\"function\" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split(\"\");\n                            c.checkVal.call(this, void 0, !1, !1, t), \"function\" == typeof this.opts.onBeforeWrite && this.opts.onBeforeWrite.call(this, void 0, l.getBuffer.call(this), 0, this.opts);\n                        }\n                        return c.unmaskedvalue.call(this, this.el);\n                    },\n                    remove: function() {\n                        if (this.el) {\n                            n.default.data(this.el, k, null);\n                            var e = this.opts.autoUnmask ? (0, c.unmaskedvalue)(this.el) : this._valueGet(this.opts.autoUnmask);\n                            e !== l.getBufferTemplate.call(this).join(\"\") ? this._valueSet(e, this.opts.autoUnmask) : this._valueSet(\"\"), \n                            f.EventRuler.off(this.el), Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this.el), \"value\") && this.__valueGet && Object.defineProperty(this.el, \"value\", {\n                                get: this.__valueGet,\n                                set: this.__valueSet,\n                                configurable: !0\n                            }) : g.__lookupGetter__ && this.el.__lookupGetter__(\"value\") && this.__valueGet && (this.el.__defineGetter__(\"value\", this.__valueGet), \n                            this.el.__defineSetter__(\"value\", this.__valueSet)), this.el.inputmask = void 0;\n                        }\n                        return this.el;\n                    },\n                    getemptymask: function() {\n                        return this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), \n                        l.getBufferTemplate.call(this).join(\"\");\n                    },\n                    hasMaskedValue: function() {\n                        return !this.opts.autoUnmask;\n                    },\n                    isComplete: function() {\n                        return this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), \n                        u.isComplete.call(this, l.getBuffer.call(this));\n                    },\n                    getmetadata: function() {\n                        if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), \n                        Array.isArray(this.maskset.metadata)) {\n                            var e = s.getMaskTemplate.call(this, !0, 0, !1).join(\"\");\n                            return this.maskset.metadata.forEach((function(t) {\n                                return t.mask !== e || (e = t, !1);\n                            })), e;\n                        }\n                        return this.maskset.metadata;\n                    },\n                    isValid: function(e) {\n                        if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), \n                        e) {\n                            var t = (\"function\" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split(\"\");\n                            c.checkVal.call(this, void 0, !0, !1, t);\n                        } else e = this.isRTL ? l.getBuffer.call(this).slice().reverse().join(\"\") : l.getBuffer.call(this).join(\"\");\n                        for (var a = l.getBuffer.call(this), i = l.determineLastRequiredPosition.call(this), n = a.length - 1; n > i && !l.isMask.call(this, n); n--) ;\n                        return a.splice(i, n + 1 - i), u.isComplete.call(this, a) && e === (this.isRTL ? l.getBuffer.call(this).slice().reverse().join(\"\") : l.getBuffer.call(this).join(\"\"));\n                    },\n                    format: function(e, t) {\n                        this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache);\n                        var a = (\"function\" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e, this.opts) || e).split(\"\");\n                        c.checkVal.call(this, void 0, !0, !1, a);\n                        var i = this.isRTL ? l.getBuffer.call(this).slice().reverse().join(\"\") : l.getBuffer.call(this).join(\"\");\n                        return t ? {\n                            value: i,\n                            metadata: this.getmetadata()\n                        } : i;\n                    },\n                    setValue: function(e) {\n                        this.el && (0, n.default)(this.el).trigger(\"setvalue\", [ e ]);\n                    },\n                    analyseMask: o.analyseMask\n                }, y.extendDefaults = function(e) {\n                    n.default.extend(!0, y.prototype.defaults, e);\n                }, y.extendDefinitions = function(e) {\n                    n.default.extend(!0, y.prototype.definitions, e);\n                }, y.extendAliases = function(e) {\n                    n.default.extend(!0, y.prototype.aliases, e);\n                }, y.format = function(e, t, a) {\n                    return y(t).format(e, a);\n                }, y.unmask = function(e, t) {\n                    return y(t).unmaskedvalue(e);\n                }, y.isValid = function(e, t) {\n                    return y(t).isValid(e);\n                }, y.remove = function(e) {\n                    \"string\" == typeof e && (e = g.getElementById(e) || g.querySelectorAll(e)), (e = e.nodeName ? [ e ] : e).forEach((function(e) {\n                        e.inputmask && e.inputmask.remove();\n                    }));\n                }, y.setValue = function(e, t) {\n                    \"string\" == typeof e && (e = g.getElementById(e) || g.querySelectorAll(e)), (e = e.nodeName ? [ e ] : e).forEach((function(e) {\n                        e.inputmask ? e.inputmask.setValue(t) : (0, n.default)(e).trigger(\"setvalue\", [ t ]);\n                    }));\n                }, y.dependencyLib = n.default, r.default.Inputmask = y;\n                var x = y;\n                t.default = x;\n            },\n            5296: function(e, t, a) {\n                function i(e) {\n                    return (i = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e) {\n                        return typeof e;\n                    } : function(e) {\n                        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n                    })(e);\n                }\n                var n = p(a(9380)), r = p(a(2394)), o = p(a(8741));\n                function s(e, t) {\n                    return !t || \"object\" !== i(t) && \"function\" != typeof t ? function(e) {\n                        if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                        return e;\n                    }(e) : t;\n                }\n                function l(e) {\n                    var t = \"function\" == typeof Map ? new Map : void 0;\n                    return (l = function(e) {\n                        if (null === e || (a = e, -1 === Function.toString.call(a).indexOf(\"[native code]\"))) return e;\n                        var a;\n                        if (\"function\" != typeof e) throw new TypeError(\"Super expression must either be null or a function\");\n                        if (void 0 !== t) {\n                            if (t.has(e)) return t.get(e);\n                            t.set(e, i);\n                        }\n                        function i() {\n                            return u(e, arguments, d(this).constructor);\n                        }\n                        return i.prototype = Object.create(e.prototype, {\n                            constructor: {\n                                value: i,\n                                enumerable: !1,\n                                writable: !0,\n                                configurable: !0\n                            }\n                        }), f(i, e);\n                    })(e);\n                }\n                function u(e, t, a) {\n                    return (u = c() ? Reflect.construct : function(e, t, a) {\n                        var i = [ null ];\n                        i.push.apply(i, t);\n                        var n = new (Function.bind.apply(e, i));\n                        return a && f(n, a.prototype), n;\n                    }).apply(null, arguments);\n                }\n                function c() {\n                    if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n                    if (Reflect.construct.sham) return !1;\n                    if (\"function\" == typeof Proxy) return !0;\n                    try {\n                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), \n                        !0;\n                    } catch (e) {\n                        return !1;\n                    }\n                }\n                function f(e, t) {\n                    return (f = Object.setPrototypeOf || function(e, t) {\n                        return e.__proto__ = t, e;\n                    })(e, t);\n                }\n                function d(e) {\n                    return (d = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {\n                        return e.__proto__ || Object.getPrototypeOf(e);\n                    })(e);\n                }\n                function p(e) {\n                    return e && e.__esModule ? e : {\n                        default: e\n                    };\n                }\n                var h = n.default.document;\n                if (o.default && h && h.head && h.head.attachShadow && n.default.customElements && void 0 === n.default.customElements.get(\"input-mask\")) {\n                    var v = function(e) {\n                        !function(e, t) {\n                            if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n                            e.prototype = Object.create(t && t.prototype, {\n                                constructor: {\n                                    value: e,\n                                    writable: !0,\n                                    configurable: !0\n                                }\n                            }), t && f(e, t);\n                        }(n, e);\n                        var t, a, i = (t = n, a = c(), function() {\n                            var e, i = d(t);\n                            if (a) {\n                                var n = d(this).constructor;\n                                e = Reflect.construct(i, arguments, n);\n                            } else e = i.apply(this, arguments);\n                            return s(this, e);\n                        });\n                        function n() {\n                            var e;\n                            !function(e, t) {\n                                if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n                            }(this, n);\n                            var t = (e = i.call(this)).getAttributeNames(), a = e.attachShadow({\n                                mode: \"closed\"\n                            }), o = h.createElement(\"input\");\n                            for (var s in o.type = \"text\", a.appendChild(o), t) Object.prototype.hasOwnProperty.call(t, s) && o.setAttribute(t[s], e.getAttribute(t[s]));\n                            var l = new r.default;\n                            return l.dataAttribute = \"\", l.mask(o), o.inputmask.shadowRoot = a, e;\n                        }\n                        return n;\n                    }(l(HTMLElement));\n                    n.default.customElements.define(\"input-mask\", v);\n                }\n            },\n            2391: function(e, t, a) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.generateMaskSet = function(e, t) {\n                    var a;\n                    function n(e, a, n) {\n                        var r, o, s = !1;\n                        if (null !== e && \"\" !== e || ((s = null !== n.regex) ? e = (e = n.regex).replace(/^(\\^)(.*)(\\$)$/, \"$2\") : (s = !0, \n                        e = \".*\")), 1 === e.length && !1 === n.greedy && 0 !== n.repeat && (n.placeholder = \"\"), \n                        n.repeat > 0 || \"*\" === n.repeat || \"+\" === n.repeat) {\n                            var l = \"*\" === n.repeat ? 0 : \"+\" === n.repeat ? 1 : n.repeat;\n                            e = n.groupmarker[0] + e + n.groupmarker[1] + n.quantifiermarker[0] + l + \",\" + n.repeat + n.quantifiermarker[1];\n                        }\n                        return o = s ? \"regex_\" + n.regex : n.numericInput ? e.split(\"\").reverse().join(\"\") : e, \n                        !1 !== n.keepStatic && (o = \"ks_\" + o), void 0 === Inputmask.prototype.masksCache[o] || !0 === t ? (r = {\n                            mask: e,\n                            maskToken: Inputmask.prototype.analyseMask(e, s, n),\n                            validPositions: {},\n                            _buffer: void 0,\n                            buffer: void 0,\n                            tests: {},\n                            excludes: {},\n                            metadata: a,\n                            maskLength: void 0,\n                            jitOffset: {}\n                        }, !0 !== t && (Inputmask.prototype.masksCache[o] = r, r = i.default.extend(!0, {}, Inputmask.prototype.masksCache[o]))) : r = i.default.extend(!0, {}, Inputmask.prototype.masksCache[o]), \n                        r;\n                    }\n                    \"function\" == typeof e.mask && (e.mask = e.mask(e));\n                    if (Array.isArray(e.mask)) {\n                        if (e.mask.length > 1) {\n                            null === e.keepStatic && (e.keepStatic = !0);\n                            var r = e.groupmarker[0];\n                            return (e.isRTL ? e.mask.reverse() : e.mask).forEach((function(t) {\n                                r.length > 1 && (r += e.groupmarker[1] + e.alternatormarker + e.groupmarker[0]), \n                                void 0 !== t.mask && \"function\" != typeof t.mask ? r += t.mask : r += t;\n                            })), n(r += e.groupmarker[1], e.mask, e);\n                        }\n                        e.mask = e.mask.pop();\n                    }\n                    null === e.keepStatic && (e.keepStatic = !1);\n                    a = e.mask && void 0 !== e.mask.mask && \"function\" != typeof e.mask.mask ? n(e.mask.mask, e.mask, e) : n(e.mask, e.mask, e);\n                    return a;\n                }, t.analyseMask = function(e, t, a) {\n                    var i, r, o, s, l, u, c = /(?:[?*+]|\\{[0-9+*]+(?:,[0-9+*]*)?(?:\\|[0-9+*]*)?\\})|[^.?*+^${[]()|\\\\]+|./g, f = /\\[\\^?]?(?:[^\\\\\\]]+|\\\\[\\S\\s]?)*]?|\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\\S\\s]?)|\\((?:\\?[:=!]?)?|(?:[?*+]|\\{[0-9]+(?:,[0-9]*)?\\})\\??|[^.?*+^${[()|\\\\]+|./g, d = !1, p = new n.default, h = [], v = [], m = !1;\n                    function g(e, i, n) {\n                        n = void 0 !== n ? n : e.matches.length;\n                        var r = e.matches[n - 1];\n                        if (t) 0 === i.indexOf(\"[\") || d && /\\\\d|\\\\s|\\\\w]/i.test(i) || \".\" === i ? e.matches.splice(n++, 0, {\n                            fn: new RegExp(i, a.casing ? \"i\" : \"\"),\n                            static: !1,\n                            optionality: !1,\n                            newBlockMarker: void 0 === r ? \"master\" : r.def !== i,\n                            casing: null,\n                            def: i,\n                            placeholder: void 0,\n                            nativeDef: i\n                        }) : (d && (i = i[i.length - 1]), i.split(\"\").forEach((function(t, i) {\n                            r = e.matches[n - 1], e.matches.splice(n++, 0, {\n                                fn: /[a-z]/i.test(a.staticDefinitionSymbol || t) ? new RegExp(\"[\" + (a.staticDefinitionSymbol || t) + \"]\", a.casing ? \"i\" : \"\") : null,\n                                static: !0,\n                                optionality: !1,\n                                newBlockMarker: void 0 === r ? \"master\" : r.def !== t && !0 !== r.static,\n                                casing: null,\n                                def: a.staticDefinitionSymbol || t,\n                                placeholder: void 0 !== a.staticDefinitionSymbol ? t : void 0,\n                                nativeDef: (d ? \"'\" : \"\") + t\n                            });\n                        }))), d = !1; else {\n                            var o = a.definitions && a.definitions[i] || a.usePrototypeDefinitions && Inputmask.prototype.definitions[i];\n                            o && !d ? e.matches.splice(n++, 0, {\n                                fn: o.validator ? \"string\" == typeof o.validator ? new RegExp(o.validator, a.casing ? \"i\" : \"\") : new function() {\n                                    this.test = o.validator;\n                                } : new RegExp(\".\"),\n                                static: o.static || !1,\n                                optionality: !1,\n                                newBlockMarker: void 0 === r ? \"master\" : r.def !== (o.definitionSymbol || i),\n                                casing: o.casing,\n                                def: o.definitionSymbol || i,\n                                placeholder: o.placeholder,\n                                nativeDef: i,\n                                generated: o.generated\n                            }) : (e.matches.splice(n++, 0, {\n                                fn: /[a-z]/i.test(a.staticDefinitionSymbol || i) ? new RegExp(\"[\" + (a.staticDefinitionSymbol || i) + \"]\", a.casing ? \"i\" : \"\") : null,\n                                static: !0,\n                                optionality: !1,\n                                newBlockMarker: void 0 === r ? \"master\" : r.def !== i && !0 !== r.static,\n                                casing: null,\n                                def: a.staticDefinitionSymbol || i,\n                                placeholder: void 0 !== a.staticDefinitionSymbol ? i : void 0,\n                                nativeDef: (d ? \"'\" : \"\") + i\n                            }), d = !1);\n                        }\n                    }\n                    function k() {\n                        if (h.length > 0) {\n                            if (g(s = h[h.length - 1], r), s.isAlternator) {\n                                l = h.pop();\n                                for (var e = 0; e < l.matches.length; e++) l.matches[e].isGroup && (l.matches[e].isGroup = !1);\n                                h.length > 0 ? (s = h[h.length - 1]).matches.push(l) : p.matches.push(l);\n                            }\n                        } else g(p, r);\n                    }\n                    function y(e) {\n                        var t = new n.default(!0);\n                        return t.openGroup = !1, t.matches = e, t;\n                    }\n                    function b() {\n                        if ((o = h.pop()).openGroup = !1, void 0 !== o) if (h.length > 0) {\n                            if ((s = h[h.length - 1]).matches.push(o), s.isAlternator) {\n                                l = h.pop();\n                                for (var e = 0; e < l.matches.length; e++) l.matches[e].isGroup = !1, l.matches[e].alternatorGroup = !1;\n                                h.length > 0 ? (s = h[h.length - 1]).matches.push(l) : p.matches.push(l);\n                            }\n                        } else p.matches.push(o); else k();\n                    }\n                    function x(e) {\n                        var t = e.pop();\n                        return t.isQuantifier && (t = y([ e.pop(), t ])), t;\n                    }\n                    t && (a.optionalmarker[0] = void 0, a.optionalmarker[1] = void 0);\n                    for (;i = t ? f.exec(e) : c.exec(e); ) {\n                        if (r = i[0], t) switch (r.charAt(0)) {\n                          case \"?\":\n                            r = \"{0,1}\";\n                            break;\n\n                          case \"+\":\n                          case \"*\":\n                            r = \"{\" + r + \"}\";\n                            break;\n\n                          case \"|\":\n                            if (0 === h.length) {\n                                var P = y(p.matches);\n                                P.openGroup = !0, h.push(P), p.matches = [], m = !0;\n                            }\n                        }\n                        if (d) k(); else switch (r.charAt(0)) {\n                          case \"$\":\n                          case \"^\":\n                            t || k();\n                            break;\n\n                          case \"(?=\":\n                          case \"(?!\":\n                          case \"(?<=\":\n                          case \"(?<!\":\n                            h.push(new n.default(!0));\n                            break;\n\n                          case a.escapeChar:\n                            d = !0, t && k();\n                            break;\n\n                          case a.optionalmarker[1]:\n                          case a.groupmarker[1]:\n                            b();\n                            break;\n\n                          case a.optionalmarker[0]:\n                            h.push(new n.default(!1, !0));\n                            break;\n\n                          case a.groupmarker[0]:\n                            h.push(new n.default(!0));\n                            break;\n\n                          case a.quantifiermarker[0]:\n                            var E = new n.default(!1, !1, !0), S = (r = r.replace(/[{}]/g, \"\")).split(\"|\"), _ = S[0].split(\",\"), M = isNaN(_[0]) ? _[0] : parseInt(_[0]), w = 1 === _.length ? M : isNaN(_[1]) ? _[1] : parseInt(_[1]), O = isNaN(S[1]) ? S[1] : parseInt(S[1]);\n                            \"*\" !== M && \"+\" !== M || (M = \"*\" === w ? 0 : 1), E.quantifier = {\n                                min: M,\n                                max: w,\n                                jit: O\n                            };\n                            var T = h.length > 0 ? h[h.length - 1].matches : p.matches;\n                            if ((i = T.pop()).isAlternator) {\n                                T.push(i), T = i.matches;\n                                var C = new n.default(!0), A = T.pop();\n                                T.push(C), T = C.matches, i = A;\n                            }\n                            i.isGroup || (i = y([ i ])), T.push(i), T.push(E);\n                            break;\n\n                          case a.alternatormarker:\n                            if (h.length > 0) {\n                                var D = (s = h[h.length - 1]).matches[s.matches.length - 1];\n                                u = s.openGroup && (void 0 === D.matches || !1 === D.isGroup && !1 === D.isAlternator) ? h.pop() : x(s.matches);\n                            } else u = x(p.matches);\n                            if (u.isAlternator) h.push(u); else if (u.alternatorGroup ? (l = h.pop(), u.alternatorGroup = !1) : l = new n.default(!1, !1, !1, !0), \n                            l.matches.push(u), h.push(l), u.openGroup) {\n                                u.openGroup = !1;\n                                var B = new n.default(!0);\n                                B.alternatorGroup = !0, h.push(B);\n                            }\n                            break;\n\n                          default:\n                            k();\n                        }\n                    }\n                    m && b();\n                    for (;h.length > 0; ) o = h.pop(), p.matches.push(o);\n                    p.matches.length > 0 && (!function e(i) {\n                        i && i.matches && i.matches.forEach((function(n, r) {\n                            var o = i.matches[r + 1];\n                            (void 0 === o || void 0 === o.matches || !1 === o.isQuantifier) && n && n.isGroup && (n.isGroup = !1, \n                            t || (g(n, a.groupmarker[0], 0), !0 !== n.openGroup && g(n, a.groupmarker[1]))), \n                            e(n);\n                        }));\n                    }(p), v.push(p));\n                    (a.numericInput || a.isRTL) && function e(t) {\n                        for (var i in t.matches = t.matches.reverse(), t.matches) if (Object.prototype.hasOwnProperty.call(t.matches, i)) {\n                            var n = parseInt(i);\n                            if (t.matches[i].isQuantifier && t.matches[n + 1] && t.matches[n + 1].isGroup) {\n                                var r = t.matches[i];\n                                t.matches.splice(i, 1), t.matches.splice(n + 1, 0, r);\n                            }\n                            void 0 !== t.matches[i].matches ? t.matches[i] = e(t.matches[i]) : t.matches[i] = ((o = t.matches[i]) === a.optionalmarker[0] ? o = a.optionalmarker[1] : o === a.optionalmarker[1] ? o = a.optionalmarker[0] : o === a.groupmarker[0] ? o = a.groupmarker[1] : o === a.groupmarker[1] && (o = a.groupmarker[0]), \n                            o);\n                        }\n                        var o;\n                        return t;\n                    }(v[0]);\n                    return v;\n                };\n                var i = r(a(4963)), n = r(a(9695));\n                function r(e) {\n                    return e && e.__esModule ? e : {\n                        default: e\n                    };\n                }\n            },\n            157: function(e, t, a) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.mask = function() {\n                    var e = this, t = this.opts, a = this.el, i = this.dependencyLib;\n                    s.EventRuler.off(a);\n                    var f = function(t, a) {\n                        \"textarea\" !== t.tagName.toLowerCase() && a.ignorables.push(n.default.ENTER);\n                        var l = t.getAttribute(\"type\"), u = \"input\" === t.tagName.toLowerCase() && a.supportsInputType.includes(l) || t.isContentEditable || \"textarea\" === t.tagName.toLowerCase();\n                        if (!u) if (\"input\" === t.tagName.toLowerCase()) {\n                            var c = document.createElement(\"input\");\n                            c.setAttribute(\"type\", l), u = \"text\" === c.type, c = null;\n                        } else u = \"partial\";\n                        return !1 !== u ? function(t) {\n                            var n, l;\n                            function u() {\n                                return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== r.getLastValidPosition.call(e) || !0 !== a.nullable ? (this.inputmask.shadowRoot || this.ownerDocument).activeElement === this && a.clearMaskOnLostFocus ? (e.isRTL ? o.clearOptionalTail.call(e, r.getBuffer.call(e).slice()).reverse() : o.clearOptionalTail.call(e, r.getBuffer.call(e).slice())).join(\"\") : n.call(this) : \"\" : n.call(this);\n                            }\n                            function c(e) {\n                                l.call(this, e), this.inputmask && (0, o.applyInputValue)(this, e);\n                            }\n                            if (!t.inputmask.__valueGet) {\n                                if (!0 !== a.noValuePatching) {\n                                    if (Object.getOwnPropertyDescriptor) {\n                                        var f = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(t), \"value\") : void 0;\n                                        f && f.get && f.set ? (n = f.get, l = f.set, Object.defineProperty(t, \"value\", {\n                                            get: u,\n                                            set: c,\n                                            configurable: !0\n                                        })) : \"input\" !== t.tagName.toLowerCase() && (n = function() {\n                                            return this.textContent;\n                                        }, l = function(e) {\n                                            this.textContent = e;\n                                        }, Object.defineProperty(t, \"value\", {\n                                            get: u,\n                                            set: c,\n                                            configurable: !0\n                                        }));\n                                    } else document.__lookupGetter__ && t.__lookupGetter__(\"value\") && (n = t.__lookupGetter__(\"value\"), \n                                    l = t.__lookupSetter__(\"value\"), t.__defineGetter__(\"value\", u), t.__defineSetter__(\"value\", c));\n                                    t.inputmask.__valueGet = n, t.inputmask.__valueSet = l;\n                                }\n                                t.inputmask._valueGet = function(t) {\n                                    return e.isRTL && !0 !== t ? n.call(this.el).split(\"\").reverse().join(\"\") : n.call(this.el);\n                                }, t.inputmask._valueSet = function(t, a) {\n                                    l.call(this.el, null == t ? \"\" : !0 !== a && e.isRTL ? t.split(\"\").reverse().join(\"\") : t);\n                                }, void 0 === n && (n = function() {\n                                    return this.value;\n                                }, l = function(e) {\n                                    this.value = e;\n                                }, function(t) {\n                                    if (i.valHooks && (void 0 === i.valHooks[t] || !0 !== i.valHooks[t].inputmaskpatch)) {\n                                        var n = i.valHooks[t] && i.valHooks[t].get ? i.valHooks[t].get : function(e) {\n                                            return e.value;\n                                        }, s = i.valHooks[t] && i.valHooks[t].set ? i.valHooks[t].set : function(e, t) {\n                                            return e.value = t, e;\n                                        };\n                                        i.valHooks[t] = {\n                                            get: function(t) {\n                                                if (t.inputmask) {\n                                                    if (t.inputmask.opts.autoUnmask) return t.inputmask.unmaskedvalue();\n                                                    var i = n(t);\n                                                    return -1 !== r.getLastValidPosition.call(e, void 0, void 0, t.inputmask.maskset.validPositions) || !0 !== a.nullable ? i : \"\";\n                                                }\n                                                return n(t);\n                                            },\n                                            set: function(e, t) {\n                                                var a = s(e, t);\n                                                return e.inputmask && (0, o.applyInputValue)(e, t), a;\n                                            },\n                                            inputmaskpatch: !0\n                                        };\n                                    }\n                                }(t.type), function(t) {\n                                    s.EventRuler.on(t, \"mouseenter\", (function() {\n                                        var t = this.inputmask._valueGet(!0);\n                                        t !== (e.isRTL ? r.getBuffer.call(e).reverse() : r.getBuffer.call(e)).join(\"\") && (0, \n                                        o.applyInputValue)(this, t);\n                                    }));\n                                }(t));\n                            }\n                        }(t) : t.inputmask = void 0, u;\n                    }(a, t);\n                    if (!1 !== f) {\n                        e.originalPlaceholder = a.placeholder, e.maxLength = void 0 !== a ? a.maxLength : void 0, \n                        -1 === e.maxLength && (e.maxLength = void 0), \"inputMode\" in a && null === a.getAttribute(\"inputmode\") && (a.inputMode = t.inputmode, \n                        a.setAttribute(\"inputmode\", t.inputmode)), !0 === f && (t.showMaskOnFocus = t.showMaskOnFocus && -1 === [ \"cc-number\", \"cc-exp\" ].indexOf(a.autocomplete), \n                        l.iphone && (t.insertModeVisual = !1), s.EventRuler.on(a, \"submit\", c.EventHandlers.submitEvent), \n                        s.EventRuler.on(a, \"reset\", c.EventHandlers.resetEvent), s.EventRuler.on(a, \"blur\", c.EventHandlers.blurEvent), \n                        s.EventRuler.on(a, \"focus\", c.EventHandlers.focusEvent), s.EventRuler.on(a, \"invalid\", c.EventHandlers.invalidEvent), \n                        s.EventRuler.on(a, \"click\", c.EventHandlers.clickEvent), s.EventRuler.on(a, \"mouseleave\", c.EventHandlers.mouseleaveEvent), \n                        s.EventRuler.on(a, \"mouseenter\", c.EventHandlers.mouseenterEvent), s.EventRuler.on(a, \"paste\", c.EventHandlers.pasteEvent), \n                        s.EventRuler.on(a, \"cut\", c.EventHandlers.cutEvent), s.EventRuler.on(a, \"complete\", t.oncomplete), \n                        s.EventRuler.on(a, \"incomplete\", t.onincomplete), s.EventRuler.on(a, \"cleared\", t.oncleared), \n                        !0 !== t.inputEventOnly && (s.EventRuler.on(a, \"keydown\", c.EventHandlers.keydownEvent), \n                        s.EventRuler.on(a, \"keypress\", c.EventHandlers.keypressEvent), s.EventRuler.on(a, \"keyup\", c.EventHandlers.keyupEvent)), \n                        (l.mobile || t.inputEventOnly) && a.removeAttribute(\"maxLength\"), s.EventRuler.on(a, \"input\", c.EventHandlers.inputFallBackEvent), \n                        s.EventRuler.on(a, \"compositionend\", c.EventHandlers.compositionendEvent)), s.EventRuler.on(a, \"setvalue\", c.EventHandlers.setValueEvent), \n                        r.getBufferTemplate.call(e).join(\"\"), e.undoValue = e._valueGet(!0);\n                        var d = (a.inputmask.shadowRoot || a.ownerDocument).activeElement;\n                        if (\"\" !== a.inputmask._valueGet(!0) || !1 === t.clearMaskOnLostFocus || d === a) {\n                            (0, o.applyInputValue)(a, a.inputmask._valueGet(!0), t);\n                            var p = r.getBuffer.call(e).slice();\n                            !1 === u.isComplete.call(e, p) && t.clearIncomplete && r.resetMaskSet.call(e), t.clearMaskOnLostFocus && d !== a && (-1 === r.getLastValidPosition.call(e) ? p = [] : o.clearOptionalTail.call(e, p)), \n                            (!1 === t.clearMaskOnLostFocus || t.showMaskOnFocus && d === a || \"\" !== a.inputmask._valueGet(!0)) && (0, \n                            o.writeBuffer)(a, p), d === a && r.caret.call(e, a, r.seekNext.call(e, r.getLastValidPosition.call(e)));\n                        }\n                    }\n                };\n                var i, n = (i = a(4528)) && i.__esModule ? i : {\n                    default: i\n                }, r = a(8711), o = a(7760), s = a(9716), l = a(9845), u = a(7215), c = a(6030);\n            },\n            9695: function(e, t) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.default = function(e, t, a, i) {\n                    this.matches = [], this.openGroup = e || !1, this.alternatorGroup = !1, this.isGroup = e || !1, \n                    this.isOptional = t || !1, this.isQuantifier = a || !1, this.isAlternator = i || !1, \n                    this.quantifier = {\n                        min: 1,\n                        max: 1\n                    };\n                };\n            },\n            3194: function() {\n                Array.prototype.includes || Object.defineProperty(Array.prototype, \"includes\", {\n                    value: function(e, t) {\n                        if (null == this) throw new TypeError('\"this\" is null or not defined');\n                        var a = Object(this), i = a.length >>> 0;\n                        if (0 === i) return !1;\n                        for (var n = 0 | t, r = Math.max(n >= 0 ? n : i - Math.abs(n), 0); r < i; ) {\n                            if (a[r] === e) return !0;\n                            r++;\n                        }\n                        return !1;\n                    }\n                });\n            },\n            7149: function() {\n                function e(t) {\n                    return (e = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e) {\n                        return typeof e;\n                    } : function(e) {\n                        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n                    })(t);\n                }\n                \"function\" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = \"object\" === e(\"test\".__proto__) ? function(e) {\n                    return e.__proto__;\n                } : function(e) {\n                    return e.constructor.prototype;\n                });\n            },\n            8711: function(e, t, a) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.caret = function(e, t, a, i, n) {\n                    var r, o = this, s = this.opts;\n                    if (void 0 === t) return \"selectionStart\" in e && \"selectionEnd\" in e ? (t = e.selectionStart, \n                    a = e.selectionEnd) : window.getSelection ? (r = window.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode !== e && r.commonAncestorContainer !== e || (t = r.startOffset, \n                    a = r.endOffset) : document.selection && document.selection.createRange && (r = document.selection.createRange(), \n                    t = 0 - r.duplicate().moveStart(\"character\", -e.inputmask._valueGet().length), a = t + r.text.length), \n                    {\n                        begin: i ? t : u.call(o, t),\n                        end: i ? a : u.call(o, a)\n                    };\n                    if (Array.isArray(t) && (a = o.isRTL ? t[0] : t[1], t = o.isRTL ? t[1] : t[0]), \n                    void 0 !== t.begin && (a = o.isRTL ? t.begin : t.end, t = o.isRTL ? t.end : t.begin), \n                    \"number\" == typeof t) {\n                        t = i ? t : u.call(o, t), a = \"number\" == typeof (a = i ? a : u.call(o, a)) ? a : t;\n                        var l = parseInt(((e.ownerDocument.defaultView || window).getComputedStyle ? (e.ownerDocument.defaultView || window).getComputedStyle(e, null) : e.currentStyle).fontSize) * a;\n                        if (e.scrollLeft = l > e.scrollWidth ? l : 0, e.inputmask.caretPos = {\n                            begin: t,\n                            end: a\n                        }, s.insertModeVisual && !1 === s.insertMode && t === a && (n || a++), e === (e.inputmask.shadowRoot || e.ownerDocument).activeElement) if (\"setSelectionRange\" in e) e.setSelectionRange(t, a); else if (window.getSelection) {\n                            if (r = document.createRange(), void 0 === e.firstChild || null === e.firstChild) {\n                                var c = document.createTextNode(\"\");\n                                e.appendChild(c);\n                            }\n                            r.setStart(e.firstChild, t < e.inputmask._valueGet().length ? t : e.inputmask._valueGet().length), \n                            r.setEnd(e.firstChild, a < e.inputmask._valueGet().length ? a : e.inputmask._valueGet().length), \n                            r.collapse(!0);\n                            var f = window.getSelection();\n                            f.removeAllRanges(), f.addRange(r);\n                        } else e.createTextRange && ((r = e.createTextRange()).collapse(!0), r.moveEnd(\"character\", a), \n                        r.moveStart(\"character\", t), r.select());\n                    }\n                }, t.determineLastRequiredPosition = function(e) {\n                    var t, a, r = this, s = this.maskset, l = this.dependencyLib, u = i.getMaskTemplate.call(r, !0, o.call(r), !0, !0), c = u.length, f = o.call(r), d = {}, p = s.validPositions[f], h = void 0 !== p ? p.locator.slice() : void 0;\n                    for (t = f + 1; t < u.length; t++) a = i.getTestTemplate.call(r, t, h, t - 1), h = a.locator.slice(), \n                    d[t] = l.extend(!0, {}, a);\n                    var v = p && void 0 !== p.alternation ? p.locator[p.alternation] : void 0;\n                    for (t = c - 1; t > f && (((a = d[t]).match.optionality || a.match.optionalQuantifier && a.match.newBlockMarker || v && (v !== d[t].locator[p.alternation] && 1 != a.match.static || !0 === a.match.static && a.locator[p.alternation] && n.checkAlternationMatch.call(r, a.locator[p.alternation].toString().split(\",\"), v.toString().split(\",\")) && \"\" !== i.getTests.call(r, t)[0].def)) && u[t] === i.getPlaceholder.call(r, t, a.match)); t--) c--;\n                    return e ? {\n                        l: c,\n                        def: d[c] ? d[c].match : void 0\n                    } : c;\n                }, t.determineNewCaretPosition = function(e, t, a) {\n                    var n = this, u = this.maskset, c = this.opts;\n                    t && (n.isRTL ? e.end = e.begin : e.begin = e.end);\n                    if (e.begin === e.end) {\n                        switch (a = a || c.positionCaretOnClick) {\n                          case \"none\":\n                            break;\n\n                          case \"select\":\n                            e = {\n                                begin: 0,\n                                end: r.call(n).length\n                            };\n                            break;\n\n                          case \"ignore\":\n                            e.end = e.begin = l.call(n, o.call(n));\n                            break;\n\n                          case \"radixFocus\":\n                            if (function(e) {\n                                if (\"\" !== c.radixPoint && 0 !== c.digits) {\n                                    var t = u.validPositions;\n                                    if (void 0 === t[e] || t[e].input === i.getPlaceholder.call(n, e)) {\n                                        if (e < l.call(n, -1)) return !0;\n                                        var a = r.call(n).indexOf(c.radixPoint);\n                                        if (-1 !== a) {\n                                            for (var o in t) if (t[o] && a < o && t[o].input !== i.getPlaceholder.call(n, o)) return !1;\n                                            return !0;\n                                        }\n                                    }\n                                }\n                                return !1;\n                            }(e.begin)) {\n                                var f = r.call(n).join(\"\").indexOf(c.radixPoint);\n                                e.end = e.begin = c.numericInput ? l.call(n, f) : f;\n                                break;\n                            }\n\n                          default:\n                            var d = e.begin, p = o.call(n, d, !0), h = l.call(n, -1 !== p || s.call(n, 0) ? p : -1);\n                            if (d <= h) e.end = e.begin = s.call(n, d, !1, !0) ? d : l.call(n, d); else {\n                                var v = u.validPositions[p], m = i.getTestTemplate.call(n, h, v ? v.match.locator : void 0, v), g = i.getPlaceholder.call(n, h, m.match);\n                                if (\"\" !== g && r.call(n)[h] !== g && !0 !== m.match.optionalQuantifier && !0 !== m.match.newBlockMarker || !s.call(n, h, c.keepStatic, !0) && m.match.def === g) {\n                                    var k = l.call(n, h);\n                                    (d >= k || d === h) && (h = k);\n                                }\n                                e.end = e.begin = h;\n                            }\n                        }\n                        return e;\n                    }\n                }, t.getBuffer = r, t.getBufferTemplate = function() {\n                    var e = this.maskset;\n                    void 0 === e._buffer && (e._buffer = i.getMaskTemplate.call(this, !1, 1), void 0 === e.buffer && (e.buffer = e._buffer.slice()));\n                    return e._buffer;\n                }, t.getLastValidPosition = o, t.isMask = s, t.resetMaskSet = function(e) {\n                    var t = this.maskset;\n                    t.buffer = void 0, !0 !== e && (t.validPositions = {}, t.p = 0);\n                }, t.seekNext = l, t.seekPrevious = function(e, t) {\n                    var a = this, n = e - 1;\n                    if (e <= 0) return 0;\n                    for (;n > 0 && (!0 === t && (!0 !== i.getTest.call(a, n).match.newBlockMarker || !s.call(a, n, void 0, !0)) || !0 !== t && !s.call(a, n, void 0, !0)); ) n--;\n                    return n;\n                }, t.translatePosition = u;\n                var i = a(4713), n = a(7215);\n                function r(e) {\n                    var t = this.maskset;\n                    return void 0 !== t.buffer && !0 !== e || (t.buffer = i.getMaskTemplate.call(this, !0, o.call(this), !0), \n                    void 0 === t._buffer && (t._buffer = t.buffer.slice())), t.buffer;\n                }\n                function o(e, t, a) {\n                    var i = this.maskset, n = -1, r = -1, o = a || i.validPositions;\n                    for (var s in void 0 === e && (e = -1), o) {\n                        var l = parseInt(s);\n                        o[l] && (t || !0 !== o[l].generatedInput) && (l <= e && (n = l), l >= e && (r = l));\n                    }\n                    return -1 === n || n == e ? r : -1 == r || e - n < r - e ? n : r;\n                }\n                function s(e, t, a) {\n                    var n = this, r = this.maskset, o = i.getTestTemplate.call(n, e).match;\n                    if (\"\" === o.def && (o = i.getTest.call(n, e).match), !0 !== o.static) return o.fn;\n                    if (!0 === a && void 0 !== r.validPositions[e] && !0 !== r.validPositions[e].generatedInput) return !0;\n                    if (!0 !== t && e > -1) {\n                        if (a) {\n                            var s = i.getTests.call(n, e);\n                            return s.length > 1 + (\"\" === s[s.length - 1].match.def ? 1 : 0);\n                        }\n                        var l = i.determineTestTemplate.call(n, e, i.getTests.call(n, e)), u = i.getPlaceholder.call(n, e, l.match);\n                        return l.match.def !== u;\n                    }\n                    return !1;\n                }\n                function l(e, t, a) {\n                    var n = this;\n                    void 0 === a && (a = !0);\n                    for (var r = e + 1; \"\" !== i.getTest.call(n, r).match.def && (!0 === t && (!0 !== i.getTest.call(n, r).match.newBlockMarker || !s.call(n, r, void 0, !0)) || !0 !== t && !s.call(n, r, void 0, a)); ) r++;\n                    return r;\n                }\n                function u(e) {\n                    var t = this.opts, a = this.el;\n                    return !this.isRTL || \"number\" != typeof e || t.greedy && \"\" === t.placeholder || !a || (e = Math.abs(this._valueGet().length - e)), \n                    e;\n                }\n            },\n            4713: function(e, t) {\n                function a(e, t) {\n                    var a = (null != e.alternation ? e.mloc[i(e)] : e.locator).join(\"\");\n                    if (\"\" !== a) for (;a.length < t; ) a += \"0\";\n                    return a;\n                }\n                function i(e) {\n                    var t = e.locator[e.alternation];\n                    return \"string\" == typeof t && t.length > 0 && (t = t.split(\",\")[0]), void 0 !== t ? t.toString() : \"\";\n                }\n                function n(e, t, a) {\n                    var i = this.opts, n = this.maskset;\n                    if (void 0 !== (t = t || s.call(this, e).match).placeholder || !0 === a) return \"function\" == typeof t.placeholder ? t.placeholder(i) : t.placeholder;\n                    if (!0 === t.static) {\n                        if (e > -1 && void 0 === n.validPositions[e]) {\n                            var r, o = u.call(this, e), l = [];\n                            if (o.length > 1 + (\"\" === o[o.length - 1].match.def ? 1 : 0)) for (var c = 0; c < o.length; c++) if (\"\" !== o[c].match.def && !0 !== o[c].match.optionality && !0 !== o[c].match.optionalQuantifier && (!0 === o[c].match.static || void 0 === r || !1 !== o[c].match.fn.test(r.match.def, n, e, !0, i)) && (l.push(o[c]), \n                            !0 === o[c].match.static && (r = o[c]), l.length > 1 && /[0-9a-bA-Z]/.test(l[0].match.def))) return i.placeholder.charAt(e % i.placeholder.length);\n                        }\n                        return t.def;\n                    }\n                    return i.placeholder.charAt(e % i.placeholder.length);\n                }\n                function r(e, t, a) {\n                    return this.maskset.validPositions[e] || o.call(this, e, u.call(this, e, t ? t.slice() : t, a));\n                }\n                function o(e, t) {\n                    var i = this.opts;\n                    e = e > 0 ? e - 1 : 0;\n                    for (var n, r, o, l = a(s.call(this, e)), u = 0; u < t.length; u++) {\n                        var c = t[u];\n                        n = a(c, l.length);\n                        var f = Math.abs(n - l);\n                        (void 0 === r || \"\" !== n && f < r || o && !i.greedy && o.match.optionality && \"master\" === o.match.newBlockMarker && (!c.match.optionality || !c.match.newBlockMarker) || o && o.match.optionalQuantifier && !c.match.optionalQuantifier) && (r = f, \n                        o = c);\n                    }\n                    return o;\n                }\n                function s(e, t) {\n                    var a = this.maskset;\n                    return a.validPositions[e] ? a.validPositions[e] : (t || u.call(this, e))[0];\n                }\n                function l(e, t, a) {\n                    function i(e) {\n                        for (var t, a = [], i = -1, n = 0, r = e.length; n < r; n++) if (\"-\" === e.charAt(n)) for (t = e.charCodeAt(n + 1); ++i < t; ) a.push(String.fromCharCode(i)); else i = e.charCodeAt(n), \n                        a.push(e.charAt(n));\n                        return a.join(\"\");\n                    }\n                    return e.match.def === t.match.nativeDef || !(!(a.regex || e.match.fn instanceof RegExp && t.match.fn instanceof RegExp) || !0 === e.match.static || !0 === t.match.static) && -1 !== i(t.match.fn.toString().replace(/[[\\]/]/g, \"\")).indexOf(i(e.match.fn.toString().replace(/[[\\]/]/g, \"\")));\n                }\n                function u(e, t, a) {\n                    var i, n = this, r = this.dependencyLib, s = this.maskset, u = this.opts, c = this.el, f = s.maskToken, d = t ? a : 0, p = t ? t.slice() : [ 0 ], h = [], v = !1, m = t ? t.join(\"\") : \"\";\n                    function g(t, a, n, r) {\n                        function o(n, r, f) {\n                            function p(e, t) {\n                                var a = 0 === t.matches.indexOf(e);\n                                return a || t.matches.every((function(i, n) {\n                                    return !0 === i.isQuantifier ? a = p(e, t.matches[n - 1]) : Object.prototype.hasOwnProperty.call(i, \"matches\") && (a = p(e, i)), \n                                    !a;\n                                })), a;\n                            }\n                            function k(e, t, a) {\n                                var i, n;\n                                if ((s.tests[e] || s.validPositions[e]) && (s.tests[e] || [ s.validPositions[e] ]).every((function(e, r) {\n                                    if (e.mloc[t]) return i = e, !1;\n                                    var o = void 0 !== a ? a : e.alternation, s = void 0 !== e.locator[o] ? e.locator[o].toString().indexOf(t) : -1;\n                                    return (void 0 === n || s < n) && -1 !== s && (i = e, n = s), !0;\n                                })), i) {\n                                    var r = i.locator[i.alternation];\n                                    return (i.mloc[t] || i.mloc[r] || i.locator).slice((void 0 !== a ? a : i.alternation) + 1);\n                                }\n                                return void 0 !== a ? k(e, t) : void 0;\n                            }\n                            function y(e, t) {\n                                var a = e.alternation, i = void 0 === t || a === t.alternation && -1 === e.locator[a].toString().indexOf(t.locator[a]);\n                                if (!i && a > t.alternation) for (var n = t.alternation; n < a; n++) if (e.locator[n] !== t.locator[n]) {\n                                    a = n, i = !0;\n                                    break;\n                                }\n                                if (i) {\n                                    e.mloc = e.mloc || {};\n                                    var r = e.locator[a];\n                                    if (void 0 !== r) {\n                                        if (\"string\" == typeof r && (r = r.split(\",\")[0]), void 0 === e.mloc[r] && (e.mloc[r] = e.locator.slice()), \n                                        void 0 !== t) {\n                                            for (var o in t.mloc) \"string\" == typeof o && (o = o.split(\",\")[0]), void 0 === e.mloc[o] && (e.mloc[o] = t.mloc[o]);\n                                            e.locator[a] = Object.keys(e.mloc).join(\",\");\n                                        }\n                                        return !0;\n                                    }\n                                    e.alternation = void 0;\n                                }\n                                return !1;\n                            }\n                            function b(e, t) {\n                                if (e.locator.length !== t.locator.length) return !1;\n                                for (var a = e.alternation + 1; a < e.locator.length; a++) if (e.locator[a] !== t.locator[a]) return !1;\n                                return !0;\n                            }\n                            if (d > e + u._maxTestPos) throw \"Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. \" + s.mask;\n                            if (d === e && void 0 === n.matches) return h.push({\n                                match: n,\n                                locator: r.reverse(),\n                                cd: m,\n                                mloc: {}\n                            }), !0;\n                            if (void 0 !== n.matches) {\n                                if (n.isGroup && f !== n) {\n                                    if (n = o(t.matches[t.matches.indexOf(n) + 1], r, f)) return !0;\n                                } else if (n.isOptional) {\n                                    var x = n, P = h.length;\n                                    if (n = g(n, a, r, f)) {\n                                        if (h.forEach((function(e, t) {\n                                            t >= P && (e.match.optionality = !0);\n                                        })), i = h[h.length - 1].match, void 0 !== f || !p(i, x)) return !0;\n                                        v = !0, d = e;\n                                    }\n                                } else if (n.isAlternator) {\n                                    var E, S = n, _ = [], M = h.slice(), w = r.length, O = !1, T = a.length > 0 ? a.shift() : -1;\n                                    if (-1 === T || \"string\" == typeof T) {\n                                        var C, A = d, D = a.slice(), B = [];\n                                        if (\"string\" == typeof T) B = T.split(\",\"); else for (C = 0; C < S.matches.length; C++) B.push(C.toString());\n                                        if (void 0 !== s.excludes[e]) {\n                                            for (var j = B.slice(), R = 0, L = s.excludes[e].length; R < L; R++) {\n                                                var I = s.excludes[e][R].toString().split(\":\");\n                                                r.length == I[1] && B.splice(B.indexOf(I[0]), 1);\n                                            }\n                                            0 === B.length && (delete s.excludes[e], B = j);\n                                        }\n                                        (!0 === u.keepStatic || isFinite(parseInt(u.keepStatic)) && A >= u.keepStatic) && (B = B.slice(0, 1));\n                                        for (var F = 0; F < B.length; F++) {\n                                            C = parseInt(B[F]), h = [], a = \"string\" == typeof T && k(d, C, w) || D.slice();\n                                            var N = S.matches[C];\n                                            if (N && o(N, [ C ].concat(r), f)) n = !0; else if (0 === F && (O = !0), N && N.matches && N.matches.length > S.matches[0].matches.length) break;\n                                            E = h.slice(), d = A, h = [];\n                                            for (var V = 0; V < E.length; V++) {\n                                                var G = E[V], H = !1;\n                                                G.match.jit = G.match.jit || O, G.alternation = G.alternation || w, y(G);\n                                                for (var K = 0; K < _.length; K++) {\n                                                    var U = _[K];\n                                                    if (\"string\" != typeof T || void 0 !== G.alternation && B.includes(G.locator[G.alternation].toString())) {\n                                                        if (G.match.nativeDef === U.match.nativeDef) {\n                                                            H = !0, y(U, G);\n                                                            break;\n                                                        }\n                                                        if (l(G, U, u)) {\n                                                            y(G, U) && (H = !0, _.splice(_.indexOf(U), 0, G));\n                                                            break;\n                                                        }\n                                                        if (l(U, G, u)) {\n                                                            y(U, G);\n                                                            break;\n                                                        }\n                                                        if (Q = U, !0 === (W = G).match.static && !0 !== Q.match.static && Q.match.fn.test(W.match.def, s, e, !1, u, !1)) {\n                                                            b(G, U) || void 0 !== c.inputmask.userOptions.keepStatic ? y(G, U) && (H = !0, _.splice(_.indexOf(U), 0, G)) : u.keepStatic = !0;\n                                                            break;\n                                                        }\n                                                    }\n                                                }\n                                                H || _.push(G);\n                                            }\n                                        }\n                                        h = M.concat(_), d = e, v = h.length > 0, n = _.length > 0, a = D.slice();\n                                    } else n = o(S.matches[T] || t.matches[T], [ T ].concat(r), f);\n                                    if (n) return !0;\n                                } else if (n.isQuantifier && f !== t.matches[t.matches.indexOf(n) - 1]) for (var $ = n, z = a.length > 0 ? a.shift() : 0; z < (isNaN($.quantifier.max) ? z + 1 : $.quantifier.max) && d <= e; z++) {\n                                    var q = t.matches[t.matches.indexOf($) - 1];\n                                    if (n = o(q, [ z ].concat(r), q)) {\n                                        if ((i = h[h.length - 1].match).optionalQuantifier = z >= $.quantifier.min, i.jit = (z + 1) * (q.matches.indexOf(i) + 1) > $.quantifier.jit, \n                                        i.optionalQuantifier && p(i, q)) {\n                                            v = !0, d = e;\n                                            break;\n                                        }\n                                        return i.jit && (s.jitOffset[e] = q.matches.length - q.matches.indexOf(i)), !0;\n                                    }\n                                } else if (n = g(n, a, r, f)) return !0;\n                            } else d++;\n                            var W, Q;\n                        }\n                        for (var f = a.length > 0 ? a.shift() : 0; f < t.matches.length; f++) if (!0 !== t.matches[f].isQuantifier) {\n                            var p = o(t.matches[f], [ f ].concat(n), r);\n                            if (p && d === e) return p;\n                            if (d > e) break;\n                        }\n                    }\n                    if (e > -1) {\n                        if (void 0 === t) {\n                            for (var k, y = e - 1; void 0 === (k = s.validPositions[y] || s.tests[y]) && y > -1; ) y--;\n                            void 0 !== k && y > -1 && (p = function(e, t) {\n                                var a, i = [];\n                                return Array.isArray(t) || (t = [ t ]), t.length > 0 && (void 0 === t[0].alternation || !0 === u.keepStatic ? 0 === (i = o.call(n, e, t.slice()).locator.slice()).length && (i = t[0].locator.slice()) : t.forEach((function(e) {\n                                    \"\" !== e.def && (0 === i.length ? (a = e.alternation, i = e.locator.slice()) : e.locator[a] && -1 === i[a].toString().indexOf(e.locator[a]) && (i[a] += \",\" + e.locator[a]));\n                                }))), i;\n                            }(y, k), m = p.join(\"\"), d = y);\n                        }\n                        if (s.tests[e] && s.tests[e][0].cd === m) return s.tests[e];\n                        for (var b = p.shift(); b < f.length; b++) {\n                            if (g(f[b], p, [ b ]) && d === e || d > e) break;\n                        }\n                    }\n                    return (0 === h.length || v) && h.push({\n                        match: {\n                            fn: null,\n                            static: !0,\n                            optionality: !1,\n                            casing: null,\n                            def: \"\",\n                            placeholder: \"\"\n                        },\n                        locator: [],\n                        mloc: {},\n                        cd: m\n                    }), void 0 !== t && s.tests[e] ? r.extend(!0, [], h) : (s.tests[e] = r.extend(!0, [], h), \n                    s.tests[e]);\n                }\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.determineTestTemplate = o, t.getDecisionTaker = i, t.getMaskTemplate = function(e, t, a, i, s) {\n                    var l = this, c = this.opts, f = this.maskset, d = c.greedy;\n                    s && (c.greedy = !1);\n                    t = t || 0;\n                    var p, h, v, m, g = [], k = 0;\n                    do {\n                        if (!0 === e && f.validPositions[k]) v = s && !0 === f.validPositions[k].match.optionality && void 0 === f.validPositions[k + 1] && (!0 === f.validPositions[k].generatedInput || f.validPositions[k].input == c.skipOptionalPartCharacter && k > 0) ? o.call(l, k, u.call(l, k, p, k - 1)) : f.validPositions[k], \n                        h = v.match, p = v.locator.slice(), g.push(!0 === a ? v.input : !1 === a ? h.nativeDef : n.call(l, k, h)); else {\n                            v = r.call(l, k, p, k - 1), h = v.match, p = v.locator.slice();\n                            var y = !0 !== i && (!1 !== c.jitMasking ? c.jitMasking : h.jit);\n                            (m = (m && h.static && h.def !== c.groupSeparator && null === h.fn || f.validPositions[k - 1] && h.static && h.def !== c.groupSeparator && null === h.fn) && f.tests[k] && 1 === f.tests[k].length) || !1 === y || void 0 === y || \"number\" == typeof y && isFinite(y) && y > k ? g.push(!1 === a ? h.nativeDef : n.call(l, k, h)) : m = !1;\n                        }\n                        k++;\n                    } while (!0 !== h.static || \"\" !== h.def || t > k);\n                    \"\" === g[g.length - 1] && g.pop();\n                    !1 === a && void 0 !== f.maskLength || (f.maskLength = k - 1);\n                    return c.greedy = d, g;\n                }, t.getPlaceholder = n, t.getTest = s, t.getTests = u, t.getTestTemplate = r, t.isSubsetOf = l;\n            },\n            7215: function(e, t, a) {\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.alternate = l, t.checkAlternationMatch = function(e, t, a) {\n                    for (var i, n = this.opts.greedy ? t : t.slice(0, 1), r = !1, o = void 0 !== a ? a.split(\",\") : [], s = 0; s < o.length; s++) -1 !== (i = e.indexOf(o[s])) && e.splice(i, 1);\n                    for (var l = 0; l < e.length; l++) if (n.includes(e[l])) {\n                        r = !0;\n                        break;\n                    }\n                    return r;\n                }, t.isComplete = c, t.isValid = f, t.refreshFromBuffer = p, t.revalidateMask = v, \n                t.handleRemove = function(e, t, a, i, s) {\n                    var u = this, c = this.maskset, f = this.opts;\n                    if ((f.numericInput || u.isRTL) && (t === r.default.BACKSPACE ? t = r.default.DELETE : t === r.default.DELETE && (t = r.default.BACKSPACE), \n                    u.isRTL)) {\n                        var d = a.end;\n                        a.end = a.begin, a.begin = d;\n                    }\n                    var p, h = o.getLastValidPosition.call(u, void 0, !0);\n                    a.end >= o.getBuffer.call(u).length && h >= a.end && (a.end = h + 1);\n                    t === r.default.BACKSPACE ? a.end - a.begin < 1 && (a.begin = o.seekPrevious.call(u, a.begin)) : t === r.default.DELETE && a.begin === a.end && (a.end = o.isMask.call(u, a.end, !0, !0) ? a.end + 1 : o.seekNext.call(u, a.end) + 1);\n                    if (!1 !== (p = v.call(u, a))) {\n                        if (!0 !== i && !1 !== f.keepStatic || null !== f.regex && -1 !== n.getTest.call(u, a.begin).match.def.indexOf(\"|\")) {\n                            var m = l.call(u, !0);\n                            if (m) {\n                                var g = void 0 !== m.caret ? m.caret : m.pos ? o.seekNext.call(u, m.pos.begin ? m.pos.begin : m.pos) : o.getLastValidPosition.call(u, -1, !0);\n                                (t !== r.default.DELETE || a.begin > g) && a.begin;\n                            }\n                        }\n                        !0 !== i && (c.p = t === r.default.DELETE ? a.begin + p : a.begin, c.p = o.determineNewCaretPosition.call(u, {\n                            begin: c.p,\n                            end: c.p\n                        }, !1).begin);\n                    }\n                };\n                var i, n = a(4713), r = (i = a(4528)) && i.__esModule ? i : {\n                    default: i\n                }, o = a(8711), s = a(6030);\n                function l(e, t, a, i, r, s) {\n                    var u, c, d, p, h, v, m, g, k, y, b, x = this, P = this.dependencyLib, E = this.opts, S = x.maskset, _ = P.extend(!0, {}, S.validPositions), M = P.extend(!0, {}, S.tests), w = !1, O = !1, T = void 0 !== r ? r : o.getLastValidPosition.call(x);\n                    if (s && (y = s.begin, b = s.end, s.begin > s.end && (y = s.end, b = s.begin)), \n                    -1 === T && void 0 === r) u = 0, c = (p = n.getTest.call(x, u)).alternation; else for (;T >= 0; T--) if ((d = S.validPositions[T]) && void 0 !== d.alternation) {\n                        if (p && p.locator[d.alternation] !== d.locator[d.alternation]) break;\n                        u = T, c = S.validPositions[u].alternation, p = d;\n                    }\n                    if (void 0 !== c) {\n                        m = parseInt(u), S.excludes[m] = S.excludes[m] || [], !0 !== e && S.excludes[m].push((0, \n                        n.getDecisionTaker)(p) + \":\" + p.alternation);\n                        var C = [], A = -1;\n                        for (h = m; h < o.getLastValidPosition.call(x, void 0, !0) + 1; h++) -1 === A && e <= h && void 0 !== t && (C.push(t), \n                        A = C.length - 1), (v = S.validPositions[h]) && !0 !== v.generatedInput && (void 0 === s || h < y || h >= b) && C.push(v.input), \n                        delete S.validPositions[h];\n                        for (-1 === A && void 0 !== t && (C.push(t), A = C.length - 1); void 0 !== S.excludes[m] && S.excludes[m].length < 10; ) {\n                            for (S.tests = {}, o.resetMaskSet.call(x, !0), w = !0, h = 0; h < C.length && (g = w.caret || o.getLastValidPosition.call(x, void 0, !0) + 1, \n                            k = C[h], w = f.call(x, g, k, !1, i, !0)); h++) h === A && (O = w), 1 == e && w && (O = {\n                                caretPos: h\n                            });\n                            if (w) break;\n                            if (o.resetMaskSet.call(x), p = n.getTest.call(x, m), S.validPositions = P.extend(!0, {}, _), \n                            S.tests = P.extend(!0, {}, M), !S.excludes[m]) {\n                                O = l.call(x, e, t, a, i, m - 1, s);\n                                break;\n                            }\n                            var D = (0, n.getDecisionTaker)(p);\n                            if (-1 !== S.excludes[m].indexOf(D + \":\" + p.alternation)) {\n                                O = l.call(x, e, t, a, i, m - 1, s);\n                                break;\n                            }\n                            for (S.excludes[m].push(D + \":\" + p.alternation), h = m; h < o.getLastValidPosition.call(x, void 0, !0) + 1; h++) delete S.validPositions[h];\n                        }\n                    }\n                    return O && !1 === E.keepStatic || delete S.excludes[m], O;\n                }\n                function u(e, t, a) {\n                    var i = this.opts, n = this.maskset;\n                    switch (i.casing || t.casing) {\n                      case \"upper\":\n                        e = e.toUpperCase();\n                        break;\n\n                      case \"lower\":\n                        e = e.toLowerCase();\n                        break;\n\n                      case \"title\":\n                        var o = n.validPositions[a - 1];\n                        e = 0 === a || o && o.input === String.fromCharCode(r.default.SPACE) ? e.toUpperCase() : e.toLowerCase();\n                        break;\n\n                      default:\n                        if (\"function\" == typeof i.casing) {\n                            var s = Array.prototype.slice.call(arguments);\n                            s.push(n.validPositions), e = i.casing.apply(this, s);\n                        }\n                    }\n                    return e;\n                }\n                function c(e) {\n                    var t = this, a = this.opts, i = this.maskset;\n                    if (\"function\" == typeof a.isComplete) return a.isComplete(e, a);\n                    if (\"*\" !== a.repeat) {\n                        var r = !1, s = o.determineLastRequiredPosition.call(t, !0), l = o.seekPrevious.call(t, s.l);\n                        if (void 0 === s.def || s.def.newBlockMarker || s.def.optionality || s.def.optionalQuantifier) {\n                            r = !0;\n                            for (var u = 0; u <= l; u++) {\n                                var c = n.getTestTemplate.call(t, u).match;\n                                if (!0 !== c.static && void 0 === i.validPositions[u] && !0 !== c.optionality && !0 !== c.optionalQuantifier || !0 === c.static && e[u] !== n.getPlaceholder.call(t, u, c)) {\n                                    r = !1;\n                                    break;\n                                }\n                            }\n                        }\n                        return r;\n                    }\n                }\n                function f(e, t, a, i, r, s, d) {\n                    var m = this, g = this.dependencyLib, k = this.opts, y = m.maskset;\n                    function b(e) {\n                        return m.isRTL ? e.begin - e.end > 1 || e.begin - e.end == 1 : e.end - e.begin > 1 || e.end - e.begin == 1;\n                    }\n                    a = !0 === a;\n                    var x = e;\n                    function P(e) {\n                        if (void 0 !== e) {\n                            if (void 0 !== e.remove && (Array.isArray(e.remove) || (e.remove = [ e.remove ]), \n                            e.remove.sort((function(e, t) {\n                                return t.pos - e.pos;\n                            })).forEach((function(e) {\n                                v.call(m, {\n                                    begin: e,\n                                    end: e + 1\n                                });\n                            })), e.remove = void 0), void 0 !== e.insert && (Array.isArray(e.insert) || (e.insert = [ e.insert ]), \n                            e.insert.sort((function(e, t) {\n                                return e.pos - t.pos;\n                            })).forEach((function(e) {\n                                \"\" !== e.c && f.call(m, e.pos, e.c, void 0 === e.strict || e.strict, void 0 !== e.fromIsValid ? e.fromIsValid : i);\n                            })), e.insert = void 0), e.refreshFromBuffer && e.buffer) {\n                                var t = e.refreshFromBuffer;\n                                p.call(m, !0 === t ? t : t.start, t.end, e.buffer), e.refreshFromBuffer = void 0;\n                            }\n                            void 0 !== e.rewritePosition && (x = e.rewritePosition, e = !0);\n                        }\n                        return e;\n                    }\n                    function E(t, a, r) {\n                        var s = !1;\n                        return n.getTests.call(m, t).every((function(l, c) {\n                            var f = l.match;\n                            if (o.getBuffer.call(m, !0), !1 !== (s = (!f.jit || void 0 !== y.validPositions[o.seekPrevious.call(m, t)]) && (null != f.fn ? f.fn.test(a, y, t, r, k, b(e)) : (a === f.def || a === k.skipOptionalPartCharacter) && \"\" !== f.def && {\n                                c: n.getPlaceholder.call(m, t, f, !0) || f.def,\n                                pos: t\n                            }))) {\n                                var d = void 0 !== s.c ? s.c : a, p = t;\n                                return d = d === k.skipOptionalPartCharacter && !0 === f.static ? n.getPlaceholder.call(m, t, f, !0) || f.def : d, \n                                !0 !== (s = P(s)) && void 0 !== s.pos && s.pos !== t && (p = s.pos), !0 !== s && void 0 === s.pos && void 0 === s.c ? !1 : (!1 === v.call(m, e, g.extend({}, l, {\n                                    input: u.call(m, d, f, p)\n                                }), i, p) && (s = !1), !1);\n                            }\n                            return !0;\n                        })), s;\n                    }\n                    void 0 !== e.begin && (x = m.isRTL ? e.end : e.begin);\n                    var S = !0, _ = g.extend(!0, {}, y.validPositions);\n                    if (!1 === k.keepStatic && void 0 !== y.excludes[x] && !0 !== r && !0 !== i) for (var M = x; M < (m.isRTL ? e.begin : e.end); M++) void 0 !== y.excludes[M] && (y.excludes[M] = void 0, \n                    delete y.tests[M]);\n                    if (\"function\" == typeof k.preValidation && !0 !== i && !0 !== s && (S = P(S = k.preValidation.call(m, o.getBuffer.call(m), x, t, b(e), k, y, e, a || r))), \n                    !0 === S) {\n                        if (S = E(x, t, a), (!a || !0 === i) && !1 === S && !0 !== s) {\n                            var w = y.validPositions[x];\n                            if (!w || !0 !== w.match.static || w.match.def !== t && t !== k.skipOptionalPartCharacter) {\n                                if (k.insertMode || void 0 === y.validPositions[o.seekNext.call(m, x)] || e.end > x) {\n                                    var O = !1;\n                                    if (y.jitOffset[x] && void 0 === y.validPositions[o.seekNext.call(m, x)] && !1 !== (S = f.call(m, x + y.jitOffset[x], t, !0, !0)) && (!0 !== r && (S.caret = x), \n                                    O = !0), e.end > x && (y.validPositions[x] = void 0), !O && !o.isMask.call(m, x, k.keepStatic && 0 === x)) for (var T = x + 1, C = o.seekNext.call(m, x, !1, 0 !== x); T <= C; T++) if (!1 !== (S = E(T, t, a))) {\n                                        S = h.call(m, x, void 0 !== S.pos ? S.pos : T) || S, x = T;\n                                        break;\n                                    }\n                                }\n                            } else S = {\n                                caret: o.seekNext.call(m, x)\n                            };\n                        }\n                        !1 !== S || !k.keepStatic || !c.call(m, o.getBuffer.call(m)) && 0 !== x || a || !0 === r ? b(e) && y.tests[x] && y.tests[x].length > 1 && k.keepStatic && !a && !0 !== r && (S = l.call(m, !0)) : S = l.call(m, x, t, a, i, void 0, e), \n                        !0 === S && (S = {\n                            pos: x\n                        });\n                    }\n                    if (\"function\" == typeof k.postValidation && !0 !== i && !0 !== s) {\n                        var A = k.postValidation.call(m, o.getBuffer.call(m, !0), void 0 !== e.begin ? m.isRTL ? e.end : e.begin : e, t, S, k, y, a, d);\n                        void 0 !== A && (S = !0 === A ? S : A);\n                    }\n                    S && void 0 === S.pos && (S.pos = x), !1 === S || !0 === s ? (o.resetMaskSet.call(m, !0), \n                    y.validPositions = g.extend(!0, {}, _)) : h.call(m, void 0, x, !0);\n                    var D = P(S);\n                    void 0 !== m.maxLength && (o.getBuffer.call(m).length > m.maxLength && !i && (o.resetMaskSet.call(m, !0), \n                    y.validPositions = g.extend(!0, {}, _), D = !1));\n                    return D;\n                }\n                function d(e, t, a) {\n                    for (var i = this.maskset, r = !1, o = n.getTests.call(this, e), s = 0; s < o.length; s++) {\n                        if (o[s].match && (o[s].match.nativeDef === t.match[a.shiftPositions ? \"def\" : \"nativeDef\"] && (!a.shiftPositions || !t.match.static) || o[s].match.nativeDef === t.match.nativeDef || a.regex && !o[s].match.static && o[s].match.fn.test(t.input))) {\n                            r = !0;\n                            break;\n                        }\n                        if (o[s].match && o[s].match.def === t.match.nativeDef) {\n                            r = void 0;\n                            break;\n                        }\n                    }\n                    return !1 === r && void 0 !== i.jitOffset[e] && (r = d.call(this, e + i.jitOffset[e], t, a)), \n                    r;\n                }\n                function p(e, t, a) {\n                    var i, n, r = this, l = this.maskset, u = this.opts, c = this.dependencyLib, f = u.skipOptionalPartCharacter, d = r.isRTL ? a.slice().reverse() : a;\n                    if (u.skipOptionalPartCharacter = \"\", !0 === e) o.resetMaskSet.call(r), l.tests = {}, \n                    e = 0, t = a.length, n = o.determineNewCaretPosition.call(r, {\n                        begin: 0,\n                        end: 0\n                    }, !1).begin; else {\n                        for (i = e; i < t; i++) delete l.validPositions[i];\n                        n = e;\n                    }\n                    var p = new c.Event(\"keypress\");\n                    for (i = e; i < t; i++) {\n                        p.which = d[i].toString().charCodeAt(0), r.ignorable = !1;\n                        var h = s.EventHandlers.keypressEvent.call(r, p, !0, !1, !1, n);\n                        !1 !== h && void 0 !== h && (n = h.forwardPosition);\n                    }\n                    u.skipOptionalPartCharacter = f;\n                }\n                function h(e, t, a) {\n                    var i = this, r = this.maskset, s = this.dependencyLib;\n                    if (void 0 === e) for (e = t - 1; e > 0 && !r.validPositions[e]; e--) ;\n                    for (var l = e; l < t; l++) {\n                        if (void 0 === r.validPositions[l] && !o.isMask.call(i, l, !1)) if (0 == l ? n.getTest.call(i, l) : r.validPositions[l - 1]) {\n                            var u = n.getTests.call(i, l).slice();\n                            \"\" === u[u.length - 1].match.def && u.pop();\n                            var c, d = n.determineTestTemplate.call(i, l, u);\n                            if (d && (!0 !== d.match.jit || \"master\" === d.match.newBlockMarker && (c = r.validPositions[l + 1]) && !0 === c.match.optionalQuantifier) && ((d = s.extend({}, d, {\n                                input: n.getPlaceholder.call(i, l, d.match, !0) || d.match.def\n                            })).generatedInput = !0, v.call(i, l, d, !0), !0 !== a)) {\n                                var p = r.validPositions[t].input;\n                                return r.validPositions[t] = void 0, f.call(i, t, p, !0, !0);\n                            }\n                        }\n                    }\n                }\n                function v(e, t, a, i) {\n                    var r = this, s = this.maskset, l = this.opts, u = this.dependencyLib;\n                    function c(e, t, a) {\n                        var i = t[e];\n                        if (void 0 !== i && !0 === i.match.static && !0 !== i.match.optionality && (void 0 === t[0] || void 0 === t[0].alternation)) {\n                            var n = a.begin <= e - 1 ? t[e - 1] && !0 === t[e - 1].match.static && t[e - 1] : t[e - 1], r = a.end > e + 1 ? t[e + 1] && !0 === t[e + 1].match.static && t[e + 1] : t[e + 1];\n                            return n && r;\n                        }\n                        return !1;\n                    }\n                    var p = 0, h = void 0 !== e.begin ? e.begin : e, v = void 0 !== e.end ? e.end : e, m = !0;\n                    if (e.begin > e.end && (h = e.end, v = e.begin), i = void 0 !== i ? i : h, h !== v || l.insertMode && void 0 !== s.validPositions[i] && void 0 === a || void 0 === t) {\n                        var g, k = u.extend(!0, {}, s.validPositions), y = o.getLastValidPosition.call(r, void 0, !0);\n                        for (s.p = h, g = y; g >= h; g--) delete s.validPositions[g], void 0 === t && delete s.tests[g + 1];\n                        var b, x, P = i, E = P;\n                        for (t && (s.validPositions[i] = u.extend(!0, {}, t), E++, P++), g = t ? v : v - 1; g <= y; g++) {\n                            if (void 0 !== (b = k[g]) && !0 !== b.generatedInput && (g >= v || g >= h && c(g, k, {\n                                begin: h,\n                                end: v\n                            }))) {\n                                for (;\"\" !== n.getTest.call(r, E).match.def; ) {\n                                    if (!1 !== (x = d.call(r, E, b, l)) || \"+\" === b.match.def) {\n                                        \"+\" === b.match.def && o.getBuffer.call(r, !0);\n                                        var S = f.call(r, E, b.input, \"+\" !== b.match.def, !0);\n                                        if (m = !1 !== S, P = (S.pos || E) + 1, !m && x) break;\n                                    } else m = !1;\n                                    if (m) {\n                                        void 0 === t && b.match.static && g === e.begin && p++;\n                                        break;\n                                    }\n                                    if (!m && E > s.maskLength) break;\n                                    E++;\n                                }\n                                \"\" == n.getTest.call(r, E).match.def && (m = !1), E = P;\n                            }\n                            if (!m) break;\n                        }\n                        if (!m) return s.validPositions = u.extend(!0, {}, k), o.resetMaskSet.call(r, !0), \n                        !1;\n                    } else t && n.getTest.call(r, i).match.cd === t.match.cd && (s.validPositions[i] = u.extend(!0, {}, t));\n                    return o.resetMaskSet.call(r, !0), p;\n                }\n            }\n        }, t = {};\n        function a(i) {\n            var n = t[i];\n            if (void 0 !== n) return n.exports;\n            var r = t[i] = {\n                exports: {}\n            };\n            return e[i](r, r.exports, a), r.exports;\n        }\n        var i = {};\n        return function() {\n            var e, t = i;\n            Object.defineProperty(t, \"__esModule\", {\n                value: !0\n            }), t.default = void 0, a(3851), a(219), a(207), a(5296);\n            var n = ((e = a(2394)) && e.__esModule ? e : {\n                default: e\n            }).default;\n            t.default = n;\n        }(), i;\n    }();\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5wdXRtYXNrL2Rpc3QvaW5wdXRtYXNrLmpzPzI1MjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBdUQsdUJBQXVCLE1BQU0sYUFHdkY7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNFJBQTRSO0FBQ3JVLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLCtDQUErQztBQUMvQyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7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QUF5RTtBQUN6RTtBQUNBLHFCQUFxQixpR0FBaUc7QUFDdEg7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW5wdXRtYXNrL2Rpc3QvaW5wdXRtYXNrLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBkaXN0L2lucHV0bWFza1xuICogaHR0cHM6Ly9naXRodWIuY29tL1JvYmluSGVyYm90cy9JbnB1dG1hc2tcbiAqIENvcHlyaWdodCAoYykgMjAxMCAtIDIwMjEgUm9iaW4gSGVyYm90c1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBWZXJzaW9uOiA1LjAuNlxuICovXG4hZnVuY3Rpb24oZSwgdCkge1xuICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG1vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSB0KCk7IGVsc2UgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQpIGRlZmluZShbXSwgdCk7IGVsc2Uge1xuICAgICAgICB2YXIgYSA9IHQoKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBhKSAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyA/IGV4cG9ydHMgOiBlKVtpXSA9IGFbaV07XG4gICAgfVxufSh0aGlzLCAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgICA0NTI4OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZS5leHBvcnRzID0gSlNPTi5wYXJzZSgne1wiQkFDS1NQQUNFXCI6OCxcIkJBQ0tTUEFDRV9TQUZBUklcIjoxMjcsXCJERUxFVEVcIjo0NixcIkRPV05cIjo0MCxcIkVORFwiOjM1LFwiRU5URVJcIjoxMyxcIkVTQ0FQRVwiOjI3LFwiSE9NRVwiOjM2LFwiSU5TRVJUXCI6NDUsXCJMRUZUXCI6MzcsXCJQQUdFX0RPV05cIjozNCxcIlBBR0VfVVBcIjozMyxcIlJJR0hUXCI6MzksXCJTUEFDRVwiOjMyLFwiVEFCXCI6OSxcIlVQXCI6MzgsXCJYXCI6ODgsXCJaXCI6OTAsXCJDT05UUk9MXCI6MTcsXCJQQVVTRS9CUkVBS1wiOjE5LFwiV0lORE9XU19MRUZUXCI6OTEsXCJXSU5ET1dTX1JJR0hUXCI6OTIsXCJLRVlfMjI5XCI6MjI5fScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDg3NDE6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgYSA9ICEoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2Ygd2luZG93IHx8ICF3aW5kb3cuZG9jdW1lbnQgfHwgIXdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0LmRlZmF1bHQgPSBhO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDM5NzY6IGZ1bmN0aW9uKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgaSwgbiA9IChpID0gYSg0NTI4KSkgJiYgaS5fX2VzTW9kdWxlID8gaSA6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogaVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIF9tYXhUZXN0UG9zOiA1MDAsXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIl9cIixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxtYXJrZXI6IFsgXCJbXCIsIFwiXVwiIF0sXG4gICAgICAgICAgICAgICAgICAgIHF1YW50aWZpZXJtYXJrZXI6IFsgXCJ7XCIsIFwifVwiIF0sXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwbWFya2VyOiBbIFwiKFwiLCBcIilcIiBdLFxuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdG9ybWFya2VyOiBcInxcIixcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlQ2hhcjogXCJcXFxcXCIsXG4gICAgICAgICAgICAgICAgICAgIG1hc2s6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBvbmNvbXBsZXRlOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgICAgICAgICBvbmluY29tcGxldGU6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgICAgICAgICAgICAgIG9uY2xlYXJlZDogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0OiAwLFxuICAgICAgICAgICAgICAgICAgICBncmVlZHk6ICExLFxuICAgICAgICAgICAgICAgICAgICBhdXRvVW5tYXNrOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTWFza09uU3VibWl0OiAhMSxcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJNYXNrT25Mb3N0Rm9jdXM6ICEwLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRNb2RlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0TW9kZVZpc3VhbDogITAsXG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW5jb21wbGV0ZTogITEsXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBvbktleURvd246IGZ1bmN0aW9uKCkge30sXG4gICAgICAgICAgICAgICAgICAgIG9uQmVmb3JlTWFzazogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgb25CZWZvcmVQYXN0ZTogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdC5vbkJlZm9yZU1hc2sgPyB0Lm9uQmVmb3JlTWFzay5jYWxsKHRoaXMsIGUsIHQpIDogZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25CZWZvcmVXcml0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgb25Vbk1hc2s6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNob3dNYXNrT25Gb2N1czogITAsXG4gICAgICAgICAgICAgICAgICAgIHNob3dNYXNrT25Ib3ZlcjogITAsXG4gICAgICAgICAgICAgICAgICAgIG9uS2V5VmFsaWRhdGlvbjogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlcjogXCIgXCIsXG4gICAgICAgICAgICAgICAgICAgIG51bWVyaWNJbnB1dDogITEsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0QWxpZ246ICExLFxuICAgICAgICAgICAgICAgICAgICB1bmRvT25Fc2NhcGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICByYWRpeFBvaW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBfcmFkaXhEYW5jZTogITEsXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwU2VwYXJhdG9yOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBrZWVwU3RhdGljOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkNhcmV0T25UYWI6ICEwLFxuICAgICAgICAgICAgICAgICAgICB0YWJUaHJvdWdoOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydHNJbnB1dFR5cGU6IFsgXCJ0ZXh0XCIsIFwidGVsXCIsIFwidXJsXCIsIFwicGFzc3dvcmRcIiwgXCJzZWFyY2hcIiBdLFxuICAgICAgICAgICAgICAgICAgICBpZ25vcmFibGVzOiBbIG4uZGVmYXVsdC5CQUNLU1BBQ0UsIG4uZGVmYXVsdC5UQUIsIG4uZGVmYXVsdFtcIlBBVVNFL0JSRUFLXCJdLCBuLmRlZmF1bHQuRVNDQVBFLCBuLmRlZmF1bHQuUEFHRV9VUCwgbi5kZWZhdWx0LlBBR0VfRE9XTiwgbi5kZWZhdWx0LkVORCwgbi5kZWZhdWx0LkhPTUUsIG4uZGVmYXVsdC5MRUZULCBuLmRlZmF1bHQuVVAsIG4uZGVmYXVsdC5SSUdIVCwgbi5kZWZhdWx0LkRPV04sIG4uZGVmYXVsdC5JTlNFUlQsIG4uZGVmYXVsdC5ERUxFVEUsIDkzLCAxMTIsIDExMywgMTE0LCAxMTUsIDExNiwgMTE3LCAxMTgsIDExOSwgMTIwLCAxMjEsIDEyMiwgMTIzLCAwLCAyMjkgXSxcbiAgICAgICAgICAgICAgICAgICAgaXNDb21wbGV0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcHJlVmFsaWRhdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcG9zdFZhbGlkYXRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY0RlZmluaXRpb25TeW1ib2w6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgaml0TWFza2luZzogITEsXG4gICAgICAgICAgICAgICAgICAgIG51bGxhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRFdmVudE9ubHk6ICExLFxuICAgICAgICAgICAgICAgICAgICBub1ZhbHVlUGF0Y2hpbmc6ICExLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkNhcmV0T25DbGljazogXCJsdnBcIixcbiAgICAgICAgICAgICAgICAgICAgY2FzaW5nOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dG1vZGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICBpbXBvcnREYXRhQXR0cmlidXRlczogITAsXG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0UG9zaXRpb25zOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgdXNlUHJvdG90eXBlRGVmaW5pdGlvbnM6ICEwLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRXZlbnRUaW1lT3V0OiAzZTNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHQuZGVmYXVsdCA9IHI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgNzM5MjogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICAgICAgICB9KSwgdC5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHQuZGVmYXVsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgOToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBcIlswLTlcXHVmZjEwLVxcdWZmMTldXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uU3ltYm9sOiBcIipcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IFwiW0EtWmEtelxcdTA0MTAtXFx1MDQ0ZlxcdTA0MDFcXHUwNDUxXFx4YzAtXFx4ZmZcXHhiNV1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25TeW1ib2w6IFwiKlwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiKlwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IFwiWzAtOVxcdWZmMTAtXFx1ZmYxOUEtWmEtelxcdTA0MTAtXFx1MDQ0ZlxcdTA0MDFcXHUwNDUxXFx4YzAtXFx4ZmZcXHhiNV1cIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAyNTM6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQuZGVmYXVsdCA9IGZ1bmN0aW9uKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYSkgcmV0dXJuIGUuX19kYXRhID8gZS5fX2RhdGFbdF0gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBlLl9fZGF0YSA9IGUuX19kYXRhIHx8IHt9LCBlLl9fZGF0YVt0XSA9IGE7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAzNzc2OiBmdW5jdGlvbihlLCB0LCBhKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0Lm9uID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhKGUsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4uYWRkRXZlbnRMaXN0ZW5lciA/IG4uYWRkRXZlbnRMaXN0ZW5lcihlLCB0LCAhMSkgOiBuLmF0dGFjaEV2ZW50ICYmIG4uYXR0YWNoRXZlbnQoXCJvblwiICsgZSwgdCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgaVtlXSA9IGlbZV0gfHwge30sIGlbZV1bYV0gPSBpW2VdW2FdIHx8IFtdLCBpW2VdW2FdLnB1c2godCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHUodGhpc1swXSkpIGZvciAodmFyIGkgPSB0aGlzWzBdLmV2ZW50UmVnaXN0cnksIG4gPSB0aGlzWzBdLCByID0gZS5zcGxpdChcIiBcIiksIG8gPSAwOyBvIDwgci5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSByW29dLnNwbGl0KFwiLlwiKSwgbCA9IHNbMF0sIGMgPSBzWzFdIHx8IFwiZ2xvYmFsXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBhKGwsIGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0sIHQub2ZmID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSwgaTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbihlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbiBhID09ICEwKSBpZiAoaS5yZW1vdmVFdmVudExpc3RlbmVyID8gaS5yZW1vdmVFdmVudExpc3RlbmVyKGUsIG4sICExKSA6IGkuZGV0YWNoRXZlbnQgJiYgaS5kZXRhY2hFdmVudChcIm9uXCIgKyBlLCBuKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBcImdsb2JhbFwiID09PSB0KSBmb3IgKHZhciByIGluIGFbZV0pIGFbZV1bcl0uc3BsaWNlKGFbZV1bcl0uaW5kZXhPZihuKSwgMSk7IGVsc2UgYVtlXVt0XS5zcGxpY2UoYVtlXVt0XS5pbmRleE9mKG4pLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByKGUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuLCByLCBvID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5sZW5ndGggPiAwKSBpZiAodm9pZCAwID09PSB0KSBmb3IgKG4gPSAwLCByID0gYVtlXVtpXS5sZW5ndGg7IG4gPCByOyBuKyspIG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXY6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBpICYmIGkubGVuZ3RoID4gMCA/IGkgOiBcImdsb2JhbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IGFbZV1baV1bbl1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyBlbHNlIG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXY6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBpICYmIGkubGVuZ3RoID4gMCA/IGkgOiBcImdsb2JhbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyBlbHNlIGlmIChpLmxlbmd0aCA+IDApIGZvciAodmFyIHMgaW4gYSkgZm9yICh2YXIgbCBpbiBhW3NdKSBpZiAobCA9PT0gaSkgaWYgKHZvaWQgMCA9PT0gdCkgZm9yIChuID0gMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gYVtzXVtsXS5sZW5ndGg7IG4gPCByOyBuKyspIG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXY6IHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IGFbc11bbF1bbl1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyBlbHNlIG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXY6IHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHUodGhpc1swXSkgJiYgZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHRoaXNbMF0uZXZlbnRSZWdpc3RyeSwgaSA9IHRoaXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvID0gZS5zcGxpdChcIiBcIiksIHMgPSAwOyBzIDwgby5sZW5ndGg7IHMrKykgZm9yICh2YXIgbCA9IG9bc10uc3BsaXQoXCIuXCIpLCBjID0gcihsWzBdLCBsWzFdKSwgZiA9IDAsIGQgPSBjLmxlbmd0aDsgZiA8IGQ7IGYrKykgbihjW2ZdLmV2LCBjW2ZdLm5hbWVzcGFjZSwgY1tmXS5oYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LCB0LnRyaWdnZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1KHRoaXNbMF0pKSBmb3IgKHZhciB0ID0gdGhpc1swXS5ldmVudFJlZ2lzdHJ5LCBhID0gdGhpc1swXSwgaSA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBlLnNwbGl0KFwiIFwiKSA6IFsgZS50eXBlIF0sIHIgPSAwOyByIDwgaS5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBpW3JdLnNwbGl0KFwiLlwiKSwgbCA9IHNbMF0sIGMgPSBzWzFdIHx8IFwiZ2xvYmFsXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBkb2N1bWVudCAmJiBcImdsb2JhbFwiID09PSBjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYsIGQsIHAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiBhcmd1bWVudHNbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5wdXRUeXBlID0gXCJpbnNlcnRUZXh0XCIsIGYgPSBuZXcgSW5wdXRFdmVudChsLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBuZXcgQ3VzdG9tRXZlbnQobCwgcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKSkuaW5pdEN1c3RvbUV2ZW50KGwsIHAuYnViYmxlcywgcC5jYW5jZWxhYmxlLCBwLmRldGFpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS50eXBlICYmICgwLCBuLmRlZmF1bHQpKGYsIGUpLCBhLmRpc3BhdGNoRXZlbnQoZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIChmID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKSkuZXZlbnRUeXBlID0gbCwgZi5kZXRhaWwgPSBhcmd1bWVudHNbMV0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUudHlwZSAmJiAoMCwgbi5kZWZhdWx0KShmLCBlKSwgYS5maXJlRXZlbnQoXCJvblwiICsgZi5ldmVudFR5cGUsIGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2b2lkIDAgIT09IHRbbF0pIGlmIChhcmd1bWVudHNbMF0gPSBhcmd1bWVudHNbMF0udHlwZSA/IGFyZ3VtZW50c1swXSA6IG8uZGVmYXVsdC5FdmVudChhcmd1bWVudHNbMF0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c1swXS5kZXRhaWwgPSBhcmd1bWVudHMuc2xpY2UoMSksIFwiZ2xvYmFsXCIgPT09IGMpIGZvciAodmFyIGggaW4gdFtsXSkgZm9yIChkID0gMDsgZCA8IHRbbF1baF0ubGVuZ3RoOyBkKyspIHRbbF1baF1bZF0uYXBwbHkoYSwgYXJndW1lbnRzKTsgZWxzZSBmb3IgKGQgPSAwOyBkIDwgdFtsXVtjXS5sZW5ndGg7IGQrKykgdFtsXVtjXVtkXS5hcHBseShhLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0sIHQuRXZlbnQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGksIG4gPSBsKGEoNjAwKSksIHIgPSBsKGEoOTM4MCkpLCBvID0gbChhKDQ5NjMpKSwgcyA9IGwoYSg4NzQxKSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHUoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQuRXZlbnQgPSBpLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHIuZGVmYXVsdC5DdXN0b21FdmVudCA/IHQuRXZlbnQgPSBpID0gci5kZWZhdWx0LkN1c3RvbUV2ZW50IDogcy5kZWZhdWx0ICYmICh0LkV2ZW50ID0gaSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IHQgfHwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlczogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5pdEN1c3RvbUV2ZW50KGUsIHQuYnViYmxlcywgdC5jYW5jZWxhYmxlLCB0LmRldGFpbCksIGE7XG4gICAgICAgICAgICAgICAgfSwgaS5wcm90b3R5cGUgPSByLmRlZmF1bHQuRXZlbnQucHJvdG90eXBlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA2MDA6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlO1xuICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgZS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGUgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIGU7XG4gICAgICAgICAgICAgICAgICAgIH0pKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQuZGVmYXVsdCA9IGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0LCBpLCBuLCByLCBvLCBzLCBsID0gYXJndW1lbnRzWzBdIHx8IHt9LCB1ID0gMSwgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIGYgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgXCJib29sZWFuXCIgPT0gdHlwZW9mIGwgJiYgKGYgPSBsLCBsID0gYXJndW1lbnRzW3VdIHx8IHt9LCB1KyspO1xuICAgICAgICAgICAgICAgICAgICBcIm9iamVjdFwiICE9PSBhKGwpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgbCAmJiAobCA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7dSA8IGM7IHUrKykgaWYgKG51bGwgIT0gKHQgPSBhcmd1bWVudHNbdV0pKSBmb3IgKGkgaW4gdCkgbiA9IGxbaV0sIHIgPSB0W2ldLCBcbiAgICAgICAgICAgICAgICAgICAgbCAhPT0gciAmJiAoZiAmJiByICYmIChcIltvYmplY3QgT2JqZWN0XVwiID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocikgfHwgKG8gPSBBcnJheS5pc0FycmF5KHIpKSkgPyAobyA/IChvID0gITEsIFxuICAgICAgICAgICAgICAgICAgICBzID0gbiAmJiBBcnJheS5pc0FycmF5KG4pID8gbiA6IFtdKSA6IHMgPSBuICYmIFwiW29iamVjdCBPYmplY3RdXCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuKSA/IG4gOiB7fSwgXG4gICAgICAgICAgICAgICAgICAgIGxbaV0gPSBlKGYsIHMsIHIpKSA6IHZvaWQgMCAhPT0gciAmJiAobFtpXSA9IHIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA0OTYzOiBmdW5jdGlvbihlLCB0LCBhKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBzKGEoNjAwKSksIG4gPSBzKGEoOTM4MCkpLCByID0gcyhhKDI1MykpLCBvID0gYSgzNzc2KTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBuLmRlZmF1bHQuZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdShlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgdSA/IGUgOiB0aGlzIGluc3RhbmNlb2YgdSA/IHZvaWQgKG51bGwgIT0gZSAmJiBlICE9PSBuLmRlZmF1bHQgJiYgKHRoaXNbMF0gPSBlLm5vZGVOYW1lID8gZSA6IHZvaWQgMCAhPT0gZVswXSAmJiBlWzBdLm5vZGVOYW1lID8gZVswXSA6IGwucXVlcnlTZWxlY3RvcihlKSwgXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gdGhpc1swXSAmJiBudWxsICE9PSB0aGlzWzBdICYmICh0aGlzWzBdLmV2ZW50UmVnaXN0cnkgPSB0aGlzWzBdLmV2ZW50UmVnaXN0cnkgfHwge30pKSkgOiBuZXcgdShlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdS5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9uOiBvLm9uLFxuICAgICAgICAgICAgICAgICAgICBvZmY6IG8ub2ZmLFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyOiBvLnRyaWdnZXJcbiAgICAgICAgICAgICAgICB9LCB1LmV4dGVuZCA9IGkuZGVmYXVsdCwgdS5kYXRhID0gci5kZWZhdWx0LCB1LkV2ZW50ID0gby5FdmVudDtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHU7XG4gICAgICAgICAgICAgICAgdC5kZWZhdWx0ID0gYztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA5ODQ1OiBmdW5jdGlvbihlLCB0LCBhKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmlwaG9uZSA9IHQuaWVtb2JpbGUgPSB0Lm1vYmlsZSA9IHQuaWUgPSB0LnVhID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBpLCBuID0gKGkgPSBhKDkzODApKSAmJiBpLl9fZXNNb2R1bGUgPyBpIDoge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgciA9IG4uZGVmYXVsdC5uYXZpZ2F0b3IgJiYgbi5kZWZhdWx0Lm5hdmlnYXRvci51c2VyQWdlbnQgfHwgXCJcIiwgbyA9IHIuaW5kZXhPZihcIk1TSUUgXCIpID4gMCB8fCByLmluZGV4T2YoXCJUcmlkZW50L1wiKSA+IDAsIHMgPSBcIm9udG91Y2hzdGFydFwiIGluIG4uZGVmYXVsdCwgbCA9IC9pZW1vYmlsZS9pLnRlc3QociksIHUgPSAvaXBob25lL2kudGVzdChyKSAmJiAhbDtcbiAgICAgICAgICAgICAgICB0LmlwaG9uZSA9IHUsIHQuaWVtb2JpbGUgPSBsLCB0Lm1vYmlsZSA9IHMsIHQuaWUgPSBvLCB0LnVhID0gcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA3MTg0OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmRlZmF1bHQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnJlcGxhY2UoYSwgXCJcXFxcJDFcIik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IG5ldyBSZWdFeHAoXCIoXFxcXFwiICsgWyBcIi9cIiwgXCIuXCIsIFwiKlwiLCBcIitcIiwgXCI/XCIsIFwifFwiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIsIFwifVwiLCBcIlxcXFxcIiwgXCIkXCIsIFwiXlwiIF0uam9pbihcInxcXFxcXCIpICsgXCIpXCIsIFwiZ2ltXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDYwMzA6IGZ1bmN0aW9uKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQuRXZlbnRIYW5kbGVycyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgaSwgbiA9IGEoODcxMSksIHIgPSAoaSA9IGEoNDUyOCkpICYmIGkuX19lc01vZHVsZSA/IGkgOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGlcbiAgICAgICAgICAgICAgICB9LCBvID0gYSg5ODQ1KSwgcyA9IGEoNzIxNSksIGwgPSBhKDc3NjApLCB1ID0gYSg0NzEzKTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHtcbiAgICAgICAgICAgICAgICAgICAga2V5ZG93bkV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuaW5wdXRtYXNrLCBhID0gdC5vcHRzLCBpID0gdC5kZXBlbmRlbmN5TGliLCBjID0gdC5tYXNrc2V0LCBmID0gdGhpcywgZCA9IGkoZiksIHAgPSBlLmtleUNvZGUsIGggPSBuLmNhcmV0LmNhbGwodCwgZiksIHYgPSBhLm9uS2V5RG93bi5jYWxsKHRoaXMsIGUsIG4uZ2V0QnVmZmVyLmNhbGwodCksIGgsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gdikgcmV0dXJuIHY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocCA9PT0gci5kZWZhdWx0LkJBQ0tTUEFDRSB8fCBwID09PSByLmRlZmF1bHQuREVMRVRFIHx8IG8uaXBob25lICYmIHAgPT09IHIuZGVmYXVsdC5CQUNLU1BBQ0VfU0FGQVJJIHx8IGUuY3RybEtleSAmJiBwID09PSByLmRlZmF1bHQuWCAmJiAhKFwib25jdXRcIiBpbiBmKSkgZS5wcmV2ZW50RGVmYXVsdCgpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuaGFuZGxlUmVtb3ZlLmNhbGwodCwgZiwgcCwgaCksICgwLCBsLndyaXRlQnVmZmVyKShmLCBuLmdldEJ1ZmZlci5jYWxsKHQsICEwKSwgYy5wLCBlLCBmLmlucHV0bWFzay5fdmFsdWVHZXQoKSAhPT0gbi5nZXRCdWZmZXIuY2FsbCh0KS5qb2luKFwiXCIpKTsgZWxzZSBpZiAocCA9PT0gci5kZWZhdWx0LkVORCB8fCBwID09PSByLmRlZmF1bHQuUEFHRV9ET1dOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gbi5zZWVrTmV4dC5jYWxsKHQsIG4uZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbCh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5jYXJldC5jYWxsKHQsIGYsIGUuc2hpZnRLZXkgPyBoLmJlZ2luIDogbSwgbSwgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHAgPT09IHIuZGVmYXVsdC5IT01FICYmICFlLnNoaWZ0S2V5IHx8IHAgPT09IHIuZGVmYXVsdC5QQUdFX1VQID8gKGUucHJldmVudERlZmF1bHQoKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBuLmNhcmV0LmNhbGwodCwgZiwgMCwgZS5zaGlmdEtleSA/IGguYmVnaW4gOiAwLCAhMCkpIDogYS51bmRvT25Fc2NhcGUgJiYgcCA9PT0gci5kZWZhdWx0LkVTQ0FQRSAmJiAhMCAhPT0gZS5hbHRLZXkgPyAoKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgbC5jaGVja1ZhbCkoZiwgITAsICExLCB0LnVuZG9WYWx1ZS5zcGxpdChcIlwiKSksIGQudHJpZ2dlcihcImNsaWNrXCIpKSA6ICEwID09PSBhLnRhYlRocm91Z2ggJiYgcCA9PT0gci5kZWZhdWx0LlRBQiA/ICEwID09PSBlLnNoaWZ0S2V5ID8gKGguZW5kID0gbi5zZWVrUHJldmlvdXMuY2FsbCh0LCBoLmVuZCwgITApLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICEwID09PSB1LmdldFRlc3QuY2FsbCh0LCBoLmVuZCAtIDEpLm1hdGNoLnN0YXRpYyAmJiBoLmVuZC0tLCBoLmJlZ2luID0gbi5zZWVrUHJldmlvdXMuY2FsbCh0LCBoLmVuZCwgITApLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGguYmVnaW4gPj0gMCAmJiBoLmVuZCA+IDAgJiYgKGUucHJldmVudERlZmF1bHQoKSwgbi5jYXJldC5jYWxsKHQsIGYsIGguYmVnaW4sIGguZW5kKSkpIDogKGguYmVnaW4gPSBuLnNlZWtOZXh0LmNhbGwodCwgaC5iZWdpbiwgITApLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGguZW5kID0gbi5zZWVrTmV4dC5jYWxsKHQsIGguYmVnaW4sICEwKSwgaC5lbmQgPCBjLm1hc2tMZW5ndGggJiYgaC5lbmQtLSwgaC5iZWdpbiA8PSBjLm1hc2tMZW5ndGggJiYgKGUucHJldmVudERlZmF1bHQoKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBuLmNhcmV0LmNhbGwodCwgZiwgaC5iZWdpbiwgaC5lbmQpKSkgOiBlLnNoaWZ0S2V5IHx8IGEuaW5zZXJ0TW9kZVZpc3VhbCAmJiAhMSA9PT0gYS5pbnNlcnRNb2RlICYmIChwID09PSByLmRlZmF1bHQuUklHSFQgPyBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IG4uY2FyZXQuY2FsbCh0LCBmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLmNhcmV0LmNhbGwodCwgZiwgZS5iZWdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgMCkgOiBwID09PSByLmRlZmF1bHQuTEVGVCAmJiBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IG4udHJhbnNsYXRlUG9zaXRpb24uY2FsbCh0LCBmLmlucHV0bWFzay5jYXJldFBvcy5iZWdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi50cmFuc2xhdGVQb3NpdGlvbi5jYWxsKHQsIGYuaW5wdXRtYXNrLmNhcmV0UG9zLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5pc1JUTCA/IG4uY2FyZXQuY2FsbCh0LCBmLCBlICsgKGUgPT09IGMubWFza0xlbmd0aCA/IDAgOiAxKSkgOiBuLmNhcmV0LmNhbGwodCwgZiwgZSAtICgwID09PSBlID8gMCA6IDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0Lmlnbm9yYWJsZSA9IGEuaWdub3JhYmxlcy5pbmNsdWRlcyhwKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAga2V5cHJlc3NFdmVudDogZnVuY3Rpb24oZSwgdCwgYSwgaSwgbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSB0aGlzLmlucHV0bWFzayB8fCB0aGlzLCBjID0gdS5vcHRzLCBmID0gdS5kZXBlbmRlbmN5TGliLCBkID0gdS5tYXNrc2V0LCBwID0gdS5lbCwgaCA9IGYocCksIHYgPSBlLndoaWNoIHx8IGUuY2hhckNvZGUgfHwgZS5rZXlDb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoITAgPT09IHQgfHwgZS5jdHJsS2V5ICYmIGUuYWx0S2V5KSAmJiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCB1Lmlnbm9yYWJsZSkpIHJldHVybiB2ID09PSByLmRlZmF1bHQuRU5URVIgJiYgdS51bmRvVmFsdWUgIT09IHUuX3ZhbHVlR2V0KCEwKSAmJiAodS51bmRvVmFsdWUgPSB1Ll92YWx1ZUdldCghMCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaC50cmlnZ2VyKFwiY2hhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksIDApKSwgdS5za2lwSW5wdXRFdmVudCA9ICEwLCAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNDQgIT09IHYgJiYgNDYgIT09IHYgfHwgMyAhPT0gZS5sb2NhdGlvbiB8fCBcIlwiID09PSBjLnJhZGl4UG9pbnQgfHwgKHYgPSBjLnJhZGl4UG9pbnQuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0sIGcgPSB0ID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbjogbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6IG4uY2FyZXQuY2FsbCh1LCBwKSwgayA9IFN0cmluZy5mcm9tQ2hhckNvZGUodik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC53cml0ZU91dEJ1ZmZlciA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gcy5pc1ZhbGlkLmNhbGwodSwgZywgaywgaSwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCExICE9PSB5ICYmIChuLnJlc2V0TWFza1NldC5jYWxsKHUsICEwKSwgbSA9IHZvaWQgMCAhPT0geS5jYXJldCA/IHkuY2FyZXQgOiBuLnNlZWtOZXh0LmNhbGwodSwgeS5wb3MuYmVnaW4gPyB5LnBvcy5iZWdpbiA6IHkucG9zKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5wID0gbSksIG0gPSBjLm51bWVyaWNJbnB1dCAmJiB2b2lkIDAgPT09IHkuY2FyZXQgPyBuLnNlZWtQcmV2aW91cy5jYWxsKHUsIG0pIDogbSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgITEgIT09IGEgJiYgKHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLm9uS2V5VmFsaWRhdGlvbi5jYWxsKHAsIHYsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAwKSwgZC53cml0ZU91dEJ1ZmZlciAmJiAhMSAhPT0geSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBuLmdldEJ1ZmZlci5jYWxsKHUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgbC53cml0ZUJ1ZmZlcikocCwgYiwgbSwgZSwgITAgIT09IHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCgpLCB0KSByZXR1cm4gITEgIT09IHkgJiYgKHkuZm9yd2FyZFBvc2l0aW9uID0gbSksIHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGtleXVwRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5pbnB1dG1hc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAhdC5pc0NvbXBvc2luZyB8fCBlLmtleUNvZGUgIT09IHIuZGVmYXVsdC5LRVlfMjI5ICYmIGUua2V5Q29kZSAhPT0gci5kZWZhdWx0LkVOVEVSIHx8IHQuJGVsLnRyaWdnZXIoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFzdGVFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQsIGEgPSB0aGlzLmlucHV0bWFzaywgaSA9IGEub3B0cywgciA9IGEuX3ZhbHVlR2V0KCEwKSwgbyA9IG4uY2FyZXQuY2FsbChhLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuaXNSVEwgJiYgKHQgPSBvLmVuZCwgby5lbmQgPSBvLmJlZ2luLCBvLmJlZ2luID0gdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHIuc3Vic3RyKDAsIG8uYmVnaW4pLCB1ID0gci5zdWJzdHIoby5lbmQsIHIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzID09IChhLmlzUlRMID8gbi5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKGEpLnNsaWNlKCkucmV2ZXJzZSgpIDogbi5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKGEpKS5zbGljZSgwLCBvLmJlZ2luKS5qb2luKFwiXCIpICYmIChzID0gXCJcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgdSA9PSAoYS5pc1JUTCA/IG4uZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChhKS5zbGljZSgpLnJldmVyc2UoKSA6IG4uZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChhKSkuc2xpY2Uoby5lbmQpLmpvaW4oXCJcIikgJiYgKHUgPSBcIlwiKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xpcGJvYXJkRGF0YSAmJiB3aW5kb3cuY2xpcGJvYXJkRGF0YS5nZXREYXRhKSByID0gcyArIHdpbmRvdy5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpICsgdTsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlLmNsaXBib2FyZERhdGEgfHwgIWUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHMgKyBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIikgKyB1O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSByO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaS5vbkJlZm9yZVBhc3RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCExID09PSAoYyA9IGkub25CZWZvcmVQYXN0ZS5jYWxsKGEsIHIsIGkpKSkgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjIHx8IChjID0gcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGwuY2hlY2tWYWwpKHRoaXMsICEwLCAhMSwgYy50b1N0cmluZygpLnNwbGl0KFwiXCIpLCBlKSwgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbnB1dEZhbGxCYWNrRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5pbnB1dG1hc2ssIGEgPSB0Lm9wdHMsIGkgPSB0LmRlcGVuZGVuY3lMaWI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMsIGYgPSBzLmlucHV0bWFzay5fdmFsdWVHZXQoITApLCBkID0gKHQuaXNSVEwgPyBuLmdldEJ1ZmZlci5jYWxsKHQpLnNsaWNlKCkucmV2ZXJzZSgpIDogbi5nZXRCdWZmZXIuY2FsbCh0KSkuam9pbihcIlwiKSwgcCA9IG4uY2FyZXQuY2FsbCh0LCBzLCB2b2lkIDAsIHZvaWQgMCwgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgIT09IGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IGZ1bmN0aW9uKGUsIGksIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbywgcywgbCwgYyA9IGUuc3Vic3RyKDAsIHIuYmVnaW4pLnNwbGl0KFwiXCIpLCBmID0gZS5zdWJzdHIoci5iZWdpbikuc3BsaXQoXCJcIiksIGQgPSBpLnN1YnN0cigwLCByLmJlZ2luKS5zcGxpdChcIlwiKSwgcCA9IGkuc3Vic3RyKHIuYmVnaW4pLnNwbGl0KFwiXCIpLCBoID0gYy5sZW5ndGggPj0gZC5sZW5ndGggPyBjLmxlbmd0aCA6IGQubGVuZ3RoLCB2ID0gZi5sZW5ndGggPj0gcC5sZW5ndGggPyBmLmxlbmd0aCA6IHAubGVuZ3RoLCBtID0gXCJcIiwgZyA9IFtdLCBrID0gXCJ+XCI7IGMubGVuZ3RoIDwgaDsgKSBjLnB1c2goayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoO2QubGVuZ3RoIDwgaDsgKSBkLnB1c2goayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoO2YubGVuZ3RoIDwgdjsgKSBmLnVuc2hpZnQoayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoO3AubGVuZ3RoIDwgdjsgKSBwLnVuc2hpZnQoayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gYy5jb25jYXQoZiksIGIgPSBkLmNvbmNhdChwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChzID0gMCwgbyA9IHkubGVuZ3RoOyBzIDwgbzsgcysrKSBzd2l0Y2ggKGwgPSB1LmdldFBsYWNlaG9sZGVyLmNhbGwodCwgbi50cmFuc2xhdGVQb3NpdGlvbi5jYWxsKHQsIHMpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zZXJ0VGV4dFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYltzIC0gMV0gPT09IHlbc10gJiYgci5iZWdpbiA9PSB5Lmxlbmd0aCAtIDEgJiYgZy5wdXNoKHlbc10pLCBzID0gbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc2VydFJlcGxhY2VtZW50VGV4dFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVDb250ZW50QmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlbc10gPT09IGsgPyByLmVuZCsrIDogcyA9IG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5W3NdICE9PSBiW3NdICYmICh5W3MgKyAxXSAhPT0gayAmJiB5W3MgKyAxXSAhPT0gbCAmJiB2b2lkIDAgIT09IHlbcyArIDFdIHx8IChiW3NdICE9PSBsIHx8IGJbcyArIDFdICE9PSBrKSAmJiBiW3NdICE9PSBrID8gYltzICsgMV0gPT09IGsgJiYgYltzXSA9PT0geVtzICsgMV0gPyAobSA9IFwiaW5zZXJ0VGV4dFwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcucHVzaCh5W3NdKSwgci5iZWdpbi0tLCByLmVuZC0tKSA6IHlbc10gIT09IGwgJiYgeVtzXSAhPT0gayAmJiAoeVtzICsgMV0gPT09IGsgfHwgYltzXSAhPT0geVtzXSAmJiBiW3MgKyAxXSA9PT0geVtzICsgMV0pID8gKG0gPSBcImluc2VydFJlcGxhY2VtZW50VGV4dFwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcucHVzaCh5W3NdKSwgci5iZWdpbi0tKSA6IHlbc10gPT09IGsgPyAobSA9IFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCIsIChuLmlzTWFzay5jYWxsKHQsIG4udHJhbnNsYXRlUG9zaXRpb24uY2FsbCh0LCBzKSwgITApIHx8IGJbc10gPT09IGEucmFkaXhQb2ludCkgJiYgci5lbmQrKykgOiBzID0gbyA6IChtID0gXCJpbnNlcnRUZXh0XCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZy5wdXNoKHlbc10pLCByLmJlZ2luLS0sIHIuZW5kLS0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0OiByXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShmID0gZnVuY3Rpb24oZSwgYSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5pZW1vYmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBhLnJlcGxhY2Uobi5nZXRCdWZmZXIuY2FsbCh0KS5qb2luKFwiXCIpLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgxID09PSByLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gYS5zcGxpdChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLnNwbGljZShpLmJlZ2luLCAwLCByKSwgYSA9IHMuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KDAsIGYsIHApLCBkLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKChzLmlucHV0bWFzay5zaGFkb3dSb290IHx8IHMub3duZXJEb2N1bWVudCkuYWN0aXZlRWxlbWVudCAhPT0gcyAmJiBzLmZvY3VzKCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBsLndyaXRlQnVmZmVyKShzLCBuLmdldEJ1ZmZlci5jYWxsKHQpKSwgbi5jYXJldC5jYWxsKHQsIHMsIHAuYmVnaW4sIHAuZW5kLCAhMCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGguYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zZXJ0VGV4dFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc2VydFJlcGxhY2VtZW50VGV4dFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoLmRhdGEuZm9yRWFjaCgoZnVuY3Rpb24oZSwgYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBuZXcgaS5FdmVudChcImtleXByZXNzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbi53aGljaCA9IGUuY2hhckNvZGVBdCgwKSwgdC5pZ25vcmFibGUgPSAhMSwgYy5rZXlwcmVzc0V2ZW50LmNhbGwocywgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LiRlbC50cmlnZ2VyKFwia2V5dXBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVDb250ZW50QmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBuZXcgaS5FdmVudChcImtleWRvd25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYua2V5Q29kZSA9IHIuZGVmYXVsdC5CQUNLU1BBQ0UsIGMua2V5ZG93bkV2ZW50LmNhbGwocywgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgbC5hcHBseUlucHV0VmFsdWUpKHMsIGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uZW5kRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5pbnB1dG1hc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LmlzQ29tcG9zaW5nID0gITEsIHQuJGVsLnRyaWdnZXIoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWVFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmlucHV0bWFzaywgYSA9IHRoaXMsIGkgPSBlICYmIGUuZGV0YWlsID8gZS5kZXRhaWxbMF0gOiBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGkgJiYgKGkgPSBhLmlucHV0bWFzay5fdmFsdWVHZXQoITApKSwgKDAsIGwuYXBwbHlJbnB1dFZhbHVlKShhLCBpKSwgKGUuZGV0YWlsICYmIHZvaWQgMCAhPT0gZS5kZXRhaWxbMV0gfHwgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0pICYmIG4uY2FyZXQuY2FsbCh0LCBhLCBlLmRldGFpbCA/IGUuZGV0YWlsWzFdIDogYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmlucHV0bWFzaywgYSA9IHQub3B0cywgaSA9IHRoaXMsIHIgPSBpLmlucHV0bWFzay5fdmFsdWVHZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuc2hvd01hc2tPbkZvY3VzICYmIHIgIT09IG4uZ2V0QnVmZmVyLmNhbGwodCkuam9pbihcIlwiKSAmJiAoMCwgbC53cml0ZUJ1ZmZlcikoaSwgbi5nZXRCdWZmZXIuY2FsbCh0KSwgbi5zZWVrTmV4dC5jYWxsKHQsIG4uZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbCh0KSkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICEwICE9PSBhLnBvc2l0aW9uQ2FyZXRPblRhYiB8fCAhMSAhPT0gdC5tb3VzZUVudGVyIHx8IHMuaXNDb21wbGV0ZS5jYWxsKHQsIG4uZ2V0QnVmZmVyLmNhbGwodCkpICYmIC0xICE9PSBuLmdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwodCkgfHwgYy5jbGlja0V2ZW50LmFwcGx5KGksIFsgZSwgITAgXSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgdC51bmRvVmFsdWUgPSB0Ll92YWx1ZUdldCghMCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dG1hc2sudmFsaWRhdGlvbkV2ZW50ID0gITA7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlbGVhdmVFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuaW5wdXRtYXNrLCB0ID0gZS5vcHRzLCBhID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubW91c2VFbnRlciA9ICExLCB0LmNsZWFyTWFza09uTG9zdEZvY3VzICYmIChhLmlucHV0bWFzay5zaGFkb3dSb290IHx8IGEub3duZXJEb2N1bWVudCkuYWN0aXZlRWxlbWVudCAhPT0gYSAmJiAoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBsLkhhbmRsZU5hdGl2ZVBsYWNlaG9sZGVyKShhLCBlLm9yaWdpbmFsUGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjbGlja0V2ZW50OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMuaW5wdXRtYXNrLCBpID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaS5pbnB1dG1hc2suc2hhZG93Um9vdCB8fCBpLm93bmVyRG9jdW1lbnQpLmFjdGl2ZUVsZW1lbnQgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IG4uZGV0ZXJtaW5lTmV3Q2FyZXRQb3NpdGlvbi5jYWxsKGEsIG4uY2FyZXQuY2FsbChhLCBpKSwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSByICYmIG4uY2FyZXQuY2FsbChhLCBpLCByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY3V0RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5pbnB1dG1hc2ssIGEgPSB0Lm1hc2tzZXQsIGkgPSB0aGlzLCBvID0gbi5jYXJldC5jYWxsKHQsIGkpLCB1ID0gd2luZG93LmNsaXBib2FyZERhdGEgfHwgZS5jbGlwYm9hcmREYXRhLCBjID0gdC5pc1JUTCA/IG4uZ2V0QnVmZmVyLmNhbGwodCkuc2xpY2Uoby5lbmQsIG8uYmVnaW4pIDogbi5nZXRCdWZmZXIuY2FsbCh0KS5zbGljZShvLmJlZ2luLCBvLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1LnNldERhdGEoXCJ0ZXh0XCIsIHQuaXNSVEwgPyBjLnJldmVyc2UoKS5qb2luKFwiXCIpIDogYy5qb2luKFwiXCIpKSwgZG9jdW1lbnQuZXhlY0NvbW1hbmQgJiYgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJjb3B5XCIpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuaGFuZGxlUmVtb3ZlLmNhbGwodCwgaSwgci5kZWZhdWx0LkRFTEVURSwgbyksICgwLCBsLndyaXRlQnVmZmVyKShpLCBuLmdldEJ1ZmZlci5jYWxsKHQpLCBhLnAsIGUsIHQudW5kb1ZhbHVlICE9PSB0Ll92YWx1ZUdldCghMCkpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBibHVyRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5pbnB1dG1hc2ssIGEgPSB0Lm9wdHMsIGkgPSAoMCwgdC5kZXBlbmRlbmN5TGliKSh0aGlzKSwgciA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5pbnB1dG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgbC5IYW5kbGVOYXRpdmVQbGFjZWhvbGRlcikociwgdC5vcmlnaW5hbFBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHIuaW5wdXRtYXNrLl92YWx1ZUdldCgpLCB1ID0gbi5nZXRCdWZmZXIuY2FsbCh0KS5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIgIT09IG8gJiYgKGEuY2xlYXJNYXNrT25Mb3N0Rm9jdXMgJiYgKC0xID09PSBuLmdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwodCkgJiYgbyA9PT0gbi5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKHQpLmpvaW4oXCJcIikgPyB1ID0gW10gOiBsLmNsZWFyT3B0aW9uYWxUYWlsLmNhbGwodCwgdSkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhMSA9PT0gcy5pc0NvbXBsZXRlLmNhbGwodCwgdSkgJiYgKHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLnRyaWdnZXIoXCJpbmNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAwKSwgYS5jbGVhckluY29tcGxldGUgJiYgKG4ucmVzZXRNYXNrU2V0LmNhbGwodCksIHUgPSBhLmNsZWFyTWFza09uTG9zdEZvY3VzID8gW10gOiBuLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwodCkuc2xpY2UoKSkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgbC53cml0ZUJ1ZmZlcikociwgdSwgdm9pZCAwLCBlKSksIHQudW5kb1ZhbHVlICE9PSB0Ll92YWx1ZUdldCghMCkgJiYgKHQudW5kb1ZhbHVlID0gdC5fdmFsdWVHZXQoITApLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLnRyaWdnZXIoXCJjaGFuZ2VcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtb3VzZWVudGVyRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmlucHV0bWFzaywgdCA9IGUub3B0cywgYSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5tb3VzZUVudGVyID0gITAsIChhLmlucHV0bWFzay5zaGFkb3dSb290IHx8IGEub3duZXJEb2N1bWVudCkuYWN0aXZlRWxlbWVudCAhPT0gYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gKGUuaXNSVEwgPyBuLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoZSkuc2xpY2UoKS5yZXZlcnNlKCkgOiBuLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoZSkpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wbGFjZWhvbGRlciAhPT0gaSAmJiBhLnBsYWNlaG9sZGVyICE9PSBlLm9yaWdpbmFsUGxhY2Vob2xkZXIgJiYgKGUub3JpZ2luYWxQbGFjZWhvbGRlciA9IGEucGxhY2Vob2xkZXIpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnNob3dNYXNrT25Ib3ZlciAmJiAoMCwgbC5IYW5kbGVOYXRpdmVQbGFjZWhvbGRlcikoYSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN1Ym1pdEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5pbnB1dG1hc2ssIHQgPSBlLm9wdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnVuZG9WYWx1ZSAhPT0gZS5fdmFsdWVHZXQoITApICYmIGUuJGVsLnRyaWdnZXIoXCJjaGFuZ2VcIiksIHQuY2xlYXJNYXNrT25Mb3N0Rm9jdXMgJiYgLTEgPT09IG4uZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChlKSAmJiBlLl92YWx1ZUdldCAmJiBlLl92YWx1ZUdldCgpID09PSBuLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoZSkuam9pbihcIlwiKSAmJiBlLl92YWx1ZVNldChcIlwiKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB0LmNsZWFySW5jb21wbGV0ZSAmJiAhMSA9PT0gcy5pc0NvbXBsZXRlLmNhbGwoZSwgbi5nZXRCdWZmZXIuY2FsbChlKSkgJiYgZS5fdmFsdWVTZXQoXCJcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgdC5yZW1vdmVNYXNrT25TdWJtaXQgJiYgKGUuX3ZhbHVlU2V0KGUudW5tYXNrZWR2YWx1ZSgpLCAhMCksIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBsLndyaXRlQnVmZmVyKShlLmVsLCBuLmdldEJ1ZmZlci5jYWxsKGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAwKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0RXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmlucHV0bWFzaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucmVmcmVzaFZhbHVlID0gITAsIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBsLmFwcGx5SW5wdXRWYWx1ZSkoZS5lbCwgZS5fdmFsdWVHZXQoITApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdC5FdmVudEhhbmRsZXJzID0gYztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA5NzE2OiBmdW5jdGlvbihlLCB0LCBhKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LkV2ZW50UnVsZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBzKGEoMjM5NCkpLCBuID0gcyhhKDQ1MjgpKSwgciA9IGEoODcxMSksIG8gPSBhKDc3NjApO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHMoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgb246IGZ1bmN0aW9uKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gZS5pbnB1dG1hc2suZGVwZW5kZW5jeUxpYiwgbCA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Lm9yaWdpbmFsRXZlbnQgJiYgKHQgPSB0Lm9yaWdpbmFsRXZlbnQgfHwgdCwgYXJndW1lbnRzWzBdID0gdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwsIHUgPSB0aGlzLCBjID0gdS5pbnB1dG1hc2ssIGYgPSBjID8gYy5vcHRzIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGMgJiYgXCJGT1JNXCIgIT09IHRoaXMubm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBzLmRhdGEodSwgXCJfaW5wdXRtYXNrX29wdHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHModSkub2ZmKCksIGQgJiYgbmV3IGkuZGVmYXVsdChkKS5tYXNrKHUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChbIFwic3VibWl0XCIsIFwicmVzZXRcIiwgXCJzZXR2YWx1ZVwiIF0uaW5jbHVkZXModC50eXBlKSB8fCBcIkZPUk1cIiA9PT0gdGhpcy5ub2RlTmFtZSB8fCAhKHUuZGlzYWJsZWQgfHwgdS5yZWFkT25seSAmJiAhKFwia2V5ZG93blwiID09PSB0LnR5cGUgJiYgdC5jdHJsS2V5ICYmIDY3ID09PSB0LmtleUNvZGUgfHwgITEgPT09IGYudGFiVGhyb3VnaCAmJiB0LmtleUNvZGUgPT09IG4uZGVmYXVsdC5UQUIpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEwID09PSBjLnNraXBJbnB1dEV2ZW50IHx8IHQuaW5wdXRUeXBlICYmIFwiaW5zZXJ0Q29tcG9zaXRpb25UZXh0XCIgPT09IHQuaW5wdXRUeXBlKSByZXR1cm4gYy5za2lwSW5wdXRFdmVudCA9ICExLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImtleWRvd25cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnNraXBLZXlQcmVzc0V2ZW50ID0gITEsIGMuc2tpcElucHV0RXZlbnQgPSBjLmlzQ29tcG9zaW5nID0gdC5rZXlDb2RlID09PSBuLmRlZmF1bHQuS0VZXzIyOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwia2V5dXBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbXBvc2l0aW9uZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pc0NvbXBvc2luZyAmJiAoYy5za2lwSW5wdXRFdmVudCA9ICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwia2V5cHJlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITAgPT09IGMuc2tpcEtleVByZXNzRXZlbnQpIHJldHVybiB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5za2lwS2V5UHJlc3NFdmVudCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjbGlja1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZm9jdXNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYy52YWxpZGF0aW9uRXZlbnQgPyAoYy52YWxpZGF0aW9uRXZlbnQgPSAhMSwgZS5ibHVyKCksICgwLCBvLkhhbmRsZU5hdGl2ZVBsYWNlaG9sZGVyKShlLCAoYy5pc1JUTCA/IHIuZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChjKS5zbGljZSgpLnJldmVyc2UoKSA6IHIuZ2V0QnVmZmVyVGVtcGxhdGUuY2FsbChjKSkuam9pbihcIlwiKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIGYudmFsaWRhdGlvbkV2ZW50VGltZU91dCksICExKSA6IChsID0gYXJndW1lbnRzLCBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5pbnB1dG1hc2sgJiYgYS5hcHBseSh1LCBsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgMCksICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gYS5hcHBseSh1LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExID09PSBwICYmICh0LnByZXZlbnREZWZhdWx0KCksIHQuc3RvcFByb3BhZ2F0aW9uKCkpLCBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgWyBcInN1Ym1pdFwiLCBcInJlc2V0XCIgXS5pbmNsdWRlcyh0KSA/IChsID0gbC5iaW5kKGUpLCBudWxsICE9PSBlLmZvcm0gJiYgcyhlLmZvcm0pLm9uKHQsIGwpKSA6IHMoZSkub24odCwgbCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgZS5pbnB1dG1hc2suZXZlbnRzW3RdID0gZS5pbnB1dG1hc2suZXZlbnRzW3RdIHx8IFtdLCBlLmlucHV0bWFzay5ldmVudHNbdF0ucHVzaChsKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb2ZmOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5pbnB1dG1hc2sgJiYgZS5pbnB1dG1hc2suZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBlLmlucHV0bWFzay5kZXBlbmRlbmN5TGliLCBpID0gZS5pbnB1dG1hc2suZXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gaW4gdCAmJiAoKGkgPSBbXSlbdF0gPSBlLmlucHV0bWFzay5ldmVudHNbdF0pLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSBpW25dOyByLmxlbmd0aCA+IDA7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSByLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBcInN1Ym1pdFwiLCBcInJlc2V0XCIgXS5pbmNsdWRlcyhuKSA/IG51bGwgIT09IGUuZm9ybSAmJiBhKGUuZm9ybSkub2ZmKG4sIG8pIDogYShlKS5vZmYobiwgbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGUuaW5wdXRtYXNrLmV2ZW50c1tuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHQuRXZlbnRSdWxlciA9IGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMjE5OiBmdW5jdGlvbihlLCB0LCBhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBsKGEoMjM5NCkpLCBuID0gbChhKDQ1MjgpKSwgciA9IGwoYSg3MTg0KSksIG8gPSBhKDg3MTEpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHMoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHMgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGU7XG4gICAgICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBlLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgZSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgZTtcbiAgICAgICAgICAgICAgICAgICAgfSkoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGwoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdSA9IGkuZGVmYXVsdC5kZXBlbmRlbmN5TGliLCBjID0gKG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpLCBmID0ge1xuICAgICAgICAgICAgICAgICAgICBkOiBbIFwiWzEtOV18WzEyXVswLTldfDNbMDFdXCIsIERhdGUucHJvdG90eXBlLnNldERhdGUsIFwiZGF5XCIsIERhdGUucHJvdG90eXBlLmdldERhdGUgXSxcbiAgICAgICAgICAgICAgICAgICAgZGQ6IFsgXCIwWzEtOV18WzEyXVswLTldfDNbMDFdXCIsIERhdGUucHJvdG90eXBlLnNldERhdGUsIFwiZGF5XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkoRGF0ZS5wcm90b3R5cGUuZ2V0RGF0ZS5jYWxsKHRoaXMpLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBkZGQ6IFsgXCJcIiBdLFxuICAgICAgICAgICAgICAgICAgICBkZGRkOiBbIFwiXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgbTogWyBcIlsxLTldfDFbMDEyXVwiLCBEYXRlLnByb3RvdHlwZS5zZXRNb250aCwgXCJtb250aFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS5nZXRNb250aC5jYWxsKHRoaXMpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBtbTogWyBcIjBbMS05XXwxWzAxMl1cIiwgRGF0ZS5wcm90b3R5cGUuc2V0TW9udGgsIFwibW9udGhcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geShEYXRlLnByb3RvdHlwZS5nZXRNb250aC5jYWxsKHRoaXMpICsgMSwgMik7XG4gICAgICAgICAgICAgICAgICAgIH0gXSxcbiAgICAgICAgICAgICAgICAgICAgbW1tOiBbIFwiXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgbW1tbTogWyBcIlwiIF0sXG4gICAgICAgICAgICAgICAgICAgIHl5OiBbIFwiWzAtOV17Mn1cIiwgRGF0ZS5wcm90b3R5cGUuc2V0RnVsbFllYXIsIFwieWVhclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5KERhdGUucHJvdG90eXBlLmdldEZ1bGxZZWFyLmNhbGwodGhpcyksIDIpO1xuICAgICAgICAgICAgICAgICAgICB9IF0sXG4gICAgICAgICAgICAgICAgICAgIHl5eXk6IFsgXCJbMC05XXs0fVwiLCBEYXRlLnByb3RvdHlwZS5zZXRGdWxsWWVhciwgXCJ5ZWFyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkoRGF0ZS5wcm90b3R5cGUuZ2V0RnVsbFllYXIuY2FsbCh0aGlzKSwgNCk7XG4gICAgICAgICAgICAgICAgICAgIH0gXSxcbiAgICAgICAgICAgICAgICAgICAgaDogWyBcIlsxLTldfDFbMC0yXVwiLCBEYXRlLnByb3RvdHlwZS5zZXRIb3VycywgXCJob3Vyc1wiLCBEYXRlLnByb3RvdHlwZS5nZXRIb3VycyBdLFxuICAgICAgICAgICAgICAgICAgICBoaDogWyBcIjBbMS05XXwxWzAtMl1cIiwgRGF0ZS5wcm90b3R5cGUuc2V0SG91cnMsIFwiaG91cnNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geShEYXRlLnByb3RvdHlwZS5nZXRIb3Vycy5jYWxsKHRoaXMpLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBoeDogWyBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbMC05XXtcIi5jb25jYXQoZSwgXCJ9XCIpO1xuICAgICAgICAgICAgICAgICAgICB9LCBEYXRlLnByb3RvdHlwZS5zZXRIb3VycywgXCJob3Vyc1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZS5wcm90b3R5cGUuZ2V0SG91cnM7XG4gICAgICAgICAgICAgICAgICAgIH0gXSxcbiAgICAgICAgICAgICAgICAgICAgSDogWyBcIjE/WzAtOV18MlswLTNdXCIsIERhdGUucHJvdG90eXBlLnNldEhvdXJzLCBcImhvdXJzXCIsIERhdGUucHJvdG90eXBlLmdldEhvdXJzIF0sXG4gICAgICAgICAgICAgICAgICAgIEhIOiBbIFwiMFswLTldfDFbMC05XXwyWzAtM11cIiwgRGF0ZS5wcm90b3R5cGUuc2V0SG91cnMsIFwiaG91cnNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geShEYXRlLnByb3RvdHlwZS5nZXRIb3Vycy5jYWxsKHRoaXMpLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBIeDogWyBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbMC05XXtcIi5jb25jYXQoZSwgXCJ9XCIpO1xuICAgICAgICAgICAgICAgICAgICB9LCBEYXRlLnByb3RvdHlwZS5zZXRIb3VycywgXCJob3Vyc1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkoRGF0ZS5wcm90b3R5cGUuZ2V0SG91cnMuY2FsbCh0aGlzKSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IF0sXG4gICAgICAgICAgICAgICAgICAgIE06IFsgXCJbMS01XT9bMC05XVwiLCBEYXRlLnByb3RvdHlwZS5zZXRNaW51dGVzLCBcIm1pbnV0ZXNcIiwgRGF0ZS5wcm90b3R5cGUuZ2V0TWludXRlcyBdLFxuICAgICAgICAgICAgICAgICAgICBNTTogWyBcIjBbMC05XXwxWzAtOV18MlswLTldfDNbMC05XXw0WzAtOV18NVswLTldXCIsIERhdGUucHJvdG90eXBlLnNldE1pbnV0ZXMsIFwibWludXRlc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5KERhdGUucHJvdG90eXBlLmdldE1pbnV0ZXMuY2FsbCh0aGlzKSwgMik7XG4gICAgICAgICAgICAgICAgICAgIH0gXSxcbiAgICAgICAgICAgICAgICAgICAgczogWyBcIlsxLTVdP1swLTldXCIsIERhdGUucHJvdG90eXBlLnNldFNlY29uZHMsIFwic2Vjb25kc1wiLCBEYXRlLnByb3RvdHlwZS5nZXRTZWNvbmRzIF0sXG4gICAgICAgICAgICAgICAgICAgIHNzOiBbIFwiMFswLTldfDFbMC05XXwyWzAtOV18M1swLTldfDRbMC05XXw1WzAtOV1cIiwgRGF0ZS5wcm90b3R5cGUuc2V0U2Vjb25kcywgXCJzZWNvbmRzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkoRGF0ZS5wcm90b3R5cGUuZ2V0U2Vjb25kcy5jYWxsKHRoaXMpLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBsOiBbIFwiWzAtOV17M31cIiwgRGF0ZS5wcm90b3R5cGUuc2V0TWlsbGlzZWNvbmRzLCBcIm1pbGxpc2Vjb25kc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5KERhdGUucHJvdG90eXBlLmdldE1pbGxpc2Vjb25kcy5jYWxsKHRoaXMpLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBMOiBbIFwiWzAtOV17Mn1cIiwgRGF0ZS5wcm90b3R5cGUuc2V0TWlsbGlzZWNvbmRzLCBcIm1pbGxpc2Vjb25kc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5KERhdGUucHJvdG90eXBlLmdldE1pbGxpc2Vjb25kcy5jYWxsKHRoaXMpLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICB0OiBbIFwiW2FwXVwiLCBwLCBcImFtcG1cIiwgaCwgMSBdLFxuICAgICAgICAgICAgICAgICAgICB0dDogWyBcIlthcF1tXCIsIHAsIFwiYW1wbVwiLCBoLCAyIF0sXG4gICAgICAgICAgICAgICAgICAgIFQ6IFsgXCJbQVBdXCIsIHAsIFwiYW1wbVwiLCBoLCAxIF0sXG4gICAgICAgICAgICAgICAgICAgIFRUOiBbIFwiW0FQXU1cIiwgcCwgXCJhbXBtXCIsIGgsIDIgXSxcbiAgICAgICAgICAgICAgICAgICAgWjogWyBcIlwiIF0sXG4gICAgICAgICAgICAgICAgICAgIG86IFsgXCJcIiBdLFxuICAgICAgICAgICAgICAgICAgICBTOiBbIFwiXCIgXVxuICAgICAgICAgICAgICAgIH0sIGQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlzb0RhdGU6IFwieXl5eS1tbS1kZFwiLFxuICAgICAgICAgICAgICAgICAgICBpc29UaW1lOiBcIkhIOk1NOnNzXCIsXG4gICAgICAgICAgICAgICAgICAgIGlzb0RhdGVUaW1lOiBcInl5eXktbW0tZGQnVCdISDpNTTpzc1wiLFxuICAgICAgICAgICAgICAgICAgICBpc29VdGNEYXRlVGltZTogXCJVVEM6eXl5eS1tbS1kZCdUJ0hIOk1NOnNzJ1onXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJwXCIpICYmIHRoaXMuc2V0SG91cnModGhpcy5nZXRIb3VycygpICsgMTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBoKCkge31cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB2KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBuZXcgUmVnRXhwKFwiXFxcXGQrJFwiKS5leGVjKGVbMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiB2b2lkIDAgIT09IHRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gZltlWzBdWzBdICsgXCJ4XCJdLnNsaWNlKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFbMF0gPSBhWzBdKHRbMF0pLCBhWzNdID0gYVszXSh0WzBdKSwgYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZltlWzBdXSkgcmV0dXJuIGZbZVswXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG0oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWUudG9rZW5pemVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IFtdLCBhID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIGYpIGlmICgvXFwuKngkLy50ZXN0KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBpWzBdICsgXCJcXFxcZCtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtMSA9PT0gYS5pbmRleE9mKG4pICYmIGEucHVzaChuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSAtMSA9PT0gdC5pbmRleE9mKGlbMF0pICYmIHQucHVzaChpWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUudG9rZW5pemVyID0gXCIoXCIgKyAoYS5sZW5ndGggPiAwID8gYS5qb2luKFwifFwiKSArIFwifFwiIDogXCJcIikgKyB0LmpvaW4oXCIrfFwiKSArIFwiKSs/fC5cIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnRva2VuaXplciA9IG5ldyBSZWdFeHAoZS50b2tlbml6ZXIsIFwiZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS50b2tlbml6ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGcoZSwgdCwgYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBlLnJhd2RheSB8fCAhaXNGaW5pdGUoZS5yYXdkYXkpICYmIG5ldyBEYXRlKGUuZGF0ZS5nZXRGdWxsWWVhcigpLCBpc0Zpbml0ZShlLnJhd21vbnRoKSA/IGUubW9udGggOiBlLmRhdGUuZ2V0TW9udGgoKSArIDEsIDApLmdldERhdGUoKSA+PSBlLmRheSB8fCBcIjI5XCIgPT0gZS5kYXkgJiYgIU51bWJlci5pc0Zpbml0ZShlLnJhd3llYXIpIHx8IG5ldyBEYXRlKGUuZGF0ZS5nZXRGdWxsWWVhcigpLCBpc0Zpbml0ZShlLnJhd21vbnRoKSA/IGUubW9udGggOiBlLmRhdGUuZ2V0TW9udGgoKSArIDEsIDApLmdldERhdGUoKSA+PSBlLmRheSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIjI5XCIgPT0gZS5kYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gUCh0LnBvcywgYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJ5eXl5XCIgPT09IGkudGFyZ2V0TWF0Y2hbMF0gJiYgdC5wb3MgLSBpLnRhcmdldE1hdGNoSW5kZXggPT0gMikgcmV0dXJuIHQucmVtb3ZlID0gdC5wb3MgKyAxLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIwMlwiID09IGUubW9udGggJiYgXCIzMFwiID09IGUuZGF5ICYmIHZvaWQgMCAhPT0gdC5jKSByZXR1cm4gZS5kYXkgPSBcIjAzXCIsIFxuICAgICAgICAgICAgICAgICAgICBlLmRhdGUuc2V0RGF0ZSgzKSwgZS5kYXRlLnNldE1vbnRoKDEpLCB0Lmluc2VydCA9IFsge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiB0LnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGM6IFwiMFwiXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogdC5wb3MgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgYzogdC5jXG4gICAgICAgICAgICAgICAgICAgIH0gXSwgdC5jYXJldCA9IG8uc2Vla05leHQuY2FsbCh0aGlzLCB0LnBvcyArIDEpLCB0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGsoZSwgdCwgYSwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiwgbywgcyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobShhKS5sYXN0SW5kZXggPSAwOyBuID0gbShhKS5leGVjKGUpOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHQpIGlmIChvID0gdihuKSkgcyArPSBcIihcIiArIG9bMF0gKyBcIilcIjsgZWxzZSBzd2l0Y2ggKG5bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IFwiKFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJdXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBcIik/XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9ICgwLCByLmRlZmF1bHQpKG5bMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvID0gdihuKSkgaWYgKCEwICE9PSBpICYmIG9bM10pIHMgKz0gb1szXS5jYWxsKHQuZGF0ZSk7IGVsc2Ugb1syXSA/IHMgKz0gdFtcInJhd1wiICsgb1syXV0gOiBzICs9IG5bMF07IGVsc2UgcyArPSBuWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB5KGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChlID0gU3RyaW5nKGUpLCB0ID0gdCB8fCAyOyBlLmxlbmd0aCA8IHQ7ICkgZSA9IGEgPyBlICsgXCIwXCIgOiBcIjBcIiArIGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBiKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIG4sIHIsIG8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgxLCAwLCAxKVxuICAgICAgICAgICAgICAgICAgICB9LCBsID0gZTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdShlLCB0LCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtpXSA9IFwiYW1wbVwiID09PSBpID8gdCA6IHQucmVwbGFjZSgvW14wLTldL2csIFwiMFwiKSwgZVtcInJhd1wiICsgaV0gPSB0LCB2b2lkIDAgIT09IHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiZGF5XCIgPT09IGkgJiYgMjkgPT09IHBhcnNlSW50KG4pIHx8IFwibW9udGhcIiA9PT0gaSAmJiAyID09PSBwYXJzZUludChuKSkgJiYgKDI5ICE9PSBwYXJzZUludChlLmRheSkgfHwgMiAhPT0gcGFyc2VJbnQoZS5tb250aCkgfHwgXCJcIiAhPT0gZS55ZWFyICYmIHZvaWQgMCAhPT0gZS55ZWFyIHx8IGUuZGF0ZS5zZXRGdWxsWWVhcigyMDEyLCAxLCAyOSkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRheVwiID09PSBpICYmIDAgPT09IHBhcnNlSW50KG4pICYmIChuID0gMSksIFwibW9udGhcIiA9PT0gaSAmJiAobiA9IHBhcnNlSW50KG4pKSA+IDAgJiYgKG4gLT0gMSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieWVhclwiID09PSBpICYmIG4ubGVuZ3RoIDwgNCAmJiAobiA9IHkobiwgNCwgITApKSwgXCJcIiA9PT0gbiB8fCBpc05hTihuKSB8fCByLmNhbGwoZS5kYXRlLCBuKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhbXBtXCIgPT09IGkgJiYgci5jYWxsKGUuZGF0ZSwgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobShhKS5sYXN0SW5kZXggPSAwOyBuID0gbShhKS5leGVjKHQpOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG5ldyBSZWdFeHAoXCJcXFxcZCskXCIpLmV4ZWMoblswXSksIGQgPSBjID8gblswXVswXSArIFwieFwiIDogblswXSwgcCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IG0oYSkubGFzdEluZGV4LCB2ID0gUChuLmluZGV4LCBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShhKS5sYXN0SW5kZXggPSBoLCBwID0gbC5zbGljZSgwLCBsLmluZGV4T2Yodi5uZXh0TWF0Y2hbMF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgcCA9IGwuc2xpY2UoMCwgZC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmLCBkKSAmJiAoaSA9IGZbZF1bMl0sIHIgPSBmW2RdWzFdLCB1KG8sIHApKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IGwuc2xpY2UocC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGwgJiYgXCJvYmplY3RcIiA9PT0gcyhsKSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobCwgXCJkYXRlXCIpKSByZXR1cm4gbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24geChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrKHQuaW5wdXRGb3JtYXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IGVcbiAgICAgICAgICAgICAgICAgICAgfSwgdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSwgaSwgbiA9IDAsIHIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKG0odCkubGFzdEluZGV4ID0gMDsgaSA9IG0odCkuZXhlYyh0LmlucHV0Rm9ybWF0KTsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IG5ldyBSZWdFeHAoXCJcXFxcZCskXCIpLmV4ZWMoaVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG4gKz0gciA9IG8gPyBwYXJzZUludChvWzBdKSA6IGlbMF0ubGVuZ3RoKSA+PSBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGksIGkgPSBtKHQpLmV4ZWModC5pbnB1dEZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE1hdGNoSW5kZXg6IG4gLSByLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE1hdGNoOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TWF0Y2g6IGFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaS5kZWZhdWx0LmV4dGVuZEFsaWFzZXMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRldGltZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzazogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLm51bWVyaWNJbnB1dCA9ICExLCBmLlMgPSBlLmkxOG4ub3JkaW5hbFN1ZmZpeC5qb2luKFwifFwiKSwgZS5pbnB1dEZvcm1hdCA9IGRbZS5pbnB1dEZvcm1hdF0gfHwgZS5pbnB1dEZvcm1hdCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5kaXNwbGF5Rm9ybWF0ID0gZFtlLmRpc3BsYXlGb3JtYXRdIHx8IGUuZGlzcGxheUZvcm1hdCB8fCBlLmlucHV0Rm9ybWF0LCBlLm91dHB1dEZvcm1hdCA9IGRbZS5vdXRwdXRGb3JtYXRdIHx8IGUub3V0cHV0Rm9ybWF0IHx8IGUuaW5wdXRGb3JtYXQsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucGxhY2Vob2xkZXIgPSBcIlwiICE9PSBlLnBsYWNlaG9sZGVyID8gZS5wbGFjZWhvbGRlciA6IGUuaW5wdXRGb3JtYXQucmVwbGFjZSgvW1tcXF1dLywgXCJcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucmVnZXggPSBrKGUuaW5wdXRGb3JtYXQsIHZvaWQgMCwgZSksIGUubWluID0gYihlLm1pbiwgZS5pbnB1dEZvcm1hdCwgZSksIGUubWF4ID0gYihlLm1heCwgZS5pbnB1dEZvcm1hdCwgZSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dEZvcm1hdDogXCJpc29EYXRlVGltZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheUZvcm1hdDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Rm9ybWF0OiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW46IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXg6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwT3B0aW9uYWxQYXJ0Q2hhcmFjdGVyOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheU5hbWVzOiBbIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCIsIFwiU3VuXCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIiwgXCJTdW5kYXlcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoTmFtZXM6IFsgXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIiwgXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkaW5hbFN1ZmZpeDogWyBcInN0XCIsIFwibmRcIiwgXCJyZFwiLCBcInRoXCIgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZVZhbGlkYXRpb246IGZ1bmN0aW9uKGUsIHQsIGEsIGksIG4sIHIsIG8sIHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocykgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihhKSAmJiBlW3RdICE9PSBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gUCh0LCBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwubmV4dE1hdGNoICYmIGwubmV4dE1hdGNoWzBdID09PSBhICYmIGwudGFyZ2V0TWF0Y2hbMF0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSBmW2wudGFyZ2V0TWF0Y2hbMF1dWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ldyBSZWdFeHAodSkudGVzdChcIjBcIiArIGVbdCAtIDFdKSkgcmV0dXJuIGVbdF0gPSBlW3QgLSAxXSwgZVt0IC0gMV0gPSBcIjBcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnV6enk6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoRnJvbUJ1ZmZlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogdCAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogdCArIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogdCArIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RWYWxpZGF0aW9uOiBmdW5jdGlvbihlLCB0LCBhLCBpLCBuLCByLCBvLCBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwsIHU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8pIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITEgPT09IGkgJiYgKCgobCA9IFAodCArIDEsIG4pKS50YXJnZXRNYXRjaCAmJiBsLnRhcmdldE1hdGNoSW5kZXggPT09IHQgJiYgbC50YXJnZXRNYXRjaFswXS5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gZltsLnRhcmdldE1hdGNoWzBdXSB8fCAobCA9IFAodCArIDIsIG4pKS50YXJnZXRNYXRjaCAmJiBsLnRhcmdldE1hdGNoSW5kZXggPT09IHQgKyAxICYmIGwudGFyZ2V0TWF0Y2hbMF0ubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGZbbC50YXJnZXRNYXRjaFswXV0pICYmICh1ID0gZltsLnRhcmdldE1hdGNoWzBdXVswXSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gdSAmJiAodm9pZCAwICE9PSByLnZhbGlkUG9zaXRpb25zW3QgKyAxXSAmJiBuZXcgUmVnRXhwKHUpLnRlc3QoYSArIFwiMFwiKSA/IChlW3RdID0gYSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZVt0ICsgMV0gPSBcIjBcIiwgaSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiB0ICsgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQ6IHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSA6IG5ldyBSZWdFeHAodSkudGVzdChcIjBcIiArIGEpICYmIChlW3RdID0gXCIwXCIsIGVbdCArIDFdID0gYSwgaSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiB0ICsgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgITEgPT09IGkpKSByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaS5mdXp6eSAmJiAoZSA9IGkuYnVmZmVyLCB0ID0gaS5wb3MpLCAobCA9IFAodCwgbikpLnRhcmdldE1hdGNoICYmIGwudGFyZ2V0TWF0Y2hbMF0gJiYgdm9pZCAwICE9PSBmW2wudGFyZ2V0TWF0Y2hbMF1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBmW2wudGFyZ2V0TWF0Y2hbMF1dWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGUuc2xpY2UobC50YXJnZXRNYXRjaEluZGV4LCBsLnRhcmdldE1hdGNoSW5kZXggKyBsLnRhcmdldE1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICExID09PSBuZXcgUmVnRXhwKHUpLnRlc3QoZC5qb2luKFwiXCIpKSAmJiAyID09PSBsLnRhcmdldE1hdGNoWzBdLmxlbmd0aCAmJiByLnZhbGlkUG9zaXRpb25zW2wudGFyZ2V0TWF0Y2hJbmRleF0gJiYgci52YWxpZFBvc2l0aW9uc1tsLnRhcmdldE1hdGNoSW5kZXggKyAxXSAmJiAoci52YWxpZFBvc2l0aW9uc1tsLnRhcmdldE1hdGNoSW5kZXggKyAxXS5pbnB1dCA9IFwiMFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBpLCBoID0gYihlLmpvaW4oXCJcIiksIG4uaW5wdXRGb3JtYXQsIG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwICYmIGguZGF0ZS5nZXRUaW1lKCkgPT0gaC5kYXRlLmdldFRpbWUoKSAmJiAobi5wcmVmaWxsWWVhciAmJiAocCA9IGZ1bmN0aW9uKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUueWVhciAhPT0gZS5yYXd5ZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGMudG9TdHJpbmcoKSwgbiA9IGUucmF3eWVhci5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIiksIHIgPSBpLnNsaWNlKDAsIG4ubGVuZ3RoKSwgbyA9IGkuc2xpY2Uobi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDIgPT09IG4ubGVuZ3RoICYmIG4gPT09IHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IG5ldyBEYXRlKGMsIGUubW9udGggLSAxLCBlLmRheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXkgPT0gcy5nZXREYXRlKCkgJiYgKCFhLm1heCB8fCBhLm1heC5kYXRlLmdldFRpbWUoKSA+PSBzLmdldFRpbWUoKSkgJiYgKGUuZGF0ZS5zZXRGdWxsWWVhcihjKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS55ZWFyID0gaSwgdC5pbnNlcnQgPSBbIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiB0LnBvcyArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM6IG9bMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogdC5wb3MgKyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjOiBvWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGgsIHAsIG4pKSwgcCA9IGZ1bmN0aW9uKGUsIHQsIGEsIGksIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0KSByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEubWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5yYXd5ZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIsIG8gPSBlLnJhd3llYXIucmVwbGFjZSgvW14wLTldL2csIFwiXCIpLCBzID0gYS5taW4ueWVhci5zdWJzdHIoMCwgby5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvIDwgcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IFAodC5wb3MsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobyA9IGUucmF3eWVhci5zdWJzdHIoMCwgdC5wb3MgLSBsLnRhcmdldE1hdGNoSW5kZXggKyAxKS5yZXBsYWNlKC9bXjAtOV0vZywgXCIwXCIpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHMgPSBhLm1pbi55ZWFyLnN1YnN0cigwLCBvLmxlbmd0aCkpIDw9IG8pIHJldHVybiB0LnJlbW92ZSA9IGwudGFyZ2V0TWF0Y2hJbmRleCArIG8ubGVuZ3RoLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8gPSBcInl5eXlcIiA9PT0gbC50YXJnZXRNYXRjaFswXSA/IGUucmF3eWVhci5zdWJzdHIoMSwgMSkgOiBlLnJhd3llYXIuc3Vic3RyKDAsIDEpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IGEubWluLnllYXIuc3Vic3RyKDIsIDEpLCByID0gYS5tYXggPyBhLm1heC55ZWFyLnN1YnN0cigyLCAxKSA6IG8sIDEgPT09IG8ubGVuZ3RoICYmIHMgPD0gbyAmJiBvIDw9IHIgJiYgITAgIT09IG4pIHJldHVybiBcInl5eXlcIiA9PT0gbC50YXJnZXRNYXRjaFswXSA/ICh0Lmluc2VydCA9IFsge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiB0LnBvcyArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjOiBvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0OiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IF0sIHQuY2FyZXQgPSB0LnBvcyArIDIsIGkudmFsaWRQb3NpdGlvbnNbdC5wb3NdLmlucHV0ID0gYS5taW4ueWVhclsxXSkgOiAodC5pbnNlcnQgPSBbIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogdC5wb3MgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzogYS5taW4ueWVhclsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdDogITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiB0LnBvcyArIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjOiBvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0OiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IF0sIHQuY2FyZXQgPSB0LnBvcyArIDMsIGkudmFsaWRQb3NpdGlvbnNbdC5wb3NdLmlucHV0ID0gYS5taW4ueWVhclswXSksIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB1IGluIGUpIC0xID09PSB1LmluZGV4T2YoXCJyYXdcIikgJiYgZVtcInJhd1wiLmNvbmNhdCh1KV0gJiYgKGVbdV0sIGVbXCJyYXdcIi5jb25jYXQodSldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgJiYgZS55ZWFyICYmIGUueWVhciA9PT0gZS5yYXd5ZWFyICYmIGEubWluLmRhdGUuZ2V0VGltZSgpID09IGEubWluLmRhdGUuZ2V0VGltZSgpICYmICh0ID0gYS5taW4uZGF0ZS5nZXRUaW1lKCkgPD0gZS5kYXRlLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgJiYgYS5tYXggJiYgYS5tYXguZGF0ZS5nZXRUaW1lKCkgPT0gYS5tYXguZGF0ZS5nZXRUaW1lKCkgJiYgKHQgPSBhLm1heC5kYXRlLmdldFRpbWUoKSA+PSBlLmRhdGUuZ2V0VGltZSgpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShoLCBwID0gZy5jYWxsKHRoaXMsIGgsIHAsIG4pLCBuLCByLCBzKSksIHZvaWQgMCAhPT0gdCAmJiBwICYmIGkucG9zICE9PSB0ID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXI6IGsobi5pbnB1dEZvcm1hdCwgaCwgbikuc3BsaXQoXCJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hGcm9tQnVmZmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaS5wb3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBpLmNhcmV0IHx8IGkucG9zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25LZXlEb3duOiBmdW5jdGlvbihlLCB0LCBhLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jdHJsS2V5ICYmIGUua2V5Q29kZSA9PT0gbi5kZWZhdWx0LlJJR0hUICYmICh0aGlzLmlucHV0bWFzay5fdmFsdWVTZXQoeChuZXcgRGF0ZSwgaSkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1KHRoaXMpLnRyaWdnZXIoXCJzZXR2YWx1ZVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25Vbk1hc2s6IGZ1bmN0aW9uKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCA/IGsoYS5vdXRwdXRGb3JtYXQsIGIoZSwgYS5pbnB1dEZvcm1hdCwgYSksIGEsICEwKSA6IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzaW5nOiBmdW5jdGlvbihlLCB0LCBhLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgPT0gdC5uYXRpdmVEZWYuaW5kZXhPZihcIlthcF1cIikgPyBlLnRvTG93ZXJDYXNlKCkgOiAwID09IHQubmF0aXZlRGVmLmluZGV4T2YoXCJbQVBdXCIpID8gZS50b1VwcGVyQ2FzZSgpIDogZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZU1hc2s6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IERhdGVdXCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSAmJiAoZSA9IHgoZSwgdCkpLCBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydE1vZGU6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRQb3NpdGlvbnM6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAga2VlcFN0YXRpYzogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dG1vZGU6IFwibnVtZXJpY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmlsbFllYXI6ICEwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAzODUxOiBmdW5jdGlvbihlLCB0LCBhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIG4gPSAoaSA9IGEoMjM5NCkpICYmIGkuX19lc01vZHVsZSA/IGkgOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGlcbiAgICAgICAgICAgICAgICB9LCByID0gYSg4NzExKSwgbyA9IGEoNDcxMyk7XG4gICAgICAgICAgICAgICAgbi5kZWZhdWx0LmV4dGVuZERlZmluaXRpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgQToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBcIltBLVphLXpcXHUwNDEwLVxcdTA0NGZcXHUwNDAxXFx1MDQ1MVxceGMwLVxceGZmXFx4YjVdXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNpbmc6IFwidXBwZXJcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcIiZcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBcIlswLTlBLVphLXpcXHUwNDEwLVxcdTA0NGZcXHUwNDAxXFx1MDQ1MVxceGMwLVxceGZmXFx4YjVdXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNpbmc6IFwidXBwZXJcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcIiNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBcIlswLTlBLUZhLWZdXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNpbmc6IFwidXBwZXJcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBuZXcgUmVnRXhwKFwiMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdWzAtOV1bMC05XVwiKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsKGUsIHQsIGEsIGksIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgLSAxID4gLTEgJiYgXCIuXCIgIT09IHQuYnVmZmVyW2EgLSAxXSA/IChlID0gdC5idWZmZXJbYSAtIDFdICsgZSwgZSA9IGEgLSAyID4gLTEgJiYgXCIuXCIgIT09IHQuYnVmZmVyW2EgLSAyXSA/IHQuYnVmZmVyW2EgLSAyXSArIGUgOiBcIjBcIiArIGUpIDogZSA9IFwiMDBcIiArIGUsIFxuICAgICAgICAgICAgICAgICAgICBzLnRlc3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG4uZGVmYXVsdC5leHRlbmRBbGlhc2VzKHtcbiAgICAgICAgICAgICAgICAgICAgY3NzdW5pdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXg6IFwiWystXT9bMC05XStcXFxcLj8oWzAtOV0rKT8ocHh8ZW18cmVtfGV4fCV8aW58Y218bW18cHR8cGMpXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWdleDogXCIoaHR0cHM/fGZ0cCk6Ly8uKlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1VubWFzazogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZWVwU3RhdGljOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYlRocm91Z2g6ICEwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGlwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrOiBcImlbaVtpXV0ualtqW2pdXS5rW2tba11dLmxbbFtsXV1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGo6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25Vbk1hc2s6IGZ1bmN0aW9uKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dG1vZGU6IFwibnVtZXJpY1wiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrOiBcIip7MSw2NH1bLip7MSw2NH1dWy4qezEsNjR9XVsuKnsxLDYzfV1ALXsxLDYzfS4tezEsNjN9Wy4tezEsNjN9XVsuLXsxLDYzfV1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyZWVkeTogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNpbmc6IFwibG93ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQmVmb3JlUGFzdGU6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUgPSBlLnRvTG93ZXJDYXNlKCkpLnJlcGxhY2UoXCJtYWlsdG86XCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIqXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBcIlswLTlcXHVmZjExLVxcdWZmMTlBLVphLXpcXHUwNDEwLVxcdTA0NGZcXHUwNDAxXFx1MDQ1MVxceGMwLVxceGZmXFx4YjUhIyQlJicqKy89P15fYHt8fX4tXVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi1cIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IFwiWzAtOUEtWmEtei1dXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25Vbk1hc2s6IGZ1bmN0aW9uKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dG1vZGU6IFwiZW1haWxcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtYWM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2s6IFwiIyM6IyM6IyM6IyM6IyM6IyNcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB2aW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2s6IFwiVnsxM305ezR9XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBcIltBLUhKLU5QUi1aYS1oai1ucHItelxcXFxkXVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNpbmc6IFwidXBwZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckluY29tcGxldGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1VubWFzazogITBcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3NuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrOiBcIjk5OS05OS05OTk5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0VmFsaWRhdGlvbjogZnVuY3Rpb24oZSwgdCwgYSwgaSwgbiwgcywgbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gby5nZXRNYXNrVGVtcGxhdGUuY2FsbCh0aGlzLCAhMCwgci5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKHRoaXMpLCAhMCwgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAvXig/ITIxOS0wOS05OTk5fDA3OC0wNS0xMTIwKSg/ITY2NnwwMDB8OS57Mn0pLnszfS0oPyEwMCkuezJ9LSg/ITB7NH0pLns0fSQvLnRlc3QodS5qb2luKFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDIwNzogZnVuY3Rpb24oZSwgdCwgYSkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gcyhhKDIzOTQpKSwgbiA9IHMoYSg0NTI4KSksIHIgPSBzKGEoNzE4NCkpLCBvID0gYSg4NzExKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBpLmRlZmF1bHQuZGVwZW5kZW5jeUxpYjtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1KGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IFwiXCIsIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykgaS5kZWZhdWx0LnByb3RvdHlwZS5kZWZpbml0aW9uc1tlLmNoYXJBdChuKV0gfHwgdC5kZWZpbml0aW9uc1tlLmNoYXJBdChuKV0gfHwgdC5vcHRpb25hbG1hcmtlclswXSA9PT0gZS5jaGFyQXQobikgfHwgdC5vcHRpb25hbG1hcmtlclsxXSA9PT0gZS5jaGFyQXQobikgfHwgdC5xdWFudGlmaWVybWFya2VyWzBdID09PSBlLmNoYXJBdChuKSB8fCB0LnF1YW50aWZpZXJtYXJrZXJbMV0gPT09IGUuY2hhckF0KG4pIHx8IHQuZ3JvdXBtYXJrZXJbMF0gPT09IGUuY2hhckF0KG4pIHx8IHQuZ3JvdXBtYXJrZXJbMV0gPT09IGUuY2hhckF0KG4pIHx8IHQuYWx0ZXJuYXRvcm1hcmtlciA9PT0gZS5jaGFyQXQobikgPyBhICs9IFwiXFxcXFwiICsgZS5jaGFyQXQobikgOiBhICs9IGUuY2hhckF0KG4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYyhlLCB0LCBhLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmxlbmd0aCA+IDAgJiYgdCA+IDAgJiYgKCFhLmRpZ2l0c09wdGlvbmFsIHx8IGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUuaW5kZXhPZihhLnJhZGl4UG9pbnQpLCByID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLm5lZ2F0aW9uU3ltYm9sLmJhY2sgPT09IGVbZS5sZW5ndGggLSAxXSAmJiAociA9ICEwLCBlLmxlbmd0aC0tKSwgLTEgPT09IG4gJiYgKGUucHVzaChhLnJhZGl4UG9pbnQpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbyA9IDE7IG8gPD0gdDsgbysrKSBpc0Zpbml0ZShlW24gKyBvXSkgfHwgKGVbbiArIG9dID0gXCIwXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByICYmIGUucHVzaChhLm5lZ2F0aW9uU3ltYm9sLmJhY2spLCBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCIrXCIgPT09IGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYSBpbiB0LnZhbGlkUG9zaXRpb25zKSA7XG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gby5zZWVrTmV4dC5jYWxsKHRoaXMsIHBhcnNlSW50KGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHQudGVzdHMpIGlmICgoaSA9IHBhcnNlSW50KGkpKSA+PSBhKSBmb3IgKHZhciBuID0gMCwgciA9IHQudGVzdHNbaV0ubGVuZ3RoOyBuIDwgcjsgbisrKSBpZiAoKHZvaWQgMCA9PT0gdC52YWxpZFBvc2l0aW9uc1tpXSB8fCBcIi1cIiA9PT0gZSkgJiYgdC50ZXN0c1tpXVtuXS5tYXRjaC5kZWYgPT09IGUpIHJldHVybiBpICsgKHZvaWQgMCAhPT0gdC52YWxpZFBvc2l0aW9uc1tpXSAmJiBcIi1cIiAhPT0gZSA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGQoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHQudmFsaWRQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gdC52YWxpZFBvc2l0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuICYmIG4ubWF0Y2guZGVmID09PSBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHBhcnNlSW50KGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwKGUsIHQsIGEsIGksIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0LmJ1ZmZlciA/IHQuYnVmZmVyLmluZGV4T2Yobi5yYWRpeFBvaW50KSA6IC0xLCBvID0gKC0xICE9PSByIHx8IGkgJiYgbi5qaXRNYXNraW5nKSAmJiBuZXcgUmVnRXhwKG4uZGVmaW5pdGlvbnNbOV0udmFsaWRhdG9yKS50ZXN0KGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbi5fcmFkaXhEYW5jZSAmJiAtMSAhPT0gciAmJiBvICYmIG51bGwgPT0gdC52YWxpZFBvc2l0aW9uc1tyXSA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogciA9PT0gYSA/IHIgKyAxIDogcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjOiBuLnJhZGl4UG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IGFcbiAgICAgICAgICAgICAgICAgICAgfSA6IG87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkuZGVmYXVsdC5leHRlbmRBbGlhc2VzKHtcbiAgICAgICAgICAgICAgICAgICAgbnVtZXJpYzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzazogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucmVwZWF0ID0gMCwgZS5ncm91cFNlcGFyYXRvciA9PT0gZS5yYWRpeFBvaW50ICYmIGUuZGlnaXRzICYmIFwiMFwiICE9PSBlLmRpZ2l0cyAmJiAoXCIuXCIgPT09IGUucmFkaXhQb2ludCA/IGUuZ3JvdXBTZXBhcmF0b3IgPSBcIixcIiA6IFwiLFwiID09PSBlLnJhZGl4UG9pbnQgPyBlLmdyb3VwU2VwYXJhdG9yID0gXCIuXCIgOiBlLmdyb3VwU2VwYXJhdG9yID0gXCJcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIFwiID09PSBlLmdyb3VwU2VwYXJhdG9yICYmIChlLnNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXIgPSB2b2lkIDApLCBlLnBsYWNlaG9sZGVyLmxlbmd0aCA+IDEgJiYgKGUucGxhY2Vob2xkZXIgPSBlLnBsYWNlaG9sZGVyLmNoYXJBdCgwKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicmFkaXhGb2N1c1wiID09PSBlLnBvc2l0aW9uQ2FyZXRPbkNsaWNrICYmIFwiXCIgPT09IGUucGxhY2Vob2xkZXIgJiYgKGUucG9zaXRpb25DYXJldE9uQ2xpY2sgPSBcImx2cFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IFwiMFwiLCBhID0gZS5yYWRpeFBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEwID09PSBlLm51bWVyaWNJbnB1dCAmJiB2b2lkIDAgPT09IGUuX19maW5hbmNlSW5wdXQgPyAodCA9IFwiMVwiLCBlLnBvc2l0aW9uQ2FyZXRPbkNsaWNrID0gXCJyYWRpeEZvY3VzXCIgPT09IGUucG9zaXRpb25DYXJldE9uQ2xpY2sgPyBcImx2cFwiIDogZS5wb3NpdGlvbkNhcmV0T25DbGljaywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5kaWdpdHNPcHRpb25hbCA9ICExLCBpc05hTihlLmRpZ2l0cykgJiYgKGUuZGlnaXRzID0gMiksIGUuX3JhZGl4RGFuY2UgPSAhMSwgYSA9IFwiLFwiID09PSBlLnJhZGl4UG9pbnQgPyBcIj9cIiA6IFwiIVwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiICE9PSBlLnJhZGl4UG9pbnQgJiYgdm9pZCAwID09PSBlLmRlZmluaXRpb25zW2FdICYmIChlLmRlZmluaXRpb25zW2FdID0ge30sIGUuZGVmaW5pdGlvbnNbYV0udmFsaWRhdG9yID0gXCJbXCIgKyBlLnJhZGl4UG9pbnQgKyBcIl1cIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5kZWZpbml0aW9uc1thXS5wbGFjZWhvbGRlciA9IGUucmFkaXhQb2ludCwgZS5kZWZpbml0aW9uc1thXS5zdGF0aWMgPSAhMCwgZS5kZWZpbml0aW9uc1thXS5nZW5lcmF0ZWQgPSAhMCkpIDogKGUuX19maW5hbmNlSW5wdXQgPSAhMSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5udW1lcmljSW5wdXQgPSAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIG4gPSBcIlsrXVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuICs9IHUoZS5wcmVmaXgsIGUpLCBcIlwiICE9PSBlLmdyb3VwU2VwYXJhdG9yID8gKHZvaWQgMCA9PT0gZS5kZWZpbml0aW9uc1tlLmdyb3VwU2VwYXJhdG9yXSAmJiAoZS5kZWZpbml0aW9uc1tlLmdyb3VwU2VwYXJhdG9yXSA9IHt9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmRlZmluaXRpb25zW2UuZ3JvdXBTZXBhcmF0b3JdLnZhbGlkYXRvciA9IFwiW1wiICsgZS5ncm91cFNlcGFyYXRvciArIFwiXVwiLCBlLmRlZmluaXRpb25zW2UuZ3JvdXBTZXBhcmF0b3JdLnBsYWNlaG9sZGVyID0gZS5ncm91cFNlcGFyYXRvciwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5kZWZpbml0aW9uc1tlLmdyb3VwU2VwYXJhdG9yXS5zdGF0aWMgPSAhMCwgZS5kZWZpbml0aW9uc1tlLmdyb3VwU2VwYXJhdG9yXS5nZW5lcmF0ZWQgPSAhMCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gZS5fbWFzayhlKSkgOiBuICs9IFwiOXsrfVwiLCB2b2lkIDAgIT09IGUuZGlnaXRzICYmIDAgIT09IGUuZGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gZS5kaWdpdHMudG9TdHJpbmcoKS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRmluaXRlKG9bMF0pICYmIG9bMV0gJiYgaXNGaW5pdGUob1sxXSkgPyBuICs9IGEgKyB0ICsgXCJ7XCIgKyBlLmRpZ2l0cyArIFwifVwiIDogKGlzTmFOKGUuZGlnaXRzKSB8fCBwYXJzZUludChlLmRpZ2l0cykgPiAwKSAmJiAoZS5kaWdpdHNPcHRpb25hbCB8fCBlLmppdE1hc2tpbmcgPyAoaSA9IG4gKyBhICsgdCArIFwiezAsXCIgKyBlLmRpZ2l0cyArIFwifVwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5rZWVwU3RhdGljID0gITApIDogbiArPSBhICsgdCArIFwie1wiICsgZS5kaWdpdHMgKyBcIn1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGUuaW5wdXRtb2RlID0gXCJudW1lcmljXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gKz0gdShlLnN1ZmZpeCwgZSksIG4gKz0gXCJbLV1cIiwgaSAmJiAobiA9IFsgaSArIHUoZS5zdWZmaXgsIGUpICsgXCJbLV1cIiwgbiBdKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5ncmVlZHkgPSAhMSwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGUucGFyc2VNaW5NYXhPcHRpb25zICYmIChudWxsICE9PSBlLm1pbiAmJiAoZS5taW4gPSBlLm1pbi50b1N0cmluZygpLnJlcGxhY2UobmV3IFJlZ0V4cCgoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIuZGVmYXVsdCkoZS5ncm91cFNlcGFyYXRvciksIFwiZ1wiKSwgXCJcIiksIFwiLFwiID09PSBlLnJhZGl4UG9pbnQgJiYgKGUubWluID0gZS5taW4ucmVwbGFjZShlLnJhZGl4UG9pbnQsIFwiLlwiKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm1pbiA9IGlzRmluaXRlKGUubWluKSA/IHBhcnNlRmxvYXQoZS5taW4pIDogTmFOLCBpc05hTihlLm1pbikgJiYgKGUubWluID0gTnVtYmVyLk1JTl9WQUxVRSkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZS5tYXggJiYgKGUubWF4ID0gZS5tYXgudG9TdHJpbmcoKS5yZXBsYWNlKG5ldyBSZWdFeHAoKDAsIHIuZGVmYXVsdCkoZS5ncm91cFNlcGFyYXRvciksIFwiZ1wiKSwgXCJcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIixcIiA9PT0gZS5yYWRpeFBvaW50ICYmIChlLm1heCA9IGUubWF4LnJlcGxhY2UoZS5yYWRpeFBvaW50LCBcIi5cIikpLCBlLm1heCA9IGlzRmluaXRlKGUubWF4KSA/IHBhcnNlRmxvYXQoZS5tYXgpIDogTmFOLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOYU4oZS5tYXgpICYmIChlLm1heCA9IE51bWJlci5NQVhfVkFMVUUpKSwgZS5wYXJzZU1pbk1heE9wdGlvbnMgPSBcImRvbmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShlKSwgbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBfbWFzazogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIihcIiArIGUuZ3JvdXBTZXBhcmF0b3IgKyBcIjk5OSl7K3wxfVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0czogXCIqXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWdpdHNPcHRpb25hbDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmZvcmNlRGlnaXRzT25CbHVyOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl4UG9pbnQ6IFwiLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25DYXJldE9uQ2xpY2s6IFwicmFkaXhGb2N1c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3JhZGl4RGFuY2U6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBTZXBhcmF0b3I6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd01pbnVzOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZ2F0aW9uU3ltYm9sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbnQ6IFwiLVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2s6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWZmaXg6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW46IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXg6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBTZXRNYXhPbk92ZXJmbG93OiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5tYXNrQXNOdW1iZXI6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91bmRpbmdGTjogTWF0aC5yb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0bW9kZTogXCJkZWNpbWFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG9ydGN1dHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrOiBcIjAwMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG06IFwiMDAwMDAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogXCIwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBncmVlZHk6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRBbGlnbjogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRNb2RlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9Vbm1hc2s6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlcjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZVByb3RvdHlwZURlZmluaXRpb25zOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IHBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uU3ltYm9sOiBcIjlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IFwiWzAtOVxcdWZmMTAtXFx1ZmYxOVxcdTA2NjAtXFx1MDY2OVxcdTA2ZjAtXFx1MDZmOV1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvblN5bWJvbDogXCIqXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiK1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24oZSwgdCwgYSwgaSwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4uYWxsb3dNaW51cyAmJiAoXCItXCIgPT09IGUgfHwgZSA9PT0gbi5uZWdhdGlvblN5bWJvbC5mcm9udCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24oZSwgdCwgYSwgaSwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4uYWxsb3dNaW51cyAmJiBlID09PSBuLm5lZ2F0aW9uU3ltYm9sLmJhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlVmFsaWRhdGlvbjogZnVuY3Rpb24oZSwgdCwgYSwgaSwgbiwgciwgbywgcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMSAhPT0gbi5fX2ZpbmFuY2VJbnB1dCAmJiBhID09PSBuLnJhZGl4UG9pbnQpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobCA9IG4uc2hvcnRjdXRzICYmIG4uc2hvcnRjdXRzW2FdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsLmxlbmd0aCA+IDEpIGZvciAodmFyIHUgPSBbXSwgYyA9IDA7IGMgPCBsLmxlbmd0aDsgYysrKSB1LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiB0ICsgYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM6IGxbY10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3Q6ICExXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0OiB1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gZS5pbmRleE9mKG4ucmFkaXhQb2ludCksIGggPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ID0gZnVuY3Rpb24oZSwgdCwgYSwgaSwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbi5fcmFkaXhEYW5jZSAmJiBuLm51bWVyaWNJbnB1dCAmJiB0ICE9PSBuLm5lZ2F0aW9uU3ltYm9sLmJhY2sgJiYgZSA8PSBhICYmIChhID4gMCB8fCB0ID09IG4ucmFkaXhQb2ludCkgJiYgKHZvaWQgMCA9PT0gaS52YWxpZFBvc2l0aW9uc1tlIC0gMV0gfHwgaS52YWxpZFBvc2l0aW9uc1tlIC0gMV0uaW5wdXQgIT09IG4ubmVnYXRpb25TeW1ib2wuYmFjaykgJiYgKGUgLT0gMSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0odCwgYSwgcCwgciwgbiksIFwiLVwiID09PSBhIHx8IGEgPT09IG4ubmVnYXRpb25TeW1ib2wuZnJvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEwICE9PSBuLmFsbG93TWludXMpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSAhMSwgbSA9IGQoXCIrXCIsIHIpLCBnID0gZChcIi1cIiwgcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMSAhPT0gbSAmJiAodiA9IFsgbSwgZyBdKSwgITEgIT09IHYgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmU6IHYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldDogaCAtIG4ubmVnYXRpb25TeW1ib2wuYmFjay5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydDogWyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBmLmNhbGwodGhpcywgXCIrXCIsIHIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM6IG4ubmVnYXRpb25TeW1ib2wuZnJvbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUlzVmFsaWQ6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBmLmNhbGwodGhpcywgXCItXCIsIHIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM6IG4ubmVnYXRpb25TeW1ib2wuYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tSXNWYWxpZDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldDogaCArIG4ubmVnYXRpb25TeW1ib2wuYmFjay5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPT09IG4uZ3JvdXBTZXBhcmF0b3IpIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0OiBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocykgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gcCAmJiAhMCA9PT0gbi5fcmFkaXhEYW5jZSAmJiAhMSA9PT0gaSAmJiBhID09PSBuLnJhZGl4UG9pbnQgJiYgdm9pZCAwICE9PSBuLmRpZ2l0cyAmJiAoaXNOYU4obi5kaWdpdHMpIHx8IHBhcnNlSW50KG4uZGlnaXRzKSA+IDApICYmIHAgIT09IHQpIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0OiBuLl9yYWRpeERhbmNlICYmIHQgPT09IHAgLSAxID8gcCArIDEgOiBwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITEgPT09IG4uX19maW5hbmNlSW5wdXQpIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLmRpZ2l0c09wdGlvbmFsKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZVBvc2l0aW9uOiBvLmVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW4uZGlnaXRzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLmJlZ2luID4gcCAmJiBvLmVuZCA8PSBwKSByZXR1cm4gYSA9PT0gbi5yYWRpeFBvaW50ID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHAgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjOiBcIjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUlzVmFsaWQ6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlUG9zaXRpb246IHBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZVBvc2l0aW9uOiBwICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLmJlZ2luIDwgcCkgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlUG9zaXRpb246IG8uYmVnaW4gLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghbi5zaG93TWFza09uSG92ZXIgJiYgIW4uc2hvd01hc2tPbkZvY3VzICYmICFuLmRpZ2l0c09wdGlvbmFsICYmIG4uZGlnaXRzID4gMCAmJiBcIlwiID09PSB0aGlzLl9fdmFsdWVHZXQuY2FsbCh0aGlzLmVsKSkgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZVBvc2l0aW9uOiBwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlUG9zaXRpb246IHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RWYWxpZGF0aW9uOiBmdW5jdGlvbihlLCB0LCBhLCBpLCBuLCByLCBvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCExID09PSBpKSByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobykgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBuLm1pbiB8fCBudWxsICE9PSBuLm1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IG4ub25Vbk1hc2soZS5zbGljZSgpLnJldmVyc2UoKS5qb2luKFwiXCIpLCB2b2lkIDAsIGwuZXh0ZW5kKHt9LCBuLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bm1hc2tBc051bWJlcjogITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gbi5taW4gJiYgcyA8IG4ubWluICYmIChzLnRvU3RyaW5nKCkubGVuZ3RoID4gbi5taW4udG9TdHJpbmcoKS5sZW5ndGggfHwgcyA8IDApKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBuLm1heCAmJiBzID4gbi5tYXgpIHJldHVybiAhIW4uU2V0TWF4T25PdmVyZmxvdyAmJiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoRnJvbUJ1ZmZlcjogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXI6IGMobi5tYXgudG9TdHJpbmcoKS5yZXBsYWNlKFwiLlwiLCBuLnJhZGl4UG9pbnQpLnNwbGl0KFwiXCIpLCBuLmRpZ2l0cywgbikucmV2ZXJzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVW5NYXNrOiBmdW5jdGlvbihlLCB0LCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiXCIgPT09IHQgJiYgITAgPT09IGEubnVsbGFibGUpIHJldHVybiB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZS5yZXBsYWNlKGEucHJlZml4LCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSA9IChpID0gaS5yZXBsYWNlKGEuc3VmZml4LCBcIlwiKSkucmVwbGFjZShuZXcgUmVnRXhwKCgwLCByLmRlZmF1bHQpKGEuZ3JvdXBTZXBhcmF0b3IpLCBcImdcIiksIFwiXCIpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiICE9PSBhLnBsYWNlaG9sZGVyLmNoYXJBdCgwKSAmJiAoaSA9IGkucmVwbGFjZShuZXcgUmVnRXhwKGEucGxhY2Vob2xkZXIuY2hhckF0KDApLCBcImdcIiksIFwiMFwiKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEudW5tYXNrQXNOdW1iZXIgPyAoXCJcIiAhPT0gYS5yYWRpeFBvaW50ICYmIC0xICE9PSBpLmluZGV4T2YoYS5yYWRpeFBvaW50KSAmJiAoaSA9IGkucmVwbGFjZShyLmRlZmF1bHQuY2FsbCh0aGlzLCBhLnJhZGl4UG9pbnQpLCBcIi5cIikpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gKGkgPSBpLnJlcGxhY2UobmV3IFJlZ0V4cChcIl5cIiArICgwLCByLmRlZmF1bHQpKGEubmVnYXRpb25TeW1ib2wuZnJvbnQpKSwgXCItXCIpKS5yZXBsYWNlKG5ldyBSZWdFeHAoKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIuZGVmYXVsdCkoYS5uZWdhdGlvblN5bWJvbC5iYWNrKSArIFwiJFwiKSwgXCJcIiksIE51bWJlcihpKSkgOiBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGxldGU6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9ICh0Lm51bWVyaWNJbnB1dCA/IGUuc2xpY2UoKS5yZXZlcnNlKCkgOiBlKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhID0gKGEgPSAoYSA9IChhID0gKGEgPSBhLnJlcGxhY2UobmV3IFJlZ0V4cChcIl5cIiArICgwLCByLmRlZmF1bHQpKHQubmVnYXRpb25TeW1ib2wuZnJvbnQpKSwgXCItXCIpKS5yZXBsYWNlKG5ldyBSZWdFeHAoKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIuZGVmYXVsdCkodC5uZWdhdGlvblN5bWJvbC5iYWNrKSArIFwiJFwiKSwgXCJcIikpLnJlcGxhY2UodC5wcmVmaXgsIFwiXCIpKS5yZXBsYWNlKHQuc3VmZml4LCBcIlwiKSkucmVwbGFjZShuZXcgUmVnRXhwKCgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmRlZmF1bHQpKHQuZ3JvdXBTZXBhcmF0b3IpICsgXCIoWzAtOV17M30pXCIsIFwiZ1wiKSwgXCIkMVwiKSwgXCIsXCIgPT09IHQucmFkaXhQb2ludCAmJiAoYSA9IGEucmVwbGFjZSgoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5kZWZhdWx0KSh0LnJhZGl4UG9pbnQpLCBcIi5cIikpLCBpc0Zpbml0ZShhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZU1hc2s6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHQucmFkaXhQb2ludCB8fCBcIixcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0Zpbml0ZSh0LmRpZ2l0cykgJiYgKHQuZGlnaXRzID0gcGFyc2VJbnQodC5kaWdpdHMpKSwgXCJudW1iZXJcIiAhPSB0eXBlb2YgZSAmJiBcIm51bWJlclwiICE9PSB0LmlucHV0VHlwZSB8fCBcIlwiID09PSBhIHx8IChlID0gZS50b1N0cmluZygpLnJlcGxhY2UoXCIuXCIsIGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IFwiLVwiID09PSBlLmNoYXJBdCgwKSB8fCBlLmNoYXJBdCgwKSA9PT0gdC5uZWdhdGlvblN5bWJvbC5mcm9udCwgbiA9IGUuc3BsaXQoYSksIG8gPSBuWzBdLnJlcGxhY2UoL1teXFwtMC05XS9nLCBcIlwiKSwgcyA9IG4ubGVuZ3RoID4gMSA/IG5bMV0ucmVwbGFjZSgvW14wLTldL2csIFwiXCIpIDogXCJcIiwgbCA9IG4ubGVuZ3RoID4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gbyArIChcIlwiICE9PSBzID8gYSArIHMgOiBzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiXCIgIT09IGEgJiYgKHUgPSB0LmRpZ2l0c09wdGlvbmFsID8gdC5kaWdpdHMgPCBzLmxlbmd0aCA/IHQuZGlnaXRzIDogcy5sZW5ndGggOiB0LmRpZ2l0cywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiAhPT0gcyB8fCAhdC5kaWdpdHNPcHRpb25hbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBNYXRoLnBvdygxMCwgdSB8fCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGUucmVwbGFjZSgoMCwgci5kZWZhdWx0KShhKSwgXCIuXCIpLCBpc05hTihwYXJzZUZsb2F0KGUpKSB8fCAoZSA9ICh0LnJvdW5kaW5nRk4ocGFyc2VGbG9hdChlKSAqIGYpIC8gZikudG9GaXhlZCh1KSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gZS50b1N0cmluZygpLnJlcGxhY2UoXCIuXCIsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gdC5kaWdpdHMgJiYgLTEgIT09IGUuaW5kZXhPZihhKSAmJiAoZSA9IGUuc3Vic3RyaW5nKDAsIGUuaW5kZXhPZihhKSkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSB0Lm1pbiB8fCBudWxsICE9PSB0Lm1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGUudG9TdHJpbmcoKS5yZXBsYWNlKGEsIFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gdC5taW4gJiYgZCA8IHQubWluID8gZSA9IHQubWluLnRvU3RyaW5nKCkucmVwbGFjZShcIi5cIiwgYSkgOiBudWxsICE9PSB0Lm1heCAmJiBkID4gdC5tYXggJiYgKGUgPSB0Lm1heC50b1N0cmluZygpLnJlcGxhY2UoXCIuXCIsIGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgJiYgXCItXCIgIT09IGUuY2hhckF0KDApICYmIChlID0gXCItXCIgKyBlKSwgYyhlLnRvU3RyaW5nKCkuc3BsaXQoXCJcIiksIHUsIHQsIGwpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25CZWZvcmVXcml0ZTogZnVuY3Rpb24oZSwgdCwgYSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG4oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITEgIT09IGkuX19maW5hbmNlSW5wdXQgfHwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBlLmluZGV4T2YoaS5yYWRpeFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xICE9PSBhICYmIGUuc3BsaWNlKGEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIlwiICE9PSBpLmdyb3VwU2VwYXJhdG9yKSBmb3IgKDstMSAhPT0gKGEgPSBlLmluZGV4T2YoaS5ncm91cFNlcGFyYXRvcikpOyApIGUuc3BsaWNlKGEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8sIHMgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gbmV3IFJlZ0V4cChcIiheXCIgKyAoXCJcIiAhPT0gdC5uZWdhdGlvblN5bWJvbC5mcm9udCA/ICgwLCByLmRlZmF1bHQpKHQubmVnYXRpb25TeW1ib2wuZnJvbnQpICsgXCI/XCIgOiBcIlwiKSArICgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5kZWZhdWx0KSh0LnByZWZpeCkgKyBcIikoLiopKFwiICsgKDAsIHIuZGVmYXVsdCkodC5zdWZmaXgpICsgKFwiXCIgIT0gdC5uZWdhdGlvblN5bWJvbC5iYWNrID8gKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmRlZmF1bHQpKHQubmVnYXRpb25TeW1ib2wuYmFjaykgKyBcIj9cIiA6IFwiXCIpICsgXCIkKVwiKS5leGVjKGUuc2xpY2UoKS5yZXZlcnNlKCkuam9pbihcIlwiKSksIGkgPSBhID8gYVsyXSA6IFwiXCIsIG4gPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgJiYgKGkgPSBpLnNwbGl0KHQucmFkaXhQb2ludC5jaGFyQXQoMCkpWzBdLCBuID0gbmV3IFJlZ0V4cChcIl5bMFwiICsgdC5ncm91cFNlcGFyYXRvciArIFwiXSpcIikuZXhlYyhpKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKCFuIHx8ICEoblswXS5sZW5ndGggPiAxIHx8IG5bMF0ubGVuZ3RoID4gMCAmJiBuWzBdLmxlbmd0aCA8IGkubGVuZ3RoKSkgJiYgbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHQsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzKSBmb3IgKHZhciB1ID0gdC5qb2luKFwiXCIpLmxhc3RJbmRleE9mKHNbMF0uc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIikpIC0gKHNbMF0gPT0gcy5pbnB1dCA/IDAgOiAxKSwgZiA9IHNbMF0gPT0gcy5pbnB1dCA/IDEgOiAwLCBkID0gc1swXS5sZW5ndGggLSBmOyBkID4gMDsgZC0tKSBkZWxldGUgdGhpcy5tYXNrc2V0LnZhbGlkUG9zaXRpb25zW3UgKyBkXSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRbdSArIGRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJsdXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjaGVja3ZhbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gaS5taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gaS5vblVuTWFzayh0LnNsaWNlKCkucmV2ZXJzZSgpLmpvaW4oXCJcIiksIHZvaWQgMCwgbC5leHRlbmQoe30sIGksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bm1hc2tBc051bWJlcjogITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBpLm1pbiAmJiBwIDwgaS5taW4pIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEZyb21CdWZmZXI6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogYyhpLm1pbi50b1N0cmluZygpLnJlcGxhY2UoXCIuXCIsIGkucmFkaXhQb2ludCkuc3BsaXQoXCJcIiksIGkuZGlnaXRzLCBpKS5yZXZlcnNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRbdC5sZW5ndGggLSAxXSA9PT0gaS5uZWdhdGlvblN5bWJvbC5mcm9udCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBuZXcgUmVnRXhwKFwiKF5cIiArIChcIlwiICE9IGkubmVnYXRpb25TeW1ib2wuZnJvbnQgPyAoMCwgci5kZWZhdWx0KShpLm5lZ2F0aW9uU3ltYm9sLmZyb250KSArIFwiP1wiIDogXCJcIikgKyAoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmRlZmF1bHQpKGkucHJlZml4KSArIFwiKSguKikoXCIgKyAoMCwgci5kZWZhdWx0KShpLnN1ZmZpeCkgKyAoXCJcIiAhPSBpLm5lZ2F0aW9uU3ltYm9sLmJhY2sgPyAoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmRlZmF1bHQpKGkubmVnYXRpb25TeW1ib2wuYmFjaykgKyBcIj9cIiA6IFwiXCIpICsgXCIkKVwiKS5leGVjKG4odC5zbGljZSgpLCAhMCkucmV2ZXJzZSgpLmpvaW4oXCJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCA9PSAoaCA/IGhbMl0gOiBcIlwiKSAmJiAobyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoRnJvbUJ1ZmZlcjogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBbIDAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBcIlwiICE9PSBpLnJhZGl4UG9pbnQgJiYgdFswXSA9PT0gaS5yYWRpeFBvaW50ICYmIChvICYmIG8uYnVmZmVyID8gby5idWZmZXIuc2hpZnQoKSA6ICh0LnNoaWZ0KCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaEZyb21CdWZmZXI6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBuKHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkuZW5mb3JjZURpZ2l0c09uQmx1cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSAobyA9IG8gfHwge30pICYmIG8uYnVmZmVyIHx8IHQuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLnJlZnJlc2hGcm9tQnVmZmVyID0gITAsIG8uYnVmZmVyID0gYyh2LCBpLmRpZ2l0cywgaSwgITApLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbktleURvd246IGZ1bmN0aW9uKGUsIHQsIGEsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciwgbyA9IGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuY3RybEtleSkgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugbi5kZWZhdWx0LlVQOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dG1hc2suX192YWx1ZVNldC5jYWxsKHRoaXMsIHBhcnNlRmxvYXQodGhpcy5pbnB1dG1hc2sudW5tYXNrZWR2YWx1ZSgpKSArIHBhcnNlSW50KGkuc3RlcCkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby50cmlnZ2VyKFwic2V0dmFsdWVcIiksICExO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG4uZGVmYXVsdC5ET1dOOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dG1hc2suX192YWx1ZVNldC5jYWxsKHRoaXMsIHBhcnNlRmxvYXQodGhpcy5pbnB1dG1hc2sudW5tYXNrZWR2YWx1ZSgpKSAtIHBhcnNlSW50KGkuc3RlcCkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby50cmlnZ2VyKFwic2V0dmFsdWVcIiksICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUuc2hpZnRLZXkgJiYgKGUua2V5Q29kZSA9PT0gbi5kZWZhdWx0LkRFTEVURSB8fCBlLmtleUNvZGUgPT09IG4uZGVmYXVsdC5CQUNLU1BBQ0UgfHwgZS5rZXlDb2RlID09PSBuLmRlZmF1bHQuQkFDS1NQQUNFX1NBRkFSSSkgJiYgYS5iZWdpbiAhPT0gdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRbZS5rZXlDb2RlID09PSBuLmRlZmF1bHQuREVMRVRFID8gYS5iZWdpbiAtIDEgOiBhLmVuZF0gPT09IGkubmVnYXRpb25TeW1ib2wuZnJvbnQpIHJldHVybiByID0gdC5zbGljZSgpLnJldmVyc2UoKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIgIT09IGkubmVnYXRpb25TeW1ib2wuZnJvbnQgJiYgci5zaGlmdCgpLCBcIlwiICE9PSBpLm5lZ2F0aW9uU3ltYm9sLmJhY2sgJiYgci5wb3AoKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8udHJpZ2dlcihcInNldHZhbHVlXCIsIFsgci5qb2luKFwiXCIpLCBhLmJlZ2luIF0pLCAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEwID09PSBpLl9yYWRpeERhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHQuaW5kZXhPZihpLnJhZGl4UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkuZGlnaXRzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gcykgcmV0dXJuIChyID0gdC5zbGljZSgpLnJldmVyc2UoKSkucG9wKCksIG8udHJpZ2dlcihcInNldHZhbHVlXCIsIFsgci5qb2luKFwiXCIpLCBhLmJlZ2luID49IHIubGVuZ3RoID8gci5sZW5ndGggOiBhLmJlZ2luIF0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoLTEgIT09IHMgJiYgKGEuYmVnaW4gPCBzIHx8IGEuZW5kIDwgcyB8fCBlLmtleUNvZGUgPT09IG4uZGVmYXVsdC5ERUxFVEUgJiYgYS5iZWdpbiA9PT0gcykpIHJldHVybiBhLmJlZ2luICE9PSBhLmVuZCB8fCBlLmtleUNvZGUgIT09IG4uZGVmYXVsdC5CQUNLU1BBQ0UgJiYgZS5rZXlDb2RlICE9PSBuLmRlZmF1bHQuQkFDS1NQQUNFX1NBRkFSSSB8fCBhLmJlZ2luKyssIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHIgPSB0LnNsaWNlKCkucmV2ZXJzZSgpKS5zcGxpY2Uoci5sZW5ndGggLSBhLmJlZ2luLCBhLmJlZ2luIC0gYS5lbmQgKyAxKSwgciA9IGMociwgaS5kaWdpdHMsIGkpLmpvaW4oXCJcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby50cmlnZ2VyKFwic2V0dmFsdWVcIiwgWyByLCBhLmJlZ2luID49IHIubGVuZ3RoID8gcyArIDEgOiBhLmJlZ2luIF0pLCAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVuY3k6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwU2VwYXJhdG9yOiBcIixcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiBcIm51bWVyaWNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0czogMixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0c09wdGlvbmFsOiAhMVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlhczogXCJudW1lcmljXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXM6IFwibnVtZXJpY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRtb2RlOiBcIm51bWVyaWNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0czogMFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50YWdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlhczogXCJudW1lcmljXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXg6IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeDogXCIgJVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dNaW51czogITFcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaW5kaWFubnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiBcIm51bWVyaWNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tYXNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiKFwiICsgZS5ncm91cFNlcGFyYXRvciArIFwiOTkpeyp8MX0oXCIgKyBlLmdyb3VwU2VwYXJhdG9yICsgXCI5OTkpezF8MX1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cFNlcGFyYXRvcjogXCIsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpeFBvaW50OiBcIi5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0czogMixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0c09wdGlvbmFsOiAhMVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgOTM4MDogZnVuY3Rpb24oZSwgdCwgYSkge1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICAgICAgICB9KSwgdC5kZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBuID0gKChpID0gYSg4NzQxKSkgJiYgaS5fX2VzTW9kdWxlID8gaSA6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogaVxuICAgICAgICAgICAgICAgIH0pLmRlZmF1bHQgPyB3aW5kb3cgOiB7fTtcbiAgICAgICAgICAgICAgICB0LmRlZmF1bHQgPSBuO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDc3NjA6IGZ1bmN0aW9uKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQuYXBwbHlJbnB1dFZhbHVlID0gYywgdC5jbGVhck9wdGlvbmFsVGFpbCA9IGYsIHQuY2hlY2tWYWwgPSBkLCB0LkhhbmRsZU5hdGl2ZVBsYWNlaG9sZGVyID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGUgPyBlLmlucHV0bWFzayA6IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsLmllKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5pbnB1dG1hc2suX3ZhbHVlR2V0KCkgIT09IHQgJiYgKGUucGxhY2Vob2xkZXIgIT09IHQgfHwgXCJcIiA9PT0gZS5wbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IG8uZ2V0QnVmZmVyLmNhbGwoYSkuc2xpY2UoKSwgbiA9IGUuaW5wdXRtYXNrLl92YWx1ZUdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuICE9PSB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gby5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtMSA9PT0gciAmJiBuID09PSBvLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoYSkuam9pbihcIlwiKSA/IGkgPSBbXSA6IC0xICE9PSByICYmIGYuY2FsbChhLCBpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAoZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZS5wbGFjZWhvbGRlciAhPT0gdCAmJiAoZS5wbGFjZWhvbGRlciA9IHQsIFwiXCIgPT09IGUucGxhY2Vob2xkZXIgJiYgZS5yZW1vdmVBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiKSk7XG4gICAgICAgICAgICAgICAgfSwgdC51bm1hc2tlZHZhbHVlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUgPyBlLmlucHV0bWFzayA6IHRoaXMsIGEgPSB0Lm9wdHMsIGkgPSB0Lm1hc2tzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBlLmlucHV0bWFzaykgcmV0dXJuIGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmlucHV0bWFzayAmJiBlLmlucHV0bWFzay5yZWZyZXNoVmFsdWUgJiYgYyhlLCBlLmlucHV0bWFzay5fdmFsdWVHZXQoITApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IFtdLCByID0gaS52YWxpZFBvc2l0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcyBpbiByKSByW3NdICYmIHJbc10ubWF0Y2ggJiYgKDEgIT0gcltzXS5tYXRjaC5zdGF0aWMgfHwgQXJyYXkuaXNBcnJheShpLm1ldGFkYXRhKSAmJiAhMCAhPT0gcltzXS5nZW5lcmF0ZWRJbnB1dCkgJiYgbi5wdXNoKHJbc10uaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IDAgPT09IG4ubGVuZ3RoID8gXCJcIiA6ICh0LmlzUlRMID8gbi5yZXZlcnNlKCkgOiBuKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBhLm9uVW5NYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9ICh0LmlzUlRMID8gby5nZXRCdWZmZXIuY2FsbCh0KS5zbGljZSgpLnJldmVyc2UoKSA6IG8uZ2V0QnVmZmVyLmNhbGwodCkpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gYS5vblVuTWFzay5jYWxsKHQsIHUsIGwsIGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICAgICAgICAgIH0sIHQud3JpdGVCdWZmZXIgPSBwO1xuICAgICAgICAgICAgICAgIHZhciBpLCBuID0gKGkgPSBhKDQ1MjgpKSAmJiBpLl9fZXNNb2R1bGUgPyBpIDoge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBpXG4gICAgICAgICAgICAgICAgfSwgciA9IGEoNDcxMyksIG8gPSBhKDg3MTEpLCBzID0gYSg3MjE1KSwgbCA9IGEoOTg0NSksIHUgPSBhKDYwMzApO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGMoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGUgPyBlLmlucHV0bWFzayA6IHRoaXMsIGkgPSBhLm9wdHM7XG4gICAgICAgICAgICAgICAgICAgIGUuaW5wdXRtYXNrLnJlZnJlc2hWYWx1ZSA9ICExLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGkub25CZWZvcmVNYXNrICYmICh0ID0gaS5vbkJlZm9yZU1hc2suY2FsbChhLCB0LCBpKSB8fCB0KSwgXG4gICAgICAgICAgICAgICAgICAgIGQoZSwgITAsICExLCB0ID0gdC50b1N0cmluZygpLnNwbGl0KFwiXCIpKSwgYS51bmRvVmFsdWUgPSBhLl92YWx1ZUdldCghMCksIChpLmNsZWFyTWFza09uTG9zdEZvY3VzIHx8IGkuY2xlYXJJbmNvbXBsZXRlKSAmJiBlLmlucHV0bWFzay5fdmFsdWVHZXQoKSA9PT0gby5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKGEpLmpvaW4oXCJcIikgJiYgLTEgPT09IG8uZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChhKSAmJiBlLmlucHV0bWFzay5fdmFsdWVTZXQoXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGYoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQsIGEgPSByLmdldE1hc2tUZW1wbGF0ZS5jYWxsKHRoaXMsICEwLCAwLCAhMCwgdm9pZCAwLCAhMCk7IHZvaWQgMCAhPT0gKHQgPSBhLnNoaWZ0KCkpOyApIGUucHVzaCh0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGQoZSwgdCwgYSwgaSwgbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IGUgPyBlLmlucHV0bWFzayA6IHRoaXMsIGMgPSBsLm1hc2tzZXQsIGYgPSBsLm9wdHMsIGQgPSBsLmRlcGVuZGVuY3lMaWIsIGggPSBpLnNsaWNlKCksIHYgPSBcIlwiLCBtID0gLTEsIGcgPSB2b2lkIDAsIGsgPSBmLnNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIGYuc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlciA9IFwiXCIsIG8ucmVzZXRNYXNrU2V0LmNhbGwobCksIGMudGVzdHMgPSB7fSwgbSA9IGYucmFkaXhQb2ludCA/IG8uZGV0ZXJtaW5lTmV3Q2FyZXRQb3NpdGlvbi5jYWxsKGwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiAwXG4gICAgICAgICAgICAgICAgICAgIH0sICExLCAhMSA9PT0gZi5fX2ZpbmFuY2VJbnB1dCA/IFwicmFkaXhGb2N1c1wiIDogdm9pZCAwKS5iZWdpbiA6IDAsIGMucCA9IG0sIGwuY2FyZXRQb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbjogbVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IFtdLCBiID0gbC5jYXJldFBvcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGguZm9yRWFjaCgoZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gbmV3IGQuRXZlbnQoXCJfY2hlY2t2YWxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS53aGljaCA9IGUudG9TdHJpbmcoKS5jaGFyQ29kZUF0KDApLCB2ICs9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBvLmdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwobCwgdm9pZCAwLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IHIuZ2V0TWFza1RlbXBsYXRlLmNhbGwobCwgITAsIDApLnNsaWNlKGUsIG8uc2Vla05leHQuY2FsbChsLCBlLCAhMSwgITEpKS5qb2luKFwiXCIpLnJlcGxhY2UoLycvZywgXCJcIiksIGkgPSBhLmluZGV4T2YodCk7IGkgPiAwICYmIFwiIFwiID09PSBhW2kgLSAxXTsgKSBpLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gMCA9PT0gaSAmJiAhby5pc01hc2suY2FsbChsLCBlKSAmJiAoci5nZXRUZXN0LmNhbGwobCwgZSkubWF0Y2gubmF0aXZlRGVmID09PSB0LmNoYXJBdCgwKSB8fCAhMCA9PT0gci5nZXRUZXN0LmNhbGwobCwgZSkubWF0Y2guc3RhdGljICYmIHIuZ2V0VGVzdC5jYWxsKGwsIGUpLm1hdGNoLm5hdGl2ZURlZiA9PT0gXCInXCIgKyB0LmNoYXJBdCgwKSB8fCBcIiBcIiA9PT0gci5nZXRUZXN0LmNhbGwobCwgZSkubWF0Y2gubmF0aXZlRGVmICYmIChyLmdldFRlc3QuY2FsbChsLCBlICsgMSkubWF0Y2gubmF0aXZlRGVmID09PSB0LmNoYXJBdCgwKSB8fCAhMCA9PT0gci5nZXRUZXN0LmNhbGwobCwgZSArIDEpLm1hdGNoLnN0YXRpYyAmJiByLmdldFRlc3QuY2FsbChsLCBlICsgMSkubWF0Y2gubmF0aXZlRGVmID09PSBcIidcIiArIHQuY2hhckF0KDApKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbiAmJiBpID4gMCAmJiAhby5pc01hc2suY2FsbChsLCBlLCAhMSwgITApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IG8uc2Vla05leHQuY2FsbChsLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwuY2FyZXRQb3MuYmVnaW4gPCBzICYmIChsLmNhcmV0UG9zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luOiBzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KG0sIHYpID8gKGcgPSB1LkV2ZW50SGFuZGxlcnMua2V5cHJlc3NFdmVudC5jYWxsKGwsIGksICEwLCAhMSwgYSwgbC5jYXJldFBvcy5iZWdpbikpICYmIChtID0gbC5jYXJldFBvcy5iZWdpbiArIDEsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBcIlwiKSA6IGcgPSB1LkV2ZW50SGFuZGxlcnMua2V5cHJlc3NFdmVudC5jYWxsKGwsIGksICEwLCAhMSwgYSwgbiArIDEpLCBnID8gKHZvaWQgMCAhPT0gZy5wb3MgJiYgYy52YWxpZFBvc2l0aW9uc1tnLnBvc10gJiYgITAgPT09IGMudmFsaWRQb3NpdGlvbnNbZy5wb3NdLm1hdGNoLnN0YXRpYyAmJiB2b2lkIDAgPT09IGMudmFsaWRQb3NpdGlvbnNbZy5wb3NdLmFsdGVybmF0aW9uICYmICh5LnB1c2goZy5wb3MpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsLmlzUlRMIHx8IChnLmZvcndhcmRQb3NpdGlvbiA9IGcucG9zICsgMSkpLCBwLmNhbGwobCwgdm9pZCAwLCBvLmdldEJ1ZmZlci5jYWxsKGwpLCBnLmZvcndhcmRQb3NpdGlvbiwgaSwgITEpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsLmNhcmV0UG9zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbjogZy5mb3J3YXJkUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZy5mb3J3YXJkUG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBiID0gbC5jYXJldFBvcykgOiB2b2lkIDAgPT09IGMudmFsaWRQb3NpdGlvbnNbdF0gJiYgaFt0XSA9PT0gci5nZXRQbGFjZWhvbGRlci5jYWxsKGwsIHQpICYmIG8uaXNNYXNrLmNhbGwobCwgdCwgITApID8gbC5jYXJldFBvcy5iZWdpbisrIDogbC5jYXJldFBvcyA9IGI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKSwgeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCwgUCwgRSA9IG8uc2Vla05leHQuY2FsbChsLCAtMSwgdm9pZCAwLCAhMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXMuaXNDb21wbGV0ZS5jYWxsKGwsIG8uZ2V0QnVmZmVyLmNhbGwobCkpICYmIHkubGVuZ3RoIDw9IEUgfHwgcy5pc0NvbXBsZXRlLmNhbGwobCwgby5nZXRCdWZmZXIuY2FsbChsKSkgJiYgeS5sZW5ndGggPiAwICYmIHkubGVuZ3RoICE9PSBFICYmIDAgPT09IHlbMF0pIGZvciAodmFyIFMgPSBFOyB2b2lkIDAgIT09ICh4ID0geS5zaGlmdCgpKTsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF8gPSBuZXcgZC5FdmVudChcIl9jaGVja3ZhbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKFAgPSBjLnZhbGlkUG9zaXRpb25zW3hdKS5nZW5lcmF0ZWRJbnB1dCA9ICEwLCBfLndoaWNoID0gUC5pbnB1dC5jaGFyQ29kZUF0KDApLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZyA9IHUuRXZlbnRIYW5kbGVycy5rZXlwcmVzc0V2ZW50LmNhbGwobCwgXywgITAsICExLCBhLCBTKSkgJiYgdm9pZCAwICE9PSBnLnBvcyAmJiBnLnBvcyAhPT0geCAmJiBjLnZhbGlkUG9zaXRpb25zW2cucG9zXSAmJiAhMCA9PT0gYy52YWxpZFBvc2l0aW9uc1tnLnBvc10ubWF0Y2guc3RhdGljKSB5LnB1c2goZy5wb3MpOyBlbHNlIGlmICghZykgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHQgJiYgcC5jYWxsKGwsIGUsIG8uZ2V0QnVmZmVyLmNhbGwobCksIGcgPyBnLmZvcndhcmRQb3NpdGlvbiA6IGwuY2FyZXRQb3MuYmVnaW4sIG4gfHwgbmV3IGQuRXZlbnQoXCJjaGVja3ZhbFwiKSwgbiAmJiBcImlucHV0XCIgPT09IG4udHlwZSAmJiBsLnVuZG9WYWx1ZSAhPT0gbC5fdmFsdWVHZXQoITApKSwgXG4gICAgICAgICAgICAgICAgICAgIGYuc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlciA9IGs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHAoZSwgdCwgYSwgaSwgcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IGUgPyBlLmlucHV0bWFzayA6IHRoaXMsIHUgPSBsLm9wdHMsIGMgPSBsLmRlcGVuZGVuY3lMaWI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdS5vbkJlZm9yZVdyaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IHUub25CZWZvcmVXcml0ZS5jYWxsKGwsIGksIHQsIGEsIHUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZi5yZWZyZXNoRnJvbUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGYucmVmcmVzaEZyb21CdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMucmVmcmVzaEZyb21CdWZmZXIuY2FsbChsLCAhMCA9PT0gZCA/IGQgOiBkLnN0YXJ0LCBkLmVuZCwgZi5idWZmZXIgfHwgdCksIHQgPSBvLmdldEJ1ZmZlci5jYWxsKGwsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBhICYmIChhID0gdm9pZCAwICE9PSBmLmNhcmV0ID8gZi5jYXJldCA6IGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGUgJiYgKGUuaW5wdXRtYXNrLl92YWx1ZVNldCh0LmpvaW4oXCJcIikpLCB2b2lkIDAgPT09IGEgfHwgdm9pZCAwICE9PSBpICYmIFwiYmx1clwiID09PSBpLnR5cGUgfHwgby5jYXJldC5jYWxsKGwsIGUsIGEsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAgIT09IGkgJiYgXCJrZXlkb3duXCIgPT09IGkudHlwZSAmJiAoaS5rZXlDb2RlID09PSBuLmRlZmF1bHQuREVMRVRFIHx8IGkua2V5Q29kZSA9PT0gbi5kZWZhdWx0LkJBQ0tTUEFDRSkpLCBcbiAgICAgICAgICAgICAgICAgICAgITAgPT09IHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IGMoZSksIGggPSBlLmlucHV0bWFzay5fdmFsdWVHZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuaW5wdXRtYXNrLnNraXBJbnB1dEV2ZW50ID0gITAsIHAudHJpZ2dlcihcImlucHV0XCIpLCBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoID09PSBvLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwobCkuam9pbihcIlwiKSA/IHAudHJpZ2dlcihcImNsZWFyZWRcIikgOiAhMCA9PT0gcy5pc0NvbXBsZXRlLmNhbGwobCwgdCkgJiYgcC50cmlnZ2VyKFwiY29tcGxldGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMjM5NDogZnVuY3Rpb24oZSwgdCwgYSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICAgICAgICB9KSwgdC5kZWZhdWx0ID0gdm9pZCAwLCBhKDcxNDkpLCBhKDMxOTQpO1xuICAgICAgICAgICAgICAgIHZhciBpID0gYSgxNTcpLCBuID0gbShhKDQ5NjMpKSwgciA9IG0oYSg5MzgwKSksIG8gPSBhKDIzOTEpLCBzID0gYSg0NzEzKSwgbCA9IGEoODcxMSksIHUgPSBhKDcyMTUpLCBjID0gYSg3NzYwKSwgZiA9IGEoOTcxNiksIGQgPSBtKGEoNzM5MikpLCBwID0gbShhKDM5NzYpKSwgaCA9IG0oYSg4NzQxKSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZTtcbiAgICAgICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIGUuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBlICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBlO1xuICAgICAgICAgICAgICAgICAgICB9KShlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbShlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBnID0gci5kZWZhdWx0LmRvY3VtZW50LCBrID0gXCJfaW5wdXRtYXNrX29wdHNcIjtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB5KGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGguZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHkpKSByZXR1cm4gbmV3IHkoZSwgdCwgYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lMaWIgPSBuLmRlZmF1bHQsIHRoaXMuZWwgPSB2b2lkIDAsIHRoaXMuZXZlbnRzID0ge30sIHRoaXMubWFza3NldCA9IHZvaWQgMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAhMCAhPT0gYSAmJiAoXCJbb2JqZWN0IE9iamVjdF1cIiA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpID8gdCA9IGUgOiAodCA9IHQgfHwge30sIFxuICAgICAgICAgICAgICAgICAgICAgICAgZSAmJiAodC5hbGlhcyA9IGUpKSwgdGhpcy5vcHRzID0gbi5kZWZhdWx0LmV4dGVuZCghMCwge30sIHRoaXMuZGVmYXVsdHMsIHQpLCB0aGlzLm5vTWFza3NDYWNoZSA9IHQgJiYgdm9pZCAwICE9PSB0LmRlZmluaXRpb25zLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlck9wdGlvbnMgPSB0IHx8IHt9LCBiKHRoaXMub3B0cy5hbGlhcywgdCwgdGhpcy5vcHRzKSksIHRoaXMucmVmcmVzaFZhbHVlID0gITEsIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bmRvVmFsdWUgPSB2b2lkIDAsIHRoaXMuJGVsID0gdm9pZCAwLCB0aGlzLnNraXBLZXlQcmVzc0V2ZW50ID0gITEsIHRoaXMuc2tpcElucHV0RXZlbnQgPSAhMSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRpb25FdmVudCA9ICExLCB0aGlzLmlnbm9yYWJsZSA9ICExLCB0aGlzLm1heExlbmd0aCwgdGhpcy5tb3VzZUVudGVyID0gITEsIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmlnaW5hbFBsYWNlaG9sZGVyID0gdm9pZCAwLCB0aGlzLmlzQ29tcG9zaW5nID0gITE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYihlLCB0LCBhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0geS5wcm90b3R5cGUuYWxpYXNlc1tlXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgPyAoaS5hbGlhcyAmJiBiKGkuYWxpYXMsIHZvaWQgMCwgYSksIG4uZGVmYXVsdC5leHRlbmQoITAsIGEsIGkpLCBuLmRlZmF1bHQuZXh0ZW5kKCEwLCBhLCB0KSwgXG4gICAgICAgICAgICAgICAgICAgICEwKSA6IChudWxsID09PSBhLm1hc2sgJiYgKGEubWFzayA9IGUpLCAhMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHkucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhQXR0cmlidXRlOiBcImRhdGEtaW5wdXRtYXNrXCIsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzOiBwLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25zOiBkLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzZXM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBtYXNrc0NhY2hlOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGlzUlRMKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0cy5pc1JUTCB8fCB0aGlzLm9wdHMubnVtZXJpY0lucHV0O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtYXNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiAoZSA9IGcuZ2V0RWxlbWVudEJ5SWQoZSkgfHwgZy5xdWVyeVNlbGVjdG9yQWxsKGUpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAoZSA9IGUubm9kZU5hbWUgPyBbIGUgXSA6IEFycmF5LmlzQXJyYXkoZSkgPyBlIDogQXJyYXkuZnJvbShlKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSwgYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gbi5kZWZhdWx0LmV4dGVuZCghMCwge30sIHQub3B0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uKGUsIHQsIGEsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbyh0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IFwiXCIgPT09IGkgPyB0IDogaSArIFwiLVwiICsgdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IChuID0gdm9pZCAwICE9PSBuID8gbiA6IGUuZ2V0QXR0cmlidXRlKG8pKSAmJiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgbiAmJiAoMCA9PT0gdC5pbmRleE9mKFwib25cIikgPyBuID0gci5kZWZhdWx0W25dIDogXCJmYWxzZVwiID09PSBuID8gbiA9ICExIDogXCJ0cnVlXCIgPT09IG4gJiYgKG4gPSAhMCkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbdF0gPSBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITAgPT09IHQuaW1wb3J0RGF0YUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzLCBsLCB1LCBjLCBmID0gZS5nZXRBdHRyaWJ1dGUoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZiAmJiBcIlwiICE9PSBmICYmIChmID0gZi5yZXBsYWNlKC8nL2csICdcIicpLCBsID0gSlNPTi5wYXJzZShcIntcIiArIGYgKyBcIn1cIikpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwpIGZvciAoYyBpbiB1ID0gdm9pZCAwLCBsKSBpZiAoXCJhbGlhc1wiID09PSBjLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gbFtjXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocyBpbiBvKFwiYWxpYXNcIiwgdSksIGEuYWxpYXMgJiYgYihhLmFsaWFzLCBhLCB0KSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsKSBmb3IgKGMgaW4gdSA9IHZvaWQgMCwgbCkgaWYgKGMudG9Mb3dlckNhc2UoKSA9PT0gcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBsW2NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyhzLCB1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLmRlZmF1bHQuZXh0ZW5kKCEwLCB0LCBhKSwgKFwicnRsXCIgPT09IGUuZGlyIHx8IHQucmlnaHRBbGlnbikgJiYgKGUuc3R5bGUudGV4dEFsaWduID0gXCJyaWdodFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwicnRsXCIgPT09IGUuZGlyIHx8IHQubnVtZXJpY0lucHV0KSAmJiAoZS5kaXIgPSBcImx0clwiLCBlLnJlbW92ZUF0dHJpYnV0ZShcImRpclwiKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuaXNSVEwgPSAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShlLCBzLCBuLmRlZmF1bHQuZXh0ZW5kKCEwLCB7fSwgdC51c2VyT3B0aW9ucyksIHQuZGF0YUF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSAoMCwgby5nZW5lcmF0ZU1hc2tTZXQpKHMsIHQubm9NYXNrc0NhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBsICYmICh2b2lkIDAgIT09IGUuaW5wdXRtYXNrICYmIChlLmlucHV0bWFzay5vcHRzLmF1dG9Vbm1hc2sgPSAhMCwgZS5pbnB1dG1hc2sucmVtb3ZlKCkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5pbnB1dG1hc2sgPSBuZXcgeSh2b2lkIDAsIHZvaWQgMCwgITApLCBlLmlucHV0bWFzay5vcHRzID0gcywgZS5pbnB1dG1hc2subm9NYXNrc0NhY2hlID0gdC5ub01hc2tzQ2FjaGUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmlucHV0bWFzay51c2VyT3B0aW9ucyA9IG4uZGVmYXVsdC5leHRlbmQoITAsIHt9LCB0LnVzZXJPcHRpb25zKSwgZS5pbnB1dG1hc2suZWwgPSBlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5pbnB1dG1hc2suJGVsID0gKDAsIG4uZGVmYXVsdCkoZSksIGUuaW5wdXRtYXNrLm1hc2tzZXQgPSBsLCBuLmRlZmF1bHQuZGF0YShlLCBrLCB0LnVzZXJPcHRpb25zKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkubWFzay5jYWxsKGUuaW5wdXRtYXNrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpLCBlICYmIGVbMF0gJiYgZVswXS5pbnB1dG1hc2sgfHwgdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IHRoaXMub3B0c1tlXSA6IFwib2JqZWN0XCIgPT09IHYoZSkgPyAobi5kZWZhdWx0LmV4dGVuZCh0aGlzLnVzZXJPcHRpb25zLCBlKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsICYmICEwICE9PSB0ICYmIHRoaXMubWFzayh0aGlzLmVsKSwgdGhpcykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVubWFza2VkdmFsdWU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hc2tzZXQgPSB0aGlzLm1hc2tzZXQgfHwgKDAsIG8uZ2VuZXJhdGVNYXNrU2V0KSh0aGlzLm9wdHMsIHRoaXMubm9NYXNrc0NhY2hlKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHRoaXMuZWwgfHwgdm9pZCAwICE9PSBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSAoXCJmdW5jdGlvblwiID09IHR5cGVvZiB0aGlzLm9wdHMub25CZWZvcmVNYXNrICYmIHRoaXMub3B0cy5vbkJlZm9yZU1hc2suY2FsbCh0aGlzLCBlLCB0aGlzLm9wdHMpIHx8IGUpLnNwbGl0KFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuY2hlY2tWYWwuY2FsbCh0aGlzLCB2b2lkIDAsICExLCAhMSwgdCksIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdGhpcy5vcHRzLm9uQmVmb3JlV3JpdGUgJiYgdGhpcy5vcHRzLm9uQmVmb3JlV3JpdGUuY2FsbCh0aGlzLCB2b2lkIDAsIGwuZ2V0QnVmZmVyLmNhbGwodGhpcyksIDAsIHRoaXMub3B0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYy51bm1hc2tlZHZhbHVlLmNhbGwodGhpcywgdGhpcy5lbCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4uZGVmYXVsdC5kYXRhKHRoaXMuZWwsIGssIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5vcHRzLmF1dG9Vbm1hc2sgPyAoMCwgYy51bm1hc2tlZHZhbHVlKSh0aGlzLmVsKSA6IHRoaXMuX3ZhbHVlR2V0KHRoaXMub3B0cy5hdXRvVW5tYXNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlICE9PSBsLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwodGhpcykuam9pbihcIlwiKSA/IHRoaXMuX3ZhbHVlU2V0KGUsIHRoaXMub3B0cy5hdXRvVW5tYXNrKSA6IHRoaXMuX3ZhbHVlU2V0KFwiXCIpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLkV2ZW50UnVsZXIub2ZmKHRoaXMuZWwpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMuZWwpLCBcInZhbHVlXCIpICYmIHRoaXMuX192YWx1ZUdldCAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbCwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogdGhpcy5fX3ZhbHVlR2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IHRoaXMuX192YWx1ZVNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogZy5fX2xvb2t1cEdldHRlcl9fICYmIHRoaXMuZWwuX19sb29rdXBHZXR0ZXJfXyhcInZhbHVlXCIpICYmIHRoaXMuX192YWx1ZUdldCAmJiAodGhpcy5lbC5fX2RlZmluZUdldHRlcl9fKFwidmFsdWVcIiwgdGhpcy5fX3ZhbHVlR2V0KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5fX2RlZmluZVNldHRlcl9fKFwidmFsdWVcIiwgdGhpcy5fX3ZhbHVlU2V0KSksIHRoaXMuZWwuaW5wdXRtYXNrID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWw7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldGVtcHR5bWFzazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXNrc2V0ID0gdGhpcy5tYXNrc2V0IHx8ICgwLCBvLmdlbmVyYXRlTWFza1NldCkodGhpcy5vcHRzLCB0aGlzLm5vTWFza3NDYWNoZSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgbC5nZXRCdWZmZXJUZW1wbGF0ZS5jYWxsKHRoaXMpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGhhc01hc2tlZFZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5vcHRzLmF1dG9Vbm1hc2s7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGlzQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFza3NldCA9IHRoaXMubWFza3NldCB8fCAoMCwgby5nZW5lcmF0ZU1hc2tTZXQpKHRoaXMub3B0cywgdGhpcy5ub01hc2tzQ2FjaGUpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHUuaXNDb21wbGV0ZS5jYWxsKHRoaXMsIGwuZ2V0QnVmZmVyLmNhbGwodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRtZXRhZGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXNrc2V0ID0gdGhpcy5tYXNrc2V0IHx8ICgwLCBvLmdlbmVyYXRlTWFza1NldCkodGhpcy5vcHRzLCB0aGlzLm5vTWFza3NDYWNoZSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLm1hc2tzZXQubWV0YWRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBzLmdldE1hc2tUZW1wbGF0ZS5jYWxsKHRoaXMsICEwLCAwLCAhMSkuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXNrc2V0Lm1ldGFkYXRhLmZvckVhY2goKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQubWFzayAhPT0gZSB8fCAoZSA9IHQsICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSksIGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXNrc2V0Lm1ldGFkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXNrc2V0ID0gdGhpcy5tYXNrc2V0IHx8ICgwLCBvLmdlbmVyYXRlTWFza1NldCkodGhpcy5vcHRzLCB0aGlzLm5vTWFza3NDYWNoZSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdGhpcy5vcHRzLm9uQmVmb3JlTWFzayAmJiB0aGlzLm9wdHMub25CZWZvcmVNYXNrLmNhbGwodGhpcywgZSwgdGhpcy5vcHRzKSB8fCBlKS5zcGxpdChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmNoZWNrVmFsLmNhbGwodGhpcywgdm9pZCAwLCAhMCwgITEsIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGUgPSB0aGlzLmlzUlRMID8gbC5nZXRCdWZmZXIuY2FsbCh0aGlzKS5zbGljZSgpLnJldmVyc2UoKS5qb2luKFwiXCIpIDogbC5nZXRCdWZmZXIuY2FsbCh0aGlzKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IGwuZ2V0QnVmZmVyLmNhbGwodGhpcyksIGkgPSBsLmRldGVybWluZUxhc3RSZXF1aXJlZFBvc2l0aW9uLmNhbGwodGhpcyksIG4gPSBhLmxlbmd0aCAtIDE7IG4gPiBpICYmICFsLmlzTWFzay5jYWxsKHRoaXMsIG4pOyBuLS0pIDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLnNwbGljZShpLCBuICsgMSAtIGkpLCB1LmlzQ29tcGxldGUuY2FsbCh0aGlzLCBhKSAmJiBlID09PSAodGhpcy5pc1JUTCA/IGwuZ2V0QnVmZmVyLmNhbGwodGhpcykuc2xpY2UoKS5yZXZlcnNlKCkuam9pbihcIlwiKSA6IGwuZ2V0QnVmZmVyLmNhbGwodGhpcykuam9pbihcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXNrc2V0ID0gdGhpcy5tYXNrc2V0IHx8ICgwLCBvLmdlbmVyYXRlTWFza1NldCkodGhpcy5vcHRzLCB0aGlzLm5vTWFza3NDYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHRoaXMub3B0cy5vbkJlZm9yZU1hc2sgJiYgdGhpcy5vcHRzLm9uQmVmb3JlTWFzay5jYWxsKHRoaXMsIGUsIHRoaXMub3B0cykgfHwgZSkuc3BsaXQoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLmNoZWNrVmFsLmNhbGwodGhpcywgdm9pZCAwLCAhMCwgITEsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmlzUlRMID8gbC5nZXRCdWZmZXIuY2FsbCh0aGlzKS5zbGljZSgpLnJldmVyc2UoKS5qb2luKFwiXCIpIDogbC5nZXRCdWZmZXIuY2FsbCh0aGlzKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMuZ2V0bWV0YWRhdGEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSA6IGk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsICYmICgwLCBuLmRlZmF1bHQpKHRoaXMuZWwpLnRyaWdnZXIoXCJzZXR2YWx1ZVwiLCBbIGUgXSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFuYWx5c2VNYXNrOiBvLmFuYWx5c2VNYXNrXG4gICAgICAgICAgICAgICAgfSwgeS5leHRlbmREZWZhdWx0cyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbi5kZWZhdWx0LmV4dGVuZCghMCwgeS5wcm90b3R5cGUuZGVmYXVsdHMsIGUpO1xuICAgICAgICAgICAgICAgIH0sIHkuZXh0ZW5kRGVmaW5pdGlvbnMgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIG4uZGVmYXVsdC5leHRlbmQoITAsIHkucHJvdG90eXBlLmRlZmluaXRpb25zLCBlKTtcbiAgICAgICAgICAgICAgICB9LCB5LmV4dGVuZEFsaWFzZXMgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIG4uZGVmYXVsdC5leHRlbmQoITAsIHkucHJvdG90eXBlLmFsaWFzZXMsIGUpO1xuICAgICAgICAgICAgICAgIH0sIHkuZm9ybWF0ID0gZnVuY3Rpb24oZSwgdCwgYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geSh0KS5mb3JtYXQoZSwgYSk7XG4gICAgICAgICAgICAgICAgfSwgeS51bm1hc2sgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5KHQpLnVubWFza2VkdmFsdWUoZSk7XG4gICAgICAgICAgICAgICAgfSwgeS5pc1ZhbGlkID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geSh0KS5pc1ZhbGlkKGUpO1xuICAgICAgICAgICAgICAgIH0sIHkucmVtb3ZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09IHR5cGVvZiBlICYmIChlID0gZy5nZXRFbGVtZW50QnlJZChlKSB8fCBnLnF1ZXJ5U2VsZWN0b3JBbGwoZSkpLCAoZSA9IGUubm9kZU5hbWUgPyBbIGUgXSA6IGUpLmZvckVhY2goKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuaW5wdXRtYXNrICYmIGUuaW5wdXRtYXNrLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSwgeS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiAoZSA9IGcuZ2V0RWxlbWVudEJ5SWQoZSkgfHwgZy5xdWVyeVNlbGVjdG9yQWxsKGUpKSwgKGUgPSBlLm5vZGVOYW1lID8gWyBlIF0gOiBlKS5mb3JFYWNoKChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmlucHV0bWFzayA/IGUuaW5wdXRtYXNrLnNldFZhbHVlKHQpIDogKDAsIG4uZGVmYXVsdCkoZSkudHJpZ2dlcihcInNldHZhbHVlXCIsIFsgdCBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0sIHkuZGVwZW5kZW5jeUxpYiA9IG4uZGVmYXVsdCwgci5kZWZhdWx0LklucHV0bWFzayA9IHk7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB5O1xuICAgICAgICAgICAgICAgIHQuZGVmYXVsdCA9IHg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgNTI5NjogZnVuY3Rpb24oZSwgdCwgYSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGkoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGkgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGU7XG4gICAgICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBlLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgZSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgZTtcbiAgICAgICAgICAgICAgICAgICAgfSkoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuID0gcChhKDkzODApKSwgciA9IHAoYSgyMzk0KSksIG8gPSBwKGEoODc0MSkpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHMoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXQgfHwgXCJvYmplY3RcIiAhPT0gaSh0KSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgPyBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICAgICAgfShlKSA6IHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGwoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgTWFwID8gbmV3IE1hcCA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChsID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGUgfHwgKGEgPSBlLCAtMSA9PT0gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChhKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSkpIHJldHVybiBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5zZXQoZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1KGUsIGFyZ3VtZW50cywgZCh0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUucHJvdG90eXBlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgZihpLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfSkoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHUoZSwgdCwgYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHUgPSBjKCkgPyBSZWZsZWN0LmNvbnN0cnVjdCA6IGZ1bmN0aW9uKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gWyBudWxsIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpLnB1c2guYXBwbHkoaSwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IG5ldyAoRnVuY3Rpb24uYmluZC5hcHBseShlLCBpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSAmJiBmKG4sIGEucHJvdG90eXBlKSwgbjtcbiAgICAgICAgICAgICAgICAgICAgfSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYygpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFJlZmxlY3QgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFByb3h5KSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCAoZnVuY3Rpb24oKSB7fSkpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAhMDtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGYoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGYgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuX19wcm90b19fID0gdCwgZTtcbiAgICAgICAgICAgICAgICAgICAgfSkoZSwgdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGQoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGQgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpO1xuICAgICAgICAgICAgICAgICAgICB9KShlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBoID0gbi5kZWZhdWx0LmRvY3VtZW50O1xuICAgICAgICAgICAgICAgIGlmIChvLmRlZmF1bHQgJiYgaCAmJiBoLmhlYWQgJiYgaC5oZWFkLmF0dGFjaFNoYWRvdyAmJiBuLmRlZmF1bHQuY3VzdG9tRWxlbWVudHMgJiYgdm9pZCAwID09PSBuLmRlZmF1bHQuY3VzdG9tRWxlbWVudHMuZ2V0KFwiaW5wdXQtbWFza1wiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCAmJiBudWxsICE9PSB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIHQgJiYgZihlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0obiwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCwgYSwgaSA9ICh0ID0gbiwgYSA9IGMoKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUsIGkgPSBkKHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gZCh0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IFJlZmxlY3QuY29uc3RydWN0KGksIGFyZ3VtZW50cywgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGUgPSBpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHModGhpcywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0odGhpcywgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSAoZSA9IGkuY2FsbCh0aGlzKSkuZ2V0QXR0cmlidXRlTmFtZXMoKSwgYSA9IGUuYXR0YWNoU2hhZG93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJjbG9zZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBvID0gaC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcyBpbiBvLnR5cGUgPSBcInRleHRcIiwgYS5hcHBlbmRDaGlsZChvKSwgdCkgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIHMpICYmIG8uc2V0QXR0cmlidXRlKHRbc10sIGUuZ2V0QXR0cmlidXRlKHRbc10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IG5ldyByLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGwuZGF0YUF0dHJpYnV0ZSA9IFwiXCIsIGwubWFzayhvKSwgby5pbnB1dG1hc2suc2hhZG93Um9vdCA9IGEsIGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICAgICAgfShsKEhUTUxFbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIG4uZGVmYXVsdC5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJpbnB1dC1tYXNrXCIsIHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAyMzkxOiBmdW5jdGlvbihlLCB0LCBhKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmdlbmVyYXRlTWFza1NldCA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGE7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG4oZSwgYSwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIsIG8sIHMgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBlICYmIFwiXCIgIT09IGUgfHwgKChzID0gbnVsbCAhPT0gbi5yZWdleCkgPyBlID0gKGUgPSBuLnJlZ2V4KS5yZXBsYWNlKC9eKFxcXikoLiopKFxcJCkkLywgXCIkMlwiKSA6IChzID0gITAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IFwiLipcIikpLCAxID09PSBlLmxlbmd0aCAmJiAhMSA9PT0gbi5ncmVlZHkgJiYgMCAhPT0gbi5yZXBlYXQgJiYgKG4ucGxhY2Vob2xkZXIgPSBcIlwiKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBuLnJlcGVhdCA+IDAgfHwgXCIqXCIgPT09IG4ucmVwZWF0IHx8IFwiK1wiID09PSBuLnJlcGVhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gXCIqXCIgPT09IG4ucmVwZWF0ID8gMCA6IFwiK1wiID09PSBuLnJlcGVhdCA/IDEgOiBuLnJlcGVhdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gbi5ncm91cG1hcmtlclswXSArIGUgKyBuLmdyb3VwbWFya2VyWzFdICsgbi5xdWFudGlmaWVybWFya2VyWzBdICsgbCArIFwiLFwiICsgbi5yZXBlYXQgKyBuLnF1YW50aWZpZXJtYXJrZXJbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbyA9IHMgPyBcInJlZ2V4X1wiICsgbi5yZWdleCA6IG4ubnVtZXJpY0lucHV0ID8gZS5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKSA6IGUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgITEgIT09IG4ua2VlcFN0YXRpYyAmJiAobyA9IFwia3NfXCIgKyBvKSwgdm9pZCAwID09PSBJbnB1dG1hc2sucHJvdG90eXBlLm1hc2tzQ2FjaGVbb10gfHwgITAgPT09IHQgPyAociA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tUb2tlbjogSW5wdXRtYXNrLnByb3RvdHlwZS5hbmFseXNlTWFzayhlLCBzLCBuKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZFBvc2l0aW9uczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2J1ZmZlcjogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNsdWRlczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza0xlbmd0aDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGppdE9mZnNldDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sICEwICE9PSB0ICYmIChJbnB1dG1hc2sucHJvdG90eXBlLm1hc2tzQ2FjaGVbb10gPSByLCByID0gaS5kZWZhdWx0LmV4dGVuZCghMCwge30sIElucHV0bWFzay5wcm90b3R5cGUubWFza3NDYWNoZVtvXSkpKSA6IHIgPSBpLmRlZmF1bHQuZXh0ZW5kKCEwLCB7fSwgSW5wdXRtYXNrLnByb3RvdHlwZS5tYXNrc0NhY2hlW29dKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICByO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZS5tYXNrICYmIChlLm1hc2sgPSBlLm1hc2soZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlLm1hc2spKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5tYXNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsID09PSBlLmtlZXBTdGF0aWMgJiYgKGUua2VlcFN0YXRpYyA9ICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGUuZ3JvdXBtYXJrZXJbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmlzUlRMID8gZS5tYXNrLnJldmVyc2UoKSA6IGUubWFzaykuZm9yRWFjaCgoZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmxlbmd0aCA+IDEgJiYgKHIgKz0gZS5ncm91cG1hcmtlclsxXSArIGUuYWx0ZXJuYXRvcm1hcmtlciArIGUuZ3JvdXBtYXJrZXJbMF0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSB0Lm1hc2sgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0Lm1hc2sgPyByICs9IHQubWFzayA6IHIgKz0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSksIG4ociArPSBlLmdyb3VwbWFya2VyWzFdLCBlLm1hc2ssIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5tYXNrID0gZS5tYXNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IGUua2VlcFN0YXRpYyAmJiAoZS5rZWVwU3RhdGljID0gITEpO1xuICAgICAgICAgICAgICAgICAgICBhID0gZS5tYXNrICYmIHZvaWQgMCAhPT0gZS5tYXNrLm1hc2sgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlLm1hc2subWFzayA/IG4oZS5tYXNrLm1hc2ssIGUubWFzaywgZSkgOiBuKGUubWFzaywgZS5tYXNrLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgfSwgdC5hbmFseXNlTWFzayA9IGZ1bmN0aW9uKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIHIsIG8sIHMsIGwsIHUsIGMgPSAvKD86Wz8qK118XFx7WzAtOSsqXSsoPzosWzAtOSsqXSopPyg/OlxcfFswLTkrKl0qKT9cXH0pfFteLj8qK14ke1tdKCl8XFxcXF0rfC4vZywgZiA9IC9cXFtcXF4/XT8oPzpbXlxcXFxcXF1dK3xcXFxcW1xcU1xcc10/KSpdP3xcXFxcKD86MCg/OlswLTNdWzAtN117MCwyfXxbNC03XVswLTddPyk/fFsxLTldWzAtOV0qfHhbMC05QS1GYS1mXXsyfXx1WzAtOUEtRmEtZl17NH18Y1tBLVphLXpdfFtcXFNcXHNdPyl8XFwoKD86XFw/Wzo9IV0/KT98KD86Wz8qK118XFx7WzAtOV0rKD86LFswLTldKik/XFx9KVxcPz98W14uPyorXiR7WygpfFxcXFxdK3wuL2csIGQgPSAhMSwgcCA9IG5ldyBuLmRlZmF1bHQsIGggPSBbXSwgdiA9IFtdLCBtID0gITE7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGcoZSwgaSwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IHZvaWQgMCAhPT0gbiA/IG4gOiBlLm1hdGNoZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBlLm1hdGNoZXNbbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQpIDAgPT09IGkuaW5kZXhPZihcIltcIikgfHwgZCAmJiAvXFxcXGR8XFxcXHN8XFxcXHddL2kudGVzdChpKSB8fCBcIi5cIiA9PT0gaSA/IGUubWF0Y2hlcy5zcGxpY2UobisrLCAwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm46IG5ldyBSZWdFeHAoaSwgYS5jYXNpbmcgPyBcImlcIiA6IFwiXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpYzogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxpdHk6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Jsb2NrTWFya2VyOiB2b2lkIDAgPT09IHIgPyBcIm1hc3RlclwiIDogci5kZWYgIT09IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzaW5nOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZjogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZURlZjogaVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiAoZCAmJiAoaSA9IGlbaS5sZW5ndGggLSAxXSksIGkuc3BsaXQoXCJcIikuZm9yRWFjaCgoZnVuY3Rpb24odCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBlLm1hdGNoZXNbbiAtIDFdLCBlLm1hdGNoZXMuc3BsaWNlKG4rKywgMCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogL1thLXpdL2kudGVzdChhLnN0YXRpY0RlZmluaXRpb25TeW1ib2wgfHwgdCkgPyBuZXcgUmVnRXhwKFwiW1wiICsgKGEuc3RhdGljRGVmaW5pdGlvblN5bWJvbCB8fCB0KSArIFwiXVwiLCBhLmNhc2luZyA/IFwiaVwiIDogXCJcIikgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWM6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbGl0eTogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Jsb2NrTWFya2VyOiB2b2lkIDAgPT09IHIgPyBcIm1hc3RlclwiIDogci5kZWYgIT09IHQgJiYgITAgIT09IHIuc3RhdGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNpbmc6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZjogYS5zdGF0aWNEZWZpbml0aW9uU3ltYm9sIHx8IHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiB2b2lkIDAgIT09IGEuc3RhdGljRGVmaW5pdGlvblN5bWJvbCA/IHQgOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZURlZjogKGQgPyBcIidcIiA6IFwiXCIpICsgdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpKSwgZCA9ICExOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IGEuZGVmaW5pdGlvbnMgJiYgYS5kZWZpbml0aW9uc1tpXSB8fCBhLnVzZVByb3RvdHlwZURlZmluaXRpb25zICYmIElucHV0bWFzay5wcm90b3R5cGUuZGVmaW5pdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAmJiAhZCA/IGUubWF0Y2hlcy5zcGxpY2UobisrLCAwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuOiBvLnZhbGlkYXRvciA/IFwic3RyaW5nXCIgPT0gdHlwZW9mIG8udmFsaWRhdG9yID8gbmV3IFJlZ0V4cChvLnZhbGlkYXRvciwgYS5jYXNpbmcgPyBcImlcIiA6IFwiXCIpIDogbmV3IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXN0ID0gby52YWxpZGF0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiBuZXcgUmVnRXhwKFwiLlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljOiBvLnN0YXRpYyB8fCAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxpdHk6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdCbG9ja01hcmtlcjogdm9pZCAwID09PSByID8gXCJtYXN0ZXJcIiA6IHIuZGVmICE9PSAoby5kZWZpbml0aW9uU3ltYm9sIHx8IGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNpbmc6IG8uY2FzaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWY6IG8uZGVmaW5pdGlvblN5bWJvbCB8fCBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogby5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlRGVmOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWQ6IG8uZ2VuZXJhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiAoZS5tYXRjaGVzLnNwbGljZShuKyssIDAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm46IC9bYS16XS9pLnRlc3QoYS5zdGF0aWNEZWZpbml0aW9uU3ltYm9sIHx8IGkpID8gbmV3IFJlZ0V4cChcIltcIiArIChhLnN0YXRpY0RlZmluaXRpb25TeW1ib2wgfHwgaSkgKyBcIl1cIiwgYS5jYXNpbmcgPyBcImlcIiA6IFwiXCIpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxpdHk6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdCbG9ja01hcmtlcjogdm9pZCAwID09PSByID8gXCJtYXN0ZXJcIiA6IHIuZGVmICE9PSBpICYmICEwICE9PSByLnN0YXRpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzaW5nOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWY6IGEuc3RhdGljRGVmaW5pdGlvblN5bWJvbCB8fCBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogdm9pZCAwICE9PSBhLnN0YXRpY0RlZmluaXRpb25TeW1ib2wgPyBpIDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVEZWY6IChkID8gXCInXCIgOiBcIlwiKSArIGlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgZCA9ICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBrKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnKHMgPSBoW2gubGVuZ3RoIC0gMV0sIHIpLCBzLmlzQWx0ZXJuYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gaC5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBsLm1hdGNoZXMubGVuZ3RoOyBlKyspIGwubWF0Y2hlc1tlXS5pc0dyb3VwICYmIChsLm1hdGNoZXNbZV0uaXNHcm91cCA9ICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaC5sZW5ndGggPiAwID8gKHMgPSBoW2gubGVuZ3RoIC0gMV0pLm1hdGNoZXMucHVzaChsKSA6IHAubWF0Y2hlcy5wdXNoKGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBnKHAsIHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHkoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBuZXcgbi5kZWZhdWx0KCEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0Lm9wZW5Hcm91cCA9ICExLCB0Lm1hdGNoZXMgPSBlLCB0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGIoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG8gPSBoLnBvcCgpKS5vcGVuR3JvdXAgPSAhMSwgdm9pZCAwICE9PSBvKSBpZiAoaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzID0gaFtoLmxlbmd0aCAtIDFdKS5tYXRjaGVzLnB1c2gobyksIHMuaXNBbHRlcm5hdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBoLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IGwubWF0Y2hlcy5sZW5ndGg7IGUrKykgbC5tYXRjaGVzW2VdLmlzR3JvdXAgPSAhMSwgbC5tYXRjaGVzW2VdLmFsdGVybmF0b3JHcm91cCA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoLmxlbmd0aCA+IDAgPyAocyA9IGhbaC5sZW5ndGggLSAxXSkubWF0Y2hlcy5wdXNoKGwpIDogcC5tYXRjaGVzLnB1c2gobCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHAubWF0Y2hlcy5wdXNoKG8pOyBlbHNlIGsoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB4KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmlzUXVhbnRpZmllciAmJiAodCA9IHkoWyBlLnBvcCgpLCB0IF0pKSwgdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ICYmIChhLm9wdGlvbmFsbWFya2VyWzBdID0gdm9pZCAwLCBhLm9wdGlvbmFsbWFya2VyWzFdID0gdm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7aSA9IHQgPyBmLmV4ZWMoZSkgOiBjLmV4ZWMoZSk7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPSBpWzBdLCB0KSBzd2l0Y2ggKHIuY2hhckF0KDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IFwiezAsMX1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBcIntcIiArIHIgKyBcIn1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwifFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgUCA9IHkocC5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5vcGVuR3JvdXAgPSAhMCwgaC5wdXNoKFApLCBwLm1hdGNoZXMgPSBbXSwgbSA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkKSBrKCk7IGVsc2Ugc3dpdGNoIChyLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgfHwgaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIoPz1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIig/IVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiKD88PVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiKD88IVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgucHVzaChuZXcgbi5kZWZhdWx0KCEwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBhLmVzY2FwZUNoYXI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9ICEwLCB0ICYmIGsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGEub3B0aW9uYWxtYXJrZXJbMV06XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgYS5ncm91cG1hcmtlclsxXTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBhLm9wdGlvbmFsbWFya2VyWzBdOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgucHVzaChuZXcgbi5kZWZhdWx0KCExLCAhMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgYS5ncm91cG1hcmtlclswXTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoLnB1c2gobmV3IG4uZGVmYXVsdCghMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgYS5xdWFudGlmaWVybWFya2VyWzBdOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBFID0gbmV3IG4uZGVmYXVsdCghMSwgITEsICEwKSwgUyA9IChyID0gci5yZXBsYWNlKC9be31dL2csIFwiXCIpKS5zcGxpdChcInxcIiksIF8gPSBTWzBdLnNwbGl0KFwiLFwiKSwgTSA9IGlzTmFOKF9bMF0pID8gX1swXSA6IHBhcnNlSW50KF9bMF0pLCB3ID0gMSA9PT0gXy5sZW5ndGggPyBNIDogaXNOYU4oX1sxXSkgPyBfWzFdIDogcGFyc2VJbnQoX1sxXSksIE8gPSBpc05hTihTWzFdKSA/IFNbMV0gOiBwYXJzZUludChTWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIipcIiAhPT0gTSAmJiBcIitcIiAhPT0gTSB8fCAoTSA9IFwiKlwiID09PSB3ID8gMCA6IDEpLCBFLnF1YW50aWZpZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogTSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiB3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqaXQ6IE9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBUID0gaC5sZW5ndGggPiAwID8gaFtoLmxlbmd0aCAtIDFdLm1hdGNoZXMgOiBwLm1hdGNoZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChpID0gVC5wb3AoKSkuaXNBbHRlcm5hdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFQucHVzaChpKSwgVCA9IGkubWF0Y2hlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEMgPSBuZXcgbi5kZWZhdWx0KCEwKSwgQSA9IFQucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFQucHVzaChDKSwgVCA9IEMubWF0Y2hlcywgaSA9IEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkuaXNHcm91cCB8fCAoaSA9IHkoWyBpIF0pKSwgVC5wdXNoKGkpLCBULnB1c2goRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBhLmFsdGVybmF0b3JtYXJrZXI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgRCA9IChzID0gaFtoLmxlbmd0aCAtIDFdKS5tYXRjaGVzW3MubWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHMub3Blbkdyb3VwICYmICh2b2lkIDAgPT09IEQubWF0Y2hlcyB8fCAhMSA9PT0gRC5pc0dyb3VwICYmICExID09PSBELmlzQWx0ZXJuYXRvcikgPyBoLnBvcCgpIDogeChzLm1hdGNoZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB1ID0geChwLm1hdGNoZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1LmlzQWx0ZXJuYXRvcikgaC5wdXNoKHUpOyBlbHNlIGlmICh1LmFsdGVybmF0b3JHcm91cCA/IChsID0gaC5wb3AoKSwgdS5hbHRlcm5hdG9yR3JvdXAgPSAhMSkgOiBsID0gbmV3IG4uZGVmYXVsdCghMSwgITEsICExLCAhMCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwubWF0Y2hlcy5wdXNoKHUpLCBoLnB1c2gobCksIHUub3Blbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUub3Blbkdyb3VwID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBCID0gbmV3IG4uZGVmYXVsdCghMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEIuYWx0ZXJuYXRvckdyb3VwID0gITAsIGgucHVzaChCKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbSAmJiBiKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoO2gubGVuZ3RoID4gMDsgKSBvID0gaC5wb3AoKSwgcC5tYXRjaGVzLnB1c2gobyk7XG4gICAgICAgICAgICAgICAgICAgIHAubWF0Y2hlcy5sZW5ndGggPiAwICYmICghZnVuY3Rpb24gZShpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICYmIGkubWF0Y2hlcyAmJiBpLm1hdGNoZXMuZm9yRWFjaCgoZnVuY3Rpb24obiwgcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gaS5tYXRjaGVzW3IgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodm9pZCAwID09PSBvIHx8IHZvaWQgMCA9PT0gby5tYXRjaGVzIHx8ICExID09PSBvLmlzUXVhbnRpZmllcikgJiYgbiAmJiBuLmlzR3JvdXAgJiYgKG4uaXNHcm91cCA9ICExLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0IHx8IChnKG4sIGEuZ3JvdXBtYXJrZXJbMF0sIDApLCAhMCAhPT0gbi5vcGVuR3JvdXAgJiYgZyhuLCBhLmdyb3VwbWFya2VyWzFdKSkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlKG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KHApLCB2LnB1c2gocCkpO1xuICAgICAgICAgICAgICAgICAgICAoYS5udW1lcmljSW5wdXQgfHwgYS5pc1JUTCkgJiYgZnVuY3Rpb24gZSh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHQubWF0Y2hlcyA9IHQubWF0Y2hlcy5yZXZlcnNlKCksIHQubWF0Y2hlcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0Lm1hdGNoZXMsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBwYXJzZUludChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5tYXRjaGVzW2ldLmlzUXVhbnRpZmllciAmJiB0Lm1hdGNoZXNbbiArIDFdICYmIHQubWF0Y2hlc1tuICsgMV0uaXNHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHQubWF0Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5tYXRjaGVzLnNwbGljZShpLCAxKSwgdC5tYXRjaGVzLnNwbGljZShuICsgMSwgMCwgcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gdC5tYXRjaGVzW2ldLm1hdGNoZXMgPyB0Lm1hdGNoZXNbaV0gPSBlKHQubWF0Y2hlc1tpXSkgOiB0Lm1hdGNoZXNbaV0gPSAoKG8gPSB0Lm1hdGNoZXNbaV0pID09PSBhLm9wdGlvbmFsbWFya2VyWzBdID8gbyA9IGEub3B0aW9uYWxtYXJrZXJbMV0gOiBvID09PSBhLm9wdGlvbmFsbWFya2VyWzFdID8gbyA9IGEub3B0aW9uYWxtYXJrZXJbMF0gOiBvID09PSBhLmdyb3VwbWFya2VyWzBdID8gbyA9IGEuZ3JvdXBtYXJrZXJbMV0gOiBvID09PSBhLmdyb3VwbWFya2VyWzFdICYmIChvID0gYS5ncm91cG1hcmtlclswXSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG87XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICAgICAgfSh2WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHIoYSg0OTYzKSksIG4gPSByKGEoOTY5NSkpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHIoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAxNTc6IGZ1bmN0aW9uKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQubWFzayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMsIHQgPSB0aGlzLm9wdHMsIGEgPSB0aGlzLmVsLCBpID0gdGhpcy5kZXBlbmRlbmN5TGliO1xuICAgICAgICAgICAgICAgICAgICBzLkV2ZW50UnVsZXIub2ZmKGEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uKHQsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dGFyZWFcIiAhPT0gdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgJiYgYS5pZ25vcmFibGVzLnB1c2gobi5kZWZhdWx0LkVOVEVSKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gdC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpLCB1ID0gXCJpbnB1dFwiID09PSB0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAmJiBhLnN1cHBvcnRzSW5wdXRUeXBlLmluY2x1ZGVzKGwpIHx8IHQuaXNDb250ZW50RWRpdGFibGUgfHwgXCJ0ZXh0YXJlYVwiID09PSB0LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdSkgaWYgKFwiaW5wdXRcIiA9PT0gdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgbCksIHUgPSBcInRleHRcIiA9PT0gYy50eXBlLCBjID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB1ID0gXCJwYXJ0aWFsXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITEgIT09IHUgPyBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4sIGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRtYXNrID8gdGhpcy5pbnB1dG1hc2sub3B0cy5hdXRvVW5tYXNrID8gdGhpcy5pbnB1dG1hc2sudW5tYXNrZWR2YWx1ZSgpIDogLTEgIT09IHIuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChlKSB8fCAhMCAhPT0gYS5udWxsYWJsZSA/ICh0aGlzLmlucHV0bWFzay5zaGFkb3dSb290IHx8IHRoaXMub3duZXJEb2N1bWVudCkuYWN0aXZlRWxlbWVudCA9PT0gdGhpcyAmJiBhLmNsZWFyTWFza09uTG9zdEZvY3VzID8gKGUuaXNSVEwgPyBvLmNsZWFyT3B0aW9uYWxUYWlsLmNhbGwoZSwgci5nZXRCdWZmZXIuY2FsbChlKS5zbGljZSgpKS5yZXZlcnNlKCkgOiBvLmNsZWFyT3B0aW9uYWxUYWlsLmNhbGwoZSwgci5nZXRCdWZmZXIuY2FsbChlKS5zbGljZSgpKSkuam9pbihcIlwiKSA6IG4uY2FsbCh0aGlzKSA6IFwiXCIgOiBuLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGMoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsLmNhbGwodGhpcywgZSksIHRoaXMuaW5wdXRtYXNrICYmICgwLCBvLmFwcGx5SW5wdXRWYWx1ZSkodGhpcywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdC5pbnB1dG1hc2suX192YWx1ZUdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITAgIT09IGEubm9WYWx1ZVBhdGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gT2JqZWN0LmdldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QuZ2V0UHJvdG90eXBlT2YodCksIFwidmFsdWVcIikgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiAmJiBmLmdldCAmJiBmLnNldCA/IChuID0gZi5nZXQsIGwgPSBmLnNldCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IHUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldDogYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSA6IFwiaW5wdXRcIiAhPT0gdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgJiYgKG4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgbCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0Q29udGVudCA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IHUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldDogYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBkb2N1bWVudC5fX2xvb2t1cEdldHRlcl9fICYmIHQuX19sb29rdXBHZXR0ZXJfXyhcInZhbHVlXCIpICYmIChuID0gdC5fX2xvb2t1cEdldHRlcl9fKFwidmFsdWVcIiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHQuX19sb29rdXBTZXR0ZXJfXyhcInZhbHVlXCIpLCB0Ll9fZGVmaW5lR2V0dGVyX18oXCJ2YWx1ZVwiLCB1KSwgdC5fX2RlZmluZVNldHRlcl9fKFwidmFsdWVcIiwgYykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5pbnB1dG1hc2suX192YWx1ZUdldCA9IG4sIHQuaW5wdXRtYXNrLl9fdmFsdWVTZXQgPSBsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuaW5wdXRtYXNrLl92YWx1ZUdldCA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmlzUlRMICYmICEwICE9PSB0ID8gbi5jYWxsKHRoaXMuZWwpLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpIDogbi5jYWxsKHRoaXMuZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0LmlucHV0bWFzay5fdmFsdWVTZXQgPSBmdW5jdGlvbih0LCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsLmNhbGwodGhpcy5lbCwgbnVsbCA9PSB0ID8gXCJcIiA6ICEwICE9PSBhICYmIGUuaXNSVEwgPyB0LnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpIDogdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHZvaWQgMCA9PT0gbiAmJiAobiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGwgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkudmFsSG9va3MgJiYgKHZvaWQgMCA9PT0gaS52YWxIb29rc1t0XSB8fCAhMCAhPT0gaS52YWxIb29rc1t0XS5pbnB1dG1hc2twYXRjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGkudmFsSG9va3NbdF0gJiYgaS52YWxIb29rc1t0XS5nZXQgPyBpLnZhbEhvb2tzW3RdLmdldCA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcyA9IGkudmFsSG9va3NbdF0gJiYgaS52YWxIb29rc1t0XS5zZXQgPyBpLnZhbEhvb2tzW3RdLnNldCA6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUudmFsdWUgPSB0LCBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaS52YWxIb29rc1t0XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5pbnB1dG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5pbnB1dG1hc2sub3B0cy5hdXRvVW5tYXNrKSByZXR1cm4gdC5pbnB1dG1hc2sudW5tYXNrZWR2YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gbih0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTEgIT09IHIuZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbChlLCB2b2lkIDAsIHZvaWQgMCwgdC5pbnB1dG1hc2subWFza3NldC52YWxpZFBvc2l0aW9ucykgfHwgITAgIT09IGEubnVsbGFibGUgPyBpIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuKHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gcyhlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmlucHV0bWFzayAmJiAoMCwgby5hcHBseUlucHV0VmFsdWUpKGUsIHQpLCBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dG1hc2twYXRjaDogITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHQudHlwZSksIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuRXZlbnRSdWxlci5vbih0LCBcIm1vdXNlZW50ZXJcIiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5pbnB1dG1hc2suX3ZhbHVlR2V0KCEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICE9PSAoZS5pc1JUTCA/IHIuZ2V0QnVmZmVyLmNhbGwoZSkucmV2ZXJzZSgpIDogci5nZXRCdWZmZXIuY2FsbChlKSkuam9pbihcIlwiKSAmJiAoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby5hcHBseUlucHV0VmFsdWUpKHRoaXMsIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KHQpIDogdC5pbnB1dG1hc2sgPSB2b2lkIDAsIHU7XG4gICAgICAgICAgICAgICAgICAgIH0oYSwgdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghMSAhPT0gZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5vcmlnaW5hbFBsYWNlaG9sZGVyID0gYS5wbGFjZWhvbGRlciwgZS5tYXhMZW5ndGggPSB2b2lkIDAgIT09IGEgPyBhLm1heExlbmd0aCA6IHZvaWQgMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAtMSA9PT0gZS5tYXhMZW5ndGggJiYgKGUubWF4TGVuZ3RoID0gdm9pZCAwKSwgXCJpbnB1dE1vZGVcIiBpbiBhICYmIG51bGwgPT09IGEuZ2V0QXR0cmlidXRlKFwiaW5wdXRtb2RlXCIpICYmIChhLmlucHV0TW9kZSA9IHQuaW5wdXRtb2RlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuc2V0QXR0cmlidXRlKFwiaW5wdXRtb2RlXCIsIHQuaW5wdXRtb2RlKSksICEwID09PSBmICYmICh0LnNob3dNYXNrT25Gb2N1cyA9IHQuc2hvd01hc2tPbkZvY3VzICYmIC0xID09PSBbIFwiY2MtbnVtYmVyXCIsIFwiY2MtZXhwXCIgXS5pbmRleE9mKGEuYXV0b2NvbXBsZXRlKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBsLmlwaG9uZSAmJiAodC5pbnNlcnRNb2RlVmlzdWFsID0gITEpLCBzLkV2ZW50UnVsZXIub24oYSwgXCJzdWJtaXRcIiwgYy5FdmVudEhhbmRsZXJzLnN1Ym1pdEV2ZW50KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBzLkV2ZW50UnVsZXIub24oYSwgXCJyZXNldFwiLCBjLkV2ZW50SGFuZGxlcnMucmVzZXRFdmVudCksIHMuRXZlbnRSdWxlci5vbihhLCBcImJsdXJcIiwgYy5FdmVudEhhbmRsZXJzLmJsdXJFdmVudCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgcy5FdmVudFJ1bGVyLm9uKGEsIFwiZm9jdXNcIiwgYy5FdmVudEhhbmRsZXJzLmZvY3VzRXZlbnQpLCBzLkV2ZW50UnVsZXIub24oYSwgXCJpbnZhbGlkXCIsIGMuRXZlbnRIYW5kbGVycy5pbnZhbGlkRXZlbnQpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuRXZlbnRSdWxlci5vbihhLCBcImNsaWNrXCIsIGMuRXZlbnRIYW5kbGVycy5jbGlja0V2ZW50KSwgcy5FdmVudFJ1bGVyLm9uKGEsIFwibW91c2VsZWF2ZVwiLCBjLkV2ZW50SGFuZGxlcnMubW91c2VsZWF2ZUV2ZW50KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBzLkV2ZW50UnVsZXIub24oYSwgXCJtb3VzZWVudGVyXCIsIGMuRXZlbnRIYW5kbGVycy5tb3VzZWVudGVyRXZlbnQpLCBzLkV2ZW50UnVsZXIub24oYSwgXCJwYXN0ZVwiLCBjLkV2ZW50SGFuZGxlcnMucGFzdGVFdmVudCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgcy5FdmVudFJ1bGVyLm9uKGEsIFwiY3V0XCIsIGMuRXZlbnRIYW5kbGVycy5jdXRFdmVudCksIHMuRXZlbnRSdWxlci5vbihhLCBcImNvbXBsZXRlXCIsIHQub25jb21wbGV0ZSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgcy5FdmVudFJ1bGVyLm9uKGEsIFwiaW5jb21wbGV0ZVwiLCB0Lm9uaW5jb21wbGV0ZSksIHMuRXZlbnRSdWxlci5vbihhLCBcImNsZWFyZWRcIiwgdC5vbmNsZWFyZWQpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICEwICE9PSB0LmlucHV0RXZlbnRPbmx5ICYmIChzLkV2ZW50UnVsZXIub24oYSwgXCJrZXlkb3duXCIsIGMuRXZlbnRIYW5kbGVycy5rZXlkb3duRXZlbnQpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuRXZlbnRSdWxlci5vbihhLCBcImtleXByZXNzXCIsIGMuRXZlbnRIYW5kbGVycy5rZXlwcmVzc0V2ZW50KSwgcy5FdmVudFJ1bGVyLm9uKGEsIFwia2V5dXBcIiwgYy5FdmVudEhhbmRsZXJzLmtleXVwRXZlbnQpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAobC5tb2JpbGUgfHwgdC5pbnB1dEV2ZW50T25seSkgJiYgYS5yZW1vdmVBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIiksIHMuRXZlbnRSdWxlci5vbihhLCBcImlucHV0XCIsIGMuRXZlbnRIYW5kbGVycy5pbnB1dEZhbGxCYWNrRXZlbnQpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuRXZlbnRSdWxlci5vbihhLCBcImNvbXBvc2l0aW9uZW5kXCIsIGMuRXZlbnRIYW5kbGVycy5jb21wb3NpdGlvbmVuZEV2ZW50KSksIHMuRXZlbnRSdWxlci5vbihhLCBcInNldHZhbHVlXCIsIGMuRXZlbnRIYW5kbGVycy5zZXRWYWx1ZUV2ZW50KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICByLmdldEJ1ZmZlclRlbXBsYXRlLmNhbGwoZSkuam9pbihcIlwiKSwgZS51bmRvVmFsdWUgPSBlLl92YWx1ZUdldCghMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IChhLmlucHV0bWFzay5zaGFkb3dSb290IHx8IGEub3duZXJEb2N1bWVudCkuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIlwiICE9PSBhLmlucHV0bWFzay5fdmFsdWVHZXQoITApIHx8ICExID09PSB0LmNsZWFyTWFza09uTG9zdEZvY3VzIHx8IGQgPT09IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgby5hcHBseUlucHV0VmFsdWUpKGEsIGEuaW5wdXRtYXNrLl92YWx1ZUdldCghMCksIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gci5nZXRCdWZmZXIuY2FsbChlKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICExID09PSB1LmlzQ29tcGxldGUuY2FsbChlLCBwKSAmJiB0LmNsZWFySW5jb21wbGV0ZSAmJiByLnJlc2V0TWFza1NldC5jYWxsKGUpLCB0LmNsZWFyTWFza09uTG9zdEZvY3VzICYmIGQgIT09IGEgJiYgKC0xID09PSByLmdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwoZSkgPyBwID0gW10gOiBvLmNsZWFyT3B0aW9uYWxUYWlsLmNhbGwoZSwgcCkpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoITEgPT09IHQuY2xlYXJNYXNrT25Mb3N0Rm9jdXMgfHwgdC5zaG93TWFza09uRm9jdXMgJiYgZCA9PT0gYSB8fCBcIlwiICE9PSBhLmlucHV0bWFzay5fdmFsdWVHZXQoITApKSAmJiAoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby53cml0ZUJ1ZmZlcikoYSwgcCksIGQgPT09IGEgJiYgci5jYXJldC5jYWxsKGUsIGEsIHIuc2Vla05leHQuY2FsbChlLCByLmdldExhc3RWYWxpZFBvc2l0aW9uLmNhbGwoZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGksIG4gPSAoaSA9IGEoNDUyOCkpICYmIGkuX19lc01vZHVsZSA/IGkgOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGlcbiAgICAgICAgICAgICAgICB9LCByID0gYSg4NzExKSwgbyA9IGEoNzc2MCksIHMgPSBhKDk3MTYpLCBsID0gYSg5ODQ1KSwgdSA9IGEoNzIxNSksIGMgPSBhKDYwMzApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDk2OTU6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQuZGVmYXVsdCA9IGZ1bmN0aW9uKGUsIHQsIGEsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzID0gW10sIHRoaXMub3Blbkdyb3VwID0gZSB8fCAhMSwgdGhpcy5hbHRlcm5hdG9yR3JvdXAgPSAhMSwgdGhpcy5pc0dyb3VwID0gZSB8fCAhMSwgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNPcHRpb25hbCA9IHQgfHwgITEsIHRoaXMuaXNRdWFudGlmaWVyID0gYSB8fCAhMSwgdGhpcy5pc0FsdGVybmF0b3IgPSBpIHx8ICExLCBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWFudGlmaWVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiAxXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAzMTk0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXMgfHwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgXCJpbmNsdWRlc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PSB0aGlzKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInRoaXNcIiBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IE9iamVjdCh0aGlzKSwgaSA9IGEubGVuZ3RoID4+PiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGkpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwIHwgdCwgciA9IE1hdGgubWF4KG4gPj0gMCA/IG4gOiBpIC0gTWF0aC5hYnMobiksIDApOyByIDwgaTsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFbcl0gPT09IGUpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA3MTQ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBlKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlO1xuICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgZS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGUgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIGU7XG4gICAgICAgICAgICAgICAgICAgIH0pKHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiAoT2JqZWN0LmdldFByb3RvdHlwZU9mID0gXCJvYmplY3RcIiA9PT0gZShcInRlc3RcIi5fX3Byb3RvX18pID8gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5fX3Byb3RvX187XG4gICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDg3MTE6IGZ1bmN0aW9uKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgICAgfSksIHQuY2FyZXQgPSBmdW5jdGlvbihlLCB0LCBhLCBpLCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByLCBvID0gdGhpcywgcyA9IHRoaXMub3B0cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gdCkgcmV0dXJuIFwic2VsZWN0aW9uU3RhcnRcIiBpbiBlICYmIFwic2VsZWN0aW9uRW5kXCIgaW4gZSA/ICh0ID0gZS5zZWxlY3Rpb25TdGFydCwgXG4gICAgICAgICAgICAgICAgICAgIGEgPSBlLnNlbGVjdGlvbkVuZCkgOiB3aW5kb3cuZ2V0U2VsZWN0aW9uID8gKHIgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VBdCgwKSkuY29tbW9uQW5jZXN0b3JDb250YWluZXIucGFyZW50Tm9kZSAhPT0gZSAmJiByLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyICE9PSBlIHx8ICh0ID0gci5zdGFydE9mZnNldCwgXG4gICAgICAgICAgICAgICAgICAgIGEgPSByLmVuZE9mZnNldCkgOiBkb2N1bWVudC5zZWxlY3Rpb24gJiYgZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlICYmIChyID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCksIFxuICAgICAgICAgICAgICAgICAgICB0ID0gMCAtIHIuZHVwbGljYXRlKCkubW92ZVN0YXJ0KFwiY2hhcmFjdGVyXCIsIC1lLmlucHV0bWFzay5fdmFsdWVHZXQoKS5sZW5ndGgpLCBhID0gdCArIHIudGV4dC5sZW5ndGgpLCBcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW46IGkgPyB0IDogdS5jYWxsKG8sIHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpID8gYSA6IHUuY2FsbChvLCBhKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSAmJiAoYSA9IG8uaXNSVEwgPyB0WzBdIDogdFsxXSwgdCA9IG8uaXNSVEwgPyB0WzFdIDogdFswXSksIFxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHQuYmVnaW4gJiYgKGEgPSBvLmlzUlRMID8gdC5iZWdpbiA6IHQuZW5kLCB0ID0gby5pc1JUTCA/IHQuZW5kIDogdC5iZWdpbiksIFxuICAgICAgICAgICAgICAgICAgICBcIm51bWJlclwiID09IHR5cGVvZiB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gaSA/IHQgOiB1LmNhbGwobywgdCksIGEgPSBcIm51bWJlclwiID09IHR5cGVvZiAoYSA9IGkgPyBhIDogdS5jYWxsKG8sIGEpKSA/IGEgOiB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBwYXJzZUludCgoKGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cpLmdldENvbXB1dGVkU3R5bGUgPyAoZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdykuZ2V0Q29tcHV0ZWRTdHlsZShlLCBudWxsKSA6IGUuY3VycmVudFN0eWxlKS5mb250U2l6ZSkgKiBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuc2Nyb2xsTGVmdCA9IGwgPiBlLnNjcm9sbFdpZHRoID8gbCA6IDAsIGUuaW5wdXRtYXNrLmNhcmV0UG9zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luOiB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogYVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcy5pbnNlcnRNb2RlVmlzdWFsICYmICExID09PSBzLmluc2VydE1vZGUgJiYgdCA9PT0gYSAmJiAobiB8fCBhKyspLCBlID09PSAoZS5pbnB1dG1hc2suc2hhZG93Um9vdCB8fCBlLm93bmVyRG9jdW1lbnQpLmFjdGl2ZUVsZW1lbnQpIGlmIChcInNldFNlbGVjdGlvblJhbmdlXCIgaW4gZSkgZS5zZXRTZWxlY3Rpb25SYW5nZSh0LCBhKTsgZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSwgdm9pZCAwID09PSBlLmZpcnN0Q2hpbGQgfHwgbnVsbCA9PT0gZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIuc2V0U3RhcnQoZS5maXJzdENoaWxkLCB0IDwgZS5pbnB1dG1hc2suX3ZhbHVlR2V0KCkubGVuZ3RoID8gdCA6IGUuaW5wdXRtYXNrLl92YWx1ZUdldCgpLmxlbmd0aCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIuc2V0RW5kKGUuZmlyc3RDaGlsZCwgYSA8IGUuaW5wdXRtYXNrLl92YWx1ZUdldCgpLmxlbmd0aCA/IGEgOiBlLmlucHV0bWFzay5fdmFsdWVHZXQoKS5sZW5ndGgpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmNvbGxhcHNlKCEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLnJlbW92ZUFsbFJhbmdlcygpLCBmLmFkZFJhbmdlKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGUuY3JlYXRlVGV4dFJhbmdlICYmICgociA9IGUuY3JlYXRlVGV4dFJhbmdlKCkpLmNvbGxhcHNlKCEwKSwgci5tb3ZlRW5kKFwiY2hhcmFjdGVyXCIsIGEpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHIubW92ZVN0YXJ0KFwiY2hhcmFjdGVyXCIsIHQpLCByLnNlbGVjdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHQuZGV0ZXJtaW5lTGFzdFJlcXVpcmVkUG9zaXRpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0LCBhLCByID0gdGhpcywgcyA9IHRoaXMubWFza3NldCwgbCA9IHRoaXMuZGVwZW5kZW5jeUxpYiwgdSA9IGkuZ2V0TWFza1RlbXBsYXRlLmNhbGwociwgITAsIG8uY2FsbChyKSwgITAsICEwKSwgYyA9IHUubGVuZ3RoLCBmID0gby5jYWxsKHIpLCBkID0ge30sIHAgPSBzLnZhbGlkUG9zaXRpb25zW2ZdLCBoID0gdm9pZCAwICE9PSBwID8gcC5sb2NhdG9yLnNsaWNlKCkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodCA9IGYgKyAxOyB0IDwgdS5sZW5ndGg7IHQrKykgYSA9IGkuZ2V0VGVzdFRlbXBsYXRlLmNhbGwociwgdCwgaCwgdCAtIDEpLCBoID0gYS5sb2NhdG9yLnNsaWNlKCksIFxuICAgICAgICAgICAgICAgICAgICBkW3RdID0gbC5leHRlbmQoITAsIHt9LCBhKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBwICYmIHZvaWQgMCAhPT0gcC5hbHRlcm5hdGlvbiA/IHAubG9jYXRvcltwLmFsdGVybmF0aW9uXSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh0ID0gYyAtIDE7IHQgPiBmICYmICgoKGEgPSBkW3RdKS5tYXRjaC5vcHRpb25hbGl0eSB8fCBhLm1hdGNoLm9wdGlvbmFsUXVhbnRpZmllciAmJiBhLm1hdGNoLm5ld0Jsb2NrTWFya2VyIHx8IHYgJiYgKHYgIT09IGRbdF0ubG9jYXRvcltwLmFsdGVybmF0aW9uXSAmJiAxICE9IGEubWF0Y2guc3RhdGljIHx8ICEwID09PSBhLm1hdGNoLnN0YXRpYyAmJiBhLmxvY2F0b3JbcC5hbHRlcm5hdGlvbl0gJiYgbi5jaGVja0FsdGVybmF0aW9uTWF0Y2guY2FsbChyLCBhLmxvY2F0b3JbcC5hbHRlcm5hdGlvbl0udG9TdHJpbmcoKS5zcGxpdChcIixcIiksIHYudG9TdHJpbmcoKS5zcGxpdChcIixcIikpICYmIFwiXCIgIT09IGkuZ2V0VGVzdHMuY2FsbChyLCB0KVswXS5kZWYpKSAmJiB1W3RdID09PSBpLmdldFBsYWNlaG9sZGVyLmNhbGwociwgdCwgYS5tYXRjaCkpOyB0LS0pIGMtLTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsOiBjLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmOiBkW2NdID8gZFtjXS5tYXRjaCA6IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICB9IDogYztcbiAgICAgICAgICAgICAgICB9LCB0LmRldGVybWluZU5ld0NhcmV0UG9zaXRpb24gPSBmdW5jdGlvbihlLCB0LCBhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcywgdSA9IHRoaXMubWFza3NldCwgYyA9IHRoaXMub3B0cztcbiAgICAgICAgICAgICAgICAgICAgdCAmJiAobi5pc1JUTCA/IGUuZW5kID0gZS5iZWdpbiA6IGUuYmVnaW4gPSBlLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmJlZ2luID09PSBlLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChhID0gYSB8fCBjLnBvc2l0aW9uQ2FyZXRPbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHIuY2FsbChuKS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpZ25vcmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmVuZCA9IGUuYmVnaW4gPSBsLmNhbGwobiwgby5jYWxsKG4pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmFkaXhGb2N1c1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIlwiICE9PSBjLnJhZGl4UG9pbnQgJiYgMCAhPT0gYy5kaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdS52YWxpZFBvc2l0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHRbZV0gfHwgdFtlXS5pbnB1dCA9PT0gaS5nZXRQbGFjZWhvbGRlci5jYWxsKG4sIGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgPCBsLmNhbGwobiwgLTEpKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSByLmNhbGwobikuaW5kZXhPZihjLnJhZGl4UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvIGluIHQpIGlmICh0W29dICYmIGEgPCBvICYmIHRbb10uaW5wdXQgIT09IGkuZ2V0UGxhY2Vob2xkZXIuY2FsbChuLCBvKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGUuYmVnaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gci5jYWxsKG4pLmpvaW4oXCJcIikuaW5kZXhPZihjLnJhZGl4UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmVuZCA9IGUuYmVnaW4gPSBjLm51bWVyaWNJbnB1dCA/IGwuY2FsbChuLCBmKSA6IGY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gZS5iZWdpbiwgcCA9IG8uY2FsbChuLCBkLCAhMCksIGggPSBsLmNhbGwobiwgLTEgIT09IHAgfHwgcy5jYWxsKG4sIDApID8gcCA6IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8PSBoKSBlLmVuZCA9IGUuYmVnaW4gPSBzLmNhbGwobiwgZCwgITEsICEwKSA/IGQgOiBsLmNhbGwobiwgZCk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHUudmFsaWRQb3NpdGlvbnNbcF0sIG0gPSBpLmdldFRlc3RUZW1wbGF0ZS5jYWxsKG4sIGgsIHYgPyB2Lm1hdGNoLmxvY2F0b3IgOiB2b2lkIDAsIHYpLCBnID0gaS5nZXRQbGFjZWhvbGRlci5jYWxsKG4sIGgsIG0ubWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJcIiAhPT0gZyAmJiByLmNhbGwobilbaF0gIT09IGcgJiYgITAgIT09IG0ubWF0Y2gub3B0aW9uYWxRdWFudGlmaWVyICYmICEwICE9PSBtLm1hdGNoLm5ld0Jsb2NrTWFya2VyIHx8ICFzLmNhbGwobiwgaCwgYy5rZWVwU3RhdGljLCAhMCkgJiYgbS5tYXRjaC5kZWYgPT09IGcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gbC5jYWxsKG4sIGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGQgPj0gayB8fCBkID09PSBoKSAmJiAoaCA9IGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZW5kID0gZS5iZWdpbiA9IGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0LmdldEJ1ZmZlciA9IHIsIHQuZ2V0QnVmZmVyVGVtcGxhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm1hc2tzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gZS5fYnVmZmVyICYmIChlLl9idWZmZXIgPSBpLmdldE1hc2tUZW1wbGF0ZS5jYWxsKHRoaXMsICExLCAxKSwgdm9pZCAwID09PSBlLmJ1ZmZlciAmJiAoZS5idWZmZXIgPSBlLl9idWZmZXIuc2xpY2UoKSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5fYnVmZmVyO1xuICAgICAgICAgICAgICAgIH0sIHQuZ2V0TGFzdFZhbGlkUG9zaXRpb24gPSBvLCB0LmlzTWFzayA9IHMsIHQucmVzZXRNYXNrU2V0ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMubWFza3NldDtcbiAgICAgICAgICAgICAgICAgICAgdC5idWZmZXIgPSB2b2lkIDAsICEwICE9PSBlICYmICh0LnZhbGlkUG9zaXRpb25zID0ge30sIHQucCA9IDApO1xuICAgICAgICAgICAgICAgIH0sIHQuc2Vla05leHQgPSBsLCB0LnNlZWtQcmV2aW91cyA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLCBuID0gZSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlIDw9IDApIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDtuID4gMCAmJiAoITAgPT09IHQgJiYgKCEwICE9PSBpLmdldFRlc3QuY2FsbChhLCBuKS5tYXRjaC5uZXdCbG9ja01hcmtlciB8fCAhcy5jYWxsKGEsIG4sIHZvaWQgMCwgITApKSB8fCAhMCAhPT0gdCAmJiAhcy5jYWxsKGEsIG4sIHZvaWQgMCwgITApKTsgKSBuLS07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIH0sIHQudHJhbnNsYXRlUG9zaXRpb24gPSB1O1xuICAgICAgICAgICAgICAgIHZhciBpID0gYSg0NzEzKSwgbiA9IGEoNzIxNSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5tYXNrc2V0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwICE9PSB0LmJ1ZmZlciAmJiAhMCAhPT0gZSB8fCAodC5idWZmZXIgPSBpLmdldE1hc2tUZW1wbGF0ZS5jYWxsKHRoaXMsICEwLCBvLmNhbGwodGhpcyksICEwKSwgXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gdC5fYnVmZmVyICYmICh0Ll9idWZmZXIgPSB0LmJ1ZmZlci5zbGljZSgpKSksIHQuYnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBvKGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLm1hc2tzZXQsIG4gPSAtMSwgciA9IC0xLCBvID0gYSB8fCBpLnZhbGlkUG9zaXRpb25zO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzIGluIHZvaWQgMCA9PT0gZSAmJiAoZSA9IC0xKSwgbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBwYXJzZUludChzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9bbF0gJiYgKHQgfHwgITAgIT09IG9bbF0uZ2VuZXJhdGVkSW5wdXQpICYmIChsIDw9IGUgJiYgKG4gPSBsKSwgbCA+PSBlICYmIChyID0gbCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMSA9PT0gbiB8fCBuID09IGUgPyByIDogLTEgPT0gciB8fCBlIC0gbiA8IHIgLSBlID8gbiA6IHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHMoZSwgdCwgYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMsIHIgPSB0aGlzLm1hc2tzZXQsIG8gPSBpLmdldFRlc3RUZW1wbGF0ZS5jYWxsKG4sIGUpLm1hdGNoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJcIiA9PT0gby5kZWYgJiYgKG8gPSBpLmdldFRlc3QuY2FsbChuLCBlKS5tYXRjaCksICEwICE9PSBvLnN0YXRpYykgcmV0dXJuIG8uZm47XG4gICAgICAgICAgICAgICAgICAgIGlmICghMCA9PT0gYSAmJiB2b2lkIDAgIT09IHIudmFsaWRQb3NpdGlvbnNbZV0gJiYgITAgIT09IHIudmFsaWRQb3NpdGlvbnNbZV0uZ2VuZXJhdGVkSW5wdXQpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEwICE9PSB0ICYmIGUgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGkuZ2V0VGVzdHMuY2FsbChuLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5sZW5ndGggPiAxICsgKFwiXCIgPT09IHNbcy5sZW5ndGggLSAxXS5tYXRjaC5kZWYgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IGkuZGV0ZXJtaW5lVGVzdFRlbXBsYXRlLmNhbGwobiwgZSwgaS5nZXRUZXN0cy5jYWxsKG4sIGUpKSwgdSA9IGkuZ2V0UGxhY2Vob2xkZXIuY2FsbChuLCBlLCBsLm1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsLm1hdGNoLmRlZiAhPT0gdTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGwoZSwgdCwgYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gYSAmJiAoYSA9ICEwKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IGUgKyAxOyBcIlwiICE9PSBpLmdldFRlc3QuY2FsbChuLCByKS5tYXRjaC5kZWYgJiYgKCEwID09PSB0ICYmICghMCAhPT0gaS5nZXRUZXN0LmNhbGwobiwgcikubWF0Y2gubmV3QmxvY2tNYXJrZXIgfHwgIXMuY2FsbChuLCByLCB2b2lkIDAsICEwKSkgfHwgITAgIT09IHQgJiYgIXMuY2FsbChuLCByLCB2b2lkIDAsIGEpKTsgKSByKys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1KGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLm9wdHMsIGEgPSB0aGlzLmVsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMuaXNSVEwgfHwgXCJudW1iZXJcIiAhPSB0eXBlb2YgZSB8fCB0LmdyZWVkeSAmJiBcIlwiID09PSB0LnBsYWNlaG9sZGVyIHx8ICFhIHx8IChlID0gTWF0aC5hYnModGhpcy5fdmFsdWVHZXQoKS5sZW5ndGggLSBlKSksIFxuICAgICAgICAgICAgICAgICAgICBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA0NzEzOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gKG51bGwgIT0gZS5hbHRlcm5hdGlvbiA/IGUubWxvY1tpKGUpXSA6IGUubG9jYXRvcikuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiXCIgIT09IGEpIGZvciAoO2EubGVuZ3RoIDwgdDsgKSBhICs9IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaShlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5sb2NhdG9yW2UuYWx0ZXJuYXRpb25dO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCAmJiB0Lmxlbmd0aCA+IDAgJiYgKHQgPSB0LnNwbGl0KFwiLFwiKVswXSksIHZvaWQgMCAhPT0gdCA/IHQudG9TdHJpbmcoKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG4oZSwgdCwgYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHRoaXMub3B0cywgbiA9IHRoaXMubWFza3NldDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gKHQgPSB0IHx8IHMuY2FsbCh0aGlzLCBlKS5tYXRjaCkucGxhY2Vob2xkZXIgfHwgITAgPT09IGEpIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQucGxhY2Vob2xkZXIgPyB0LnBsYWNlaG9sZGVyKGkpIDogdC5wbGFjZWhvbGRlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEwID09PSB0LnN0YXRpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgPiAtMSAmJiB2b2lkIDAgPT09IG4udmFsaWRQb3NpdGlvbnNbZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciwgbyA9IHUuY2FsbCh0aGlzLCBlKSwgbCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLmxlbmd0aCA+IDEgKyAoXCJcIiA9PT0gb1tvLmxlbmd0aCAtIDFdLm1hdGNoLmRlZiA/IDEgOiAwKSkgZm9yICh2YXIgYyA9IDA7IGMgPCBvLmxlbmd0aDsgYysrKSBpZiAoXCJcIiAhPT0gb1tjXS5tYXRjaC5kZWYgJiYgITAgIT09IG9bY10ubWF0Y2gub3B0aW9uYWxpdHkgJiYgITAgIT09IG9bY10ubWF0Y2gub3B0aW9uYWxRdWFudGlmaWVyICYmICghMCA9PT0gb1tjXS5tYXRjaC5zdGF0aWMgfHwgdm9pZCAwID09PSByIHx8ICExICE9PSBvW2NdLm1hdGNoLmZuLnRlc3Qoci5tYXRjaC5kZWYsIG4sIGUsICEwLCBpKSkgJiYgKGwucHVzaChvW2NdKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgITAgPT09IG9bY10ubWF0Y2guc3RhdGljICYmIChyID0gb1tjXSksIGwubGVuZ3RoID4gMSAmJiAvWzAtOWEtYkEtWl0vLnRlc3QobFswXS5tYXRjaC5kZWYpKSkgcmV0dXJuIGkucGxhY2Vob2xkZXIuY2hhckF0KGUgJSBpLnBsYWNlaG9sZGVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5kZWY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkucGxhY2Vob2xkZXIuY2hhckF0KGUgJSBpLnBsYWNlaG9sZGVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHIoZSwgdCwgYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXNrc2V0LnZhbGlkUG9zaXRpb25zW2VdIHx8IG8uY2FsbCh0aGlzLCBlLCB1LmNhbGwodGhpcywgZSwgdCA/IHQuc2xpY2UoKSA6IHQsIGEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbyhlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcy5vcHRzO1xuICAgICAgICAgICAgICAgICAgICBlID0gZSA+IDAgPyBlIC0gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4sIHIsIG8sIGwgPSBhKHMuY2FsbCh0aGlzLCBlKSksIHUgPSAwOyB1IDwgdC5sZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSB0W3VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGEoYywgbC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBNYXRoLmFicyhuIC0gbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAodm9pZCAwID09PSByIHx8IFwiXCIgIT09IG4gJiYgZiA8IHIgfHwgbyAmJiAhaS5ncmVlZHkgJiYgby5tYXRjaC5vcHRpb25hbGl0eSAmJiBcIm1hc3RlclwiID09PSBvLm1hdGNoLm5ld0Jsb2NrTWFya2VyICYmICghYy5tYXRjaC5vcHRpb25hbGl0eSB8fCAhYy5tYXRjaC5uZXdCbG9ja01hcmtlcikgfHwgbyAmJiBvLm1hdGNoLm9wdGlvbmFsUXVhbnRpZmllciAmJiAhYy5tYXRjaC5vcHRpb25hbFF1YW50aWZpZXIpICYmIChyID0gZiwgXG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHMoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMubWFza3NldDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEudmFsaWRQb3NpdGlvbnNbZV0gPyBhLnZhbGlkUG9zaXRpb25zW2VdIDogKHQgfHwgdS5jYWxsKHRoaXMsIGUpKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbChlLCB0LCBhKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGkoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCwgYSA9IFtdLCBpID0gLTEsIG4gPSAwLCByID0gZS5sZW5ndGg7IG4gPCByOyBuKyspIGlmIChcIi1cIiA9PT0gZS5jaGFyQXQobikpIGZvciAodCA9IGUuY2hhckNvZGVBdChuICsgMSk7ICsraSA8IHQ7ICkgYS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaSkpOyBlbHNlIGkgPSBlLmNoYXJDb2RlQXQobiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGUuY2hhckF0KG4pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUubWF0Y2guZGVmID09PSB0Lm1hdGNoLm5hdGl2ZURlZiB8fCAhKCEoYS5yZWdleCB8fCBlLm1hdGNoLmZuIGluc3RhbmNlb2YgUmVnRXhwICYmIHQubWF0Y2guZm4gaW5zdGFuY2VvZiBSZWdFeHApIHx8ICEwID09PSBlLm1hdGNoLnN0YXRpYyB8fCAhMCA9PT0gdC5tYXRjaC5zdGF0aWMpICYmIC0xICE9PSBpKHQubWF0Y2guZm4udG9TdHJpbmcoKS5yZXBsYWNlKC9bW1xcXS9dL2csIFwiXCIpKS5pbmRleE9mKGkoZS5tYXRjaC5mbi50b1N0cmluZygpLnJlcGxhY2UoL1tbXFxdL10vZywgXCJcIikpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdShlLCB0LCBhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpLCBuID0gdGhpcywgciA9IHRoaXMuZGVwZW5kZW5jeUxpYiwgcyA9IHRoaXMubWFza3NldCwgdSA9IHRoaXMub3B0cywgYyA9IHRoaXMuZWwsIGYgPSBzLm1hc2tUb2tlbiwgZCA9IHQgPyBhIDogMCwgcCA9IHQgPyB0LnNsaWNlKCkgOiBbIDAgXSwgaCA9IFtdLCB2ID0gITEsIG0gPSB0ID8gdC5qb2luKFwiXCIpIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZyh0LCBhLCBuLCByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvKG4sIHIsIGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBwKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSAwID09PSB0Lm1hdGNoZXMuaW5kZXhPZihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgfHwgdC5tYXRjaGVzLmV2ZXJ5KChmdW5jdGlvbihpLCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITAgPT09IGkuaXNRdWFudGlmaWVyID8gYSA9IHAoZSwgdC5tYXRjaGVzW24gLSAxXSkgOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSwgXCJtYXRjaGVzXCIpICYmIChhID0gcChlLCBpKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gayhlLCB0LCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHMudGVzdHNbZV0gfHwgcy52YWxpZFBvc2l0aW9uc1tlXSkgJiYgKHMudGVzdHNbZV0gfHwgWyBzLnZhbGlkUG9zaXRpb25zW2VdIF0pLmV2ZXJ5KChmdW5jdGlvbihlLCByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5tbG9jW3RdKSByZXR1cm4gaSA9IGUsICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB2b2lkIDAgIT09IGEgPyBhIDogZS5hbHRlcm5hdGlvbiwgcyA9IHZvaWQgMCAhPT0gZS5sb2NhdG9yW29dID8gZS5sb2NhdG9yW29dLnRvU3RyaW5nKCkuaW5kZXhPZih0KSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2b2lkIDAgPT09IG4gfHwgcyA8IG4pICYmIC0xICE9PSBzICYmIChpID0gZSwgbiA9IHMpLCAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGkubG9jYXRvcltpLmFsdGVybmF0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaS5tbG9jW3RdIHx8IGkubWxvY1tyXSB8fCBpLmxvY2F0b3IpLnNsaWNlKCh2b2lkIDAgIT09IGEgPyBhIDogaS5hbHRlcm5hdGlvbikgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwICE9PSBhID8gayhlLCB0KSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24geShlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gZS5hbHRlcm5hdGlvbiwgaSA9IHZvaWQgMCA9PT0gdCB8fCBhID09PSB0LmFsdGVybmF0aW9uICYmIC0xID09PSBlLmxvY2F0b3JbYV0udG9TdHJpbmcoKS5pbmRleE9mKHQubG9jYXRvclthXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaSAmJiBhID4gdC5hbHRlcm5hdGlvbikgZm9yICh2YXIgbiA9IHQuYWx0ZXJuYXRpb247IG4gPCBhOyBuKyspIGlmIChlLmxvY2F0b3Jbbl0gIT09IHQubG9jYXRvcltuXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IG4sIGkgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm1sb2MgPSBlLm1sb2MgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGUubG9jYXRvclthXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgciAmJiAociA9IHIuc3BsaXQoXCIsXCIpWzBdKSwgdm9pZCAwID09PSBlLm1sb2Nbcl0gJiYgKGUubWxvY1tyXSA9IGUubG9jYXRvci5zbGljZSgpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG8gaW4gdC5tbG9jKSBcInN0cmluZ1wiID09IHR5cGVvZiBvICYmIChvID0gby5zcGxpdChcIixcIilbMF0pLCB2b2lkIDAgPT09IGUubWxvY1tvXSAmJiAoZS5tbG9jW29dID0gdC5tbG9jW29dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5sb2NhdG9yW2FdID0gT2JqZWN0LmtleXMoZS5tbG9jKS5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5hbHRlcm5hdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGIoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5sb2NhdG9yLmxlbmd0aCAhPT0gdC5sb2NhdG9yLmxlbmd0aCkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gZS5hbHRlcm5hdGlvbiArIDE7IGEgPCBlLmxvY2F0b3IubGVuZ3RoOyBhKyspIGlmIChlLmxvY2F0b3JbYV0gIT09IHQubG9jYXRvclthXSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkID4gZSArIHUuX21heFRlc3RQb3MpIHRocm93IFwiSW5wdXRtYXNrOiBUaGVyZSBpcyBwcm9iYWJseSBhbiBlcnJvciBpbiB5b3VyIG1hc2sgZGVmaW5pdGlvbiBvciBpbiB0aGUgY29kZS4gQ3JlYXRlIGFuIGlzc3VlIG9uIGdpdGh1YiB3aXRoIGFuIGV4YW1wbGUgb2YgdGhlIG1hc2sgeW91IGFyZSB1c2luZy4gXCIgKyBzLm1hc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPT09IGUgJiYgdm9pZCAwID09PSBuLm1hdGNoZXMpIHJldHVybiBoLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaDogbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRvcjogci5yZXZlcnNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNkOiBtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtbG9jOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBuLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4uaXNHcm91cCAmJiBmICE9PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobiA9IG8odC5tYXRjaGVzW3QubWF0Y2hlcy5pbmRleE9mKG4pICsgMV0sIHIsIGYpKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobi5pc09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IG4sIFAgPSBoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuID0gZyhuLCBhLCByLCBmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoLmZvckVhY2goKGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA+PSBQICYmIChlLm1hdGNoLm9wdGlvbmFsaXR5ID0gITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgaSA9IGhbaC5sZW5ndGggLSAxXS5tYXRjaCwgdm9pZCAwICE9PSBmIHx8ICFwKGksIHgpKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9ICEwLCBkID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuLmlzQWx0ZXJuYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEUsIFMgPSBuLCBfID0gW10sIE0gPSBoLnNsaWNlKCksIHcgPSByLmxlbmd0aCwgTyA9ICExLCBUID0gYS5sZW5ndGggPiAwID8gYS5zaGlmdCgpIDogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLTEgPT09IFQgfHwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBDLCBBID0gZCwgRCA9IGEuc2xpY2UoKSwgQiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBUKSBCID0gVC5zcGxpdChcIixcIik7IGVsc2UgZm9yIChDID0gMDsgQyA8IFMubWF0Y2hlcy5sZW5ndGg7IEMrKykgQi5wdXNoKEMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gcy5leGNsdWRlc1tlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gQi5zbGljZSgpLCBSID0gMCwgTCA9IHMuZXhjbHVkZXNbZV0ubGVuZ3RoOyBSIDwgTDsgUisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgSSA9IHMuZXhjbHVkZXNbZV1bUl0udG9TdHJpbmcoKS5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmxlbmd0aCA9PSBJWzFdICYmIEIuc3BsaWNlKEIuaW5kZXhPZihJWzBdKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCA9PT0gQi5sZW5ndGggJiYgKGRlbGV0ZSBzLmV4Y2x1ZGVzW2VdLCBCID0gaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICghMCA9PT0gdS5rZWVwU3RhdGljIHx8IGlzRmluaXRlKHBhcnNlSW50KHUua2VlcFN0YXRpYykpICYmIEEgPj0gdS5rZWVwU3RhdGljKSAmJiAoQiA9IEIuc2xpY2UoMCwgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIEYgPSAwOyBGIDwgQi5sZW5ndGg7IEYrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDID0gcGFyc2VJbnQoQltGXSksIGggPSBbXSwgYSA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIFQgJiYgayhkLCBDLCB3KSB8fCBELnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBOID0gUy5tYXRjaGVzW0NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTiAmJiBvKE4sIFsgQyBdLmNvbmNhdChyKSwgZikpIG4gPSAhMDsgZWxzZSBpZiAoMCA9PT0gRiAmJiAoTyA9ICEwKSwgTiAmJiBOLm1hdGNoZXMgJiYgTi5tYXRjaGVzLmxlbmd0aCA+IFMubWF0Y2hlc1swXS5tYXRjaGVzLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEUgPSBoLnNsaWNlKCksIGQgPSBBLCBoID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIFYgPSAwOyBWIDwgRS5sZW5ndGg7IFYrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEcgPSBFW1ZdLCBIID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHLm1hdGNoLmppdCA9IEcubWF0Y2guaml0IHx8IE8sIEcuYWx0ZXJuYXRpb24gPSBHLmFsdGVybmF0aW9uIHx8IHcsIHkoRyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBLID0gMDsgSyA8IF8ubGVuZ3RoOyBLKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgVSA9IF9bS107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIFQgfHwgdm9pZCAwICE9PSBHLmFsdGVybmF0aW9uICYmIEIuaW5jbHVkZXMoRy5sb2NhdG9yW0cuYWx0ZXJuYXRpb25dLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChHLm1hdGNoLm5hdGl2ZURlZiA9PT0gVS5tYXRjaC5uYXRpdmVEZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEggPSAhMCwgeShVLCBHKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsKEcsIFUsIHUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KEcsIFUpICYmIChIID0gITAsIF8uc3BsaWNlKF8uaW5kZXhPZihVKSwgMCwgRykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwoVSwgRywgdSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoVSwgRyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoUSA9IFUsICEwID09PSAoVyA9IEcpLm1hdGNoLnN0YXRpYyAmJiAhMCAhPT0gUS5tYXRjaC5zdGF0aWMgJiYgUS5tYXRjaC5mbi50ZXN0KFcubWF0Y2guZGVmLCBzLCBlLCAhMSwgdSwgITEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiKEcsIFUpIHx8IHZvaWQgMCAhPT0gYy5pbnB1dG1hc2sudXNlck9wdGlvbnMua2VlcFN0YXRpYyA/IHkoRywgVSkgJiYgKEggPSAhMCwgXy5zcGxpY2UoXy5pbmRleE9mKFUpLCAwLCBHKSkgOiB1LmtlZXBTdGF0aWMgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSCB8fCBfLnB1c2goRyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9IE0uY29uY2F0KF8pLCBkID0gZSwgdiA9IGgubGVuZ3RoID4gMCwgbiA9IF8ubGVuZ3RoID4gMCwgYSA9IEQuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBuID0gbyhTLm1hdGNoZXNbVF0gfHwgdC5tYXRjaGVzW1RdLCBbIFQgXS5jb25jYXQociksIGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4pIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuLmlzUXVhbnRpZmllciAmJiBmICE9PSB0Lm1hdGNoZXNbdC5tYXRjaGVzLmluZGV4T2YobikgLSAxXSkgZm9yICh2YXIgJCA9IG4sIHogPSBhLmxlbmd0aCA+IDAgPyBhLnNoaWZ0KCkgOiAwOyB6IDwgKGlzTmFOKCQucXVhbnRpZmllci5tYXgpID8geiArIDEgOiAkLnF1YW50aWZpZXIubWF4KSAmJiBkIDw9IGU7IHorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSB0Lm1hdGNoZXNbdC5tYXRjaGVzLmluZGV4T2YoJCkgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuID0gbyhxLCBbIHogXS5jb25jYXQociksIHEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChpID0gaFtoLmxlbmd0aCAtIDFdLm1hdGNoKS5vcHRpb25hbFF1YW50aWZpZXIgPSB6ID49ICQucXVhbnRpZmllci5taW4sIGkuaml0ID0gKHogKyAxKSAqIChxLm1hdGNoZXMuaW5kZXhPZihpKSArIDEpID4gJC5xdWFudGlmaWVyLmppdCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaS5vcHRpb25hbFF1YW50aWZpZXIgJiYgcChpLCBxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gITAsIGQgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkuaml0ICYmIChzLmppdE9mZnNldFtlXSA9IHEubWF0Y2hlcy5sZW5ndGggLSBxLm1hdGNoZXMuaW5kZXhPZihpKSksICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG4gPSBnKG4sIGEsIHIsIGYpKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgVywgUTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGYgPSBhLmxlbmd0aCA+IDAgPyBhLnNoaWZ0KCkgOiAwOyBmIDwgdC5tYXRjaGVzLmxlbmd0aDsgZisrKSBpZiAoITAgIT09IHQubWF0Y2hlc1tmXS5pc1F1YW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG8odC5tYXRjaGVzW2ZdLCBbIGYgXS5jb25jYXQobiksIHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwICYmIGQgPT09IGUpIHJldHVybiBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkID4gZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGssIHkgPSBlIC0gMTsgdm9pZCAwID09PSAoayA9IHMudmFsaWRQb3NpdGlvbnNbeV0gfHwgcy50ZXN0c1t5XSkgJiYgeSA+IC0xOyApIHktLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGsgJiYgeSA+IC0xICYmIChwID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSwgaSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSB8fCAodCA9IFsgdCBdKSwgdC5sZW5ndGggPiAwICYmICh2b2lkIDAgPT09IHRbMF0uYWx0ZXJuYXRpb24gfHwgITAgPT09IHUua2VlcFN0YXRpYyA/IDAgPT09IChpID0gby5jYWxsKG4sIGUsIHQuc2xpY2UoKSkubG9jYXRvci5zbGljZSgpKS5sZW5ndGggJiYgKGkgPSB0WzBdLmxvY2F0b3Iuc2xpY2UoKSkgOiB0LmZvckVhY2goKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIgIT09IGUuZGVmICYmICgwID09PSBpLmxlbmd0aCA/IChhID0gZS5hbHRlcm5hdGlvbiwgaSA9IGUubG9jYXRvci5zbGljZSgpKSA6IGUubG9jYXRvclthXSAmJiAtMSA9PT0gaVthXS50b1N0cmluZygpLmluZGV4T2YoZS5sb2NhdG9yW2FdKSAmJiAoaVthXSArPSBcIixcIiArIGUubG9jYXRvclthXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpLCBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oeSwgayksIG0gPSBwLmpvaW4oXCJcIiksIGQgPSB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnRlc3RzW2VdICYmIHMudGVzdHNbZV1bMF0uY2QgPT09IG0pIHJldHVybiBzLnRlc3RzW2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IHAuc2hpZnQoKTsgYiA8IGYubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZyhmW2JdLCBwLCBbIGIgXSkgJiYgZCA9PT0gZSB8fCBkID4gZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwID09PSBoLmxlbmd0aCB8fCB2KSAmJiBoLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWM6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsaXR5OiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNpbmc6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRvcjogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBtbG9jOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNkOiBtXG4gICAgICAgICAgICAgICAgICAgIH0pLCB2b2lkIDAgIT09IHQgJiYgcy50ZXN0c1tlXSA/IHIuZXh0ZW5kKCEwLCBbXSwgaCkgOiAocy50ZXN0c1tlXSA9IHIuZXh0ZW5kKCEwLCBbXSwgaCksIFxuICAgICAgICAgICAgICAgICAgICBzLnRlc3RzW2VdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmRldGVybWluZVRlc3RUZW1wbGF0ZSA9IG8sIHQuZ2V0RGVjaXNpb25UYWtlciA9IGksIHQuZ2V0TWFza1RlbXBsYXRlID0gZnVuY3Rpb24oZSwgdCwgYSwgaSwgcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHRoaXMsIGMgPSB0aGlzLm9wdHMsIGYgPSB0aGlzLm1hc2tzZXQsIGQgPSBjLmdyZWVkeTtcbiAgICAgICAgICAgICAgICAgICAgcyAmJiAoYy5ncmVlZHkgPSAhMSk7XG4gICAgICAgICAgICAgICAgICAgIHQgPSB0IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwLCBoLCB2LCBtLCBnID0gW10sIGsgPSAwO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoITAgPT09IGUgJiYgZi52YWxpZFBvc2l0aW9uc1trXSkgdiA9IHMgJiYgITAgPT09IGYudmFsaWRQb3NpdGlvbnNba10ubWF0Y2gub3B0aW9uYWxpdHkgJiYgdm9pZCAwID09PSBmLnZhbGlkUG9zaXRpb25zW2sgKyAxXSAmJiAoITAgPT09IGYudmFsaWRQb3NpdGlvbnNba10uZ2VuZXJhdGVkSW5wdXQgfHwgZi52YWxpZFBvc2l0aW9uc1trXS5pbnB1dCA9PSBjLnNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXIgJiYgayA+IDApID8gby5jYWxsKGwsIGssIHUuY2FsbChsLCBrLCBwLCBrIC0gMSkpIDogZi52YWxpZFBvc2l0aW9uc1trXSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gdi5tYXRjaCwgcCA9IHYubG9jYXRvci5zbGljZSgpLCBnLnB1c2goITAgPT09IGEgPyB2LmlucHV0IDogITEgPT09IGEgPyBoLm5hdGl2ZURlZiA6IG4uY2FsbChsLCBrLCBoKSk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSByLmNhbGwobCwgaywgcCwgayAtIDEpLCBoID0gdi5tYXRjaCwgcCA9IHYubG9jYXRvci5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gITAgIT09IGkgJiYgKCExICE9PSBjLmppdE1hc2tpbmcgPyBjLmppdE1hc2tpbmcgOiBoLmppdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG0gPSAobSAmJiBoLnN0YXRpYyAmJiBoLmRlZiAhPT0gYy5ncm91cFNlcGFyYXRvciAmJiBudWxsID09PSBoLmZuIHx8IGYudmFsaWRQb3NpdGlvbnNbayAtIDFdICYmIGguc3RhdGljICYmIGguZGVmICE9PSBjLmdyb3VwU2VwYXJhdG9yICYmIG51bGwgPT09IGguZm4pICYmIGYudGVzdHNba10gJiYgMSA9PT0gZi50ZXN0c1trXS5sZW5ndGgpIHx8ICExID09PSB5IHx8IHZvaWQgMCA9PT0geSB8fCBcIm51bWJlclwiID09IHR5cGVvZiB5ICYmIGlzRmluaXRlKHkpICYmIHkgPiBrID8gZy5wdXNoKCExID09PSBhID8gaC5uYXRpdmVEZWYgOiBuLmNhbGwobCwgaywgaCkpIDogbSA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICghMCAhPT0gaC5zdGF0aWMgfHwgXCJcIiAhPT0gaC5kZWYgfHwgdCA+IGspO1xuICAgICAgICAgICAgICAgICAgICBcIlwiID09PSBnW2cubGVuZ3RoIC0gMV0gJiYgZy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgITEgPT09IGEgJiYgdm9pZCAwICE9PSBmLm1hc2tMZW5ndGggfHwgKGYubWFza0xlbmd0aCA9IGsgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMuZ3JlZWR5ID0gZCwgZztcbiAgICAgICAgICAgICAgICB9LCB0LmdldFBsYWNlaG9sZGVyID0gbiwgdC5nZXRUZXN0ID0gcywgdC5nZXRUZXN0cyA9IHUsIHQuZ2V0VGVzdFRlbXBsYXRlID0gciwgdC5pc1N1YnNldE9mID0gbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA3MjE1OiBmdW5jdGlvbihlLCB0LCBhKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgICAgIH0pLCB0LmFsdGVybmF0ZSA9IGwsIHQuY2hlY2tBbHRlcm5hdGlvbk1hdGNoID0gZnVuY3Rpb24oZSwgdCwgYSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpLCBuID0gdGhpcy5vcHRzLmdyZWVkeSA/IHQgOiB0LnNsaWNlKDAsIDEpLCByID0gITEsIG8gPSB2b2lkIDAgIT09IGEgPyBhLnNwbGl0KFwiLFwiKSA6IFtdLCBzID0gMDsgcyA8IG8ubGVuZ3RoOyBzKyspIC0xICE9PSAoaSA9IGUuaW5kZXhPZihvW3NdKSkgJiYgZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgZS5sZW5ndGg7IGwrKykgaWYgKG4uaW5jbHVkZXMoZVtsXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgIH0sIHQuaXNDb21wbGV0ZSA9IGMsIHQuaXNWYWxpZCA9IGYsIHQucmVmcmVzaEZyb21CdWZmZXIgPSBwLCB0LnJldmFsaWRhdGVNYXNrID0gdiwgXG4gICAgICAgICAgICAgICAgdC5oYW5kbGVSZW1vdmUgPSBmdW5jdGlvbihlLCB0LCBhLCBpLCBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1ID0gdGhpcywgYyA9IHRoaXMubWFza3NldCwgZiA9IHRoaXMub3B0cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKChmLm51bWVyaWNJbnB1dCB8fCB1LmlzUlRMKSAmJiAodCA9PT0gci5kZWZhdWx0LkJBQ0tTUEFDRSA/IHQgPSByLmRlZmF1bHQuREVMRVRFIDogdCA9PT0gci5kZWZhdWx0LkRFTEVURSAmJiAodCA9IHIuZGVmYXVsdC5CQUNLU1BBQ0UpLCBcbiAgICAgICAgICAgICAgICAgICAgdS5pc1JUTCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gYS5lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLmVuZCA9IGEuYmVnaW4sIGEuYmVnaW4gPSBkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBwLCBoID0gby5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKHUsIHZvaWQgMCwgITApO1xuICAgICAgICAgICAgICAgICAgICBhLmVuZCA+PSBvLmdldEJ1ZmZlci5jYWxsKHUpLmxlbmd0aCAmJiBoID49IGEuZW5kICYmIChhLmVuZCA9IGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdCA9PT0gci5kZWZhdWx0LkJBQ0tTUEFDRSA/IGEuZW5kIC0gYS5iZWdpbiA8IDEgJiYgKGEuYmVnaW4gPSBvLnNlZWtQcmV2aW91cy5jYWxsKHUsIGEuYmVnaW4pKSA6IHQgPT09IHIuZGVmYXVsdC5ERUxFVEUgJiYgYS5iZWdpbiA9PT0gYS5lbmQgJiYgKGEuZW5kID0gby5pc01hc2suY2FsbCh1LCBhLmVuZCwgITAsICEwKSA/IGEuZW5kICsgMSA6IG8uc2Vla05leHQuY2FsbCh1LCBhLmVuZCkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCExICE9PSAocCA9IHYuY2FsbCh1LCBhKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMCAhPT0gaSAmJiAhMSAhPT0gZi5rZWVwU3RhdGljIHx8IG51bGwgIT09IGYucmVnZXggJiYgLTEgIT09IG4uZ2V0VGVzdC5jYWxsKHUsIGEuYmVnaW4pLm1hdGNoLmRlZi5pbmRleE9mKFwifFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gbC5jYWxsKHUsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IHZvaWQgMCAhPT0gbS5jYXJldCA/IG0uY2FyZXQgOiBtLnBvcyA/IG8uc2Vla05leHQuY2FsbCh1LCBtLnBvcy5iZWdpbiA/IG0ucG9zLmJlZ2luIDogbS5wb3MpIDogby5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKHUsIC0xLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0ICE9PSByLmRlZmF1bHQuREVMRVRFIHx8IGEuYmVnaW4gPiBnKSAmJiBhLmJlZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICEwICE9PSBpICYmIChjLnAgPSB0ID09PSByLmRlZmF1bHQuREVMRVRFID8gYS5iZWdpbiArIHAgOiBhLmJlZ2luLCBjLnAgPSBvLmRldGVybWluZU5ld0NhcmV0UG9zaXRpb24uY2FsbCh1LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW46IGMucCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGMucFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgITEpLmJlZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGksIG4gPSBhKDQ3MTMpLCByID0gKGkgPSBhKDQ1MjgpKSAmJiBpLl9fZXNNb2R1bGUgPyBpIDoge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBpXG4gICAgICAgICAgICAgICAgfSwgbyA9IGEoODcxMSksIHMgPSBhKDYwMzApO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGwoZSwgdCwgYSwgaSwgciwgcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdSwgYywgZCwgcCwgaCwgdiwgbSwgZywgaywgeSwgYiwgeCA9IHRoaXMsIFAgPSB0aGlzLmRlcGVuZGVuY3lMaWIsIEUgPSB0aGlzLm9wdHMsIFMgPSB4Lm1hc2tzZXQsIF8gPSBQLmV4dGVuZCghMCwge30sIFMudmFsaWRQb3NpdGlvbnMpLCBNID0gUC5leHRlbmQoITAsIHt9LCBTLnRlc3RzKSwgdyA9ICExLCBPID0gITEsIFQgPSB2b2lkIDAgIT09IHIgPyByIDogby5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocyAmJiAoeSA9IHMuYmVnaW4sIGIgPSBzLmVuZCwgcy5iZWdpbiA+IHMuZW5kICYmICh5ID0gcy5lbmQsIGIgPSBzLmJlZ2luKSksIFxuICAgICAgICAgICAgICAgICAgICAtMSA9PT0gVCAmJiB2b2lkIDAgPT09IHIpIHUgPSAwLCBjID0gKHAgPSBuLmdldFRlc3QuY2FsbCh4LCB1KSkuYWx0ZXJuYXRpb247IGVsc2UgZm9yICg7VCA+PSAwOyBULS0pIGlmICgoZCA9IFMudmFsaWRQb3NpdGlvbnNbVF0pICYmIHZvaWQgMCAhPT0gZC5hbHRlcm5hdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgJiYgcC5sb2NhdG9yW2QuYWx0ZXJuYXRpb25dICE9PSBkLmxvY2F0b3JbZC5hbHRlcm5hdGlvbl0pIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdSA9IFQsIGMgPSBTLnZhbGlkUG9zaXRpb25zW3VdLmFsdGVybmF0aW9uLCBwID0gZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gcGFyc2VJbnQodSksIFMuZXhjbHVkZXNbbV0gPSBTLmV4Y2x1ZGVzW21dIHx8IFtdLCAhMCAhPT0gZSAmJiBTLmV4Y2x1ZGVzW21dLnB1c2goKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgbi5nZXREZWNpc2lvblRha2VyKShwKSArIFwiOlwiICsgcC5hbHRlcm5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgQyA9IFtdLCBBID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGggPSBtOyBoIDwgby5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKHgsIHZvaWQgMCwgITApICsgMTsgaCsrKSAtMSA9PT0gQSAmJiBlIDw9IGggJiYgdm9pZCAwICE9PSB0ICYmIChDLnB1c2godCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgQSA9IEMubGVuZ3RoIC0gMSksICh2ID0gUy52YWxpZFBvc2l0aW9uc1toXSkgJiYgITAgIT09IHYuZ2VuZXJhdGVkSW5wdXQgJiYgKHZvaWQgMCA9PT0gcyB8fCBoIDwgeSB8fCBoID49IGIpICYmIEMucHVzaCh2LmlucHV0KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgUy52YWxpZFBvc2l0aW9uc1toXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoLTEgPT09IEEgJiYgdm9pZCAwICE9PSB0ICYmIChDLnB1c2godCksIEEgPSBDLmxlbmd0aCAtIDEpOyB2b2lkIDAgIT09IFMuZXhjbHVkZXNbbV0gJiYgUy5leGNsdWRlc1ttXS5sZW5ndGggPCAxMDsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChTLnRlc3RzID0ge30sIG8ucmVzZXRNYXNrU2V0LmNhbGwoeCwgITApLCB3ID0gITAsIGggPSAwOyBoIDwgQy5sZW5ndGggJiYgKGcgPSB3LmNhcmV0IHx8IG8uZ2V0TGFzdFZhbGlkUG9zaXRpb24uY2FsbCh4LCB2b2lkIDAsICEwKSArIDEsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBDW2hdLCB3ID0gZi5jYWxsKHgsIGcsIGssICExLCBpLCAhMCkpOyBoKyspIGggPT09IEEgJiYgKE8gPSB3KSwgMSA9PSBlICYmIHcgJiYgKE8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zOiBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLnJlc2V0TWFza1NldC5jYWxsKHgpLCBwID0gbi5nZXRUZXN0LmNhbGwoeCwgbSksIFMudmFsaWRQb3NpdGlvbnMgPSBQLmV4dGVuZCghMCwge30sIF8pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTLnRlc3RzID0gUC5leHRlbmQoITAsIHt9LCBNKSwgIVMuZXhjbHVkZXNbbV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyA9IGwuY2FsbCh4LCBlLCB0LCBhLCBpLCBtIC0gMSwgcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgRCA9ICgwLCBuLmdldERlY2lzaW9uVGFrZXIpKHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gUy5leGNsdWRlc1ttXS5pbmRleE9mKEQgKyBcIjpcIiArIHAuYWx0ZXJuYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8gPSBsLmNhbGwoeCwgZSwgdCwgYSwgaSwgbSAtIDEsIHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChTLmV4Y2x1ZGVzW21dLnB1c2goRCArIFwiOlwiICsgcC5hbHRlcm5hdGlvbiksIGggPSBtOyBoIDwgby5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKHgsIHZvaWQgMCwgITApICsgMTsgaCsrKSBkZWxldGUgUy52YWxpZFBvc2l0aW9uc1toXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTyAmJiAhMSA9PT0gRS5rZWVwU3RhdGljIHx8IGRlbGV0ZSBTLmV4Y2x1ZGVzW21dLCBPO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1KGUsIHQsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLm9wdHMsIG4gPSB0aGlzLm1hc2tzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoaS5jYXNpbmcgfHwgdC5jYXNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidXBwZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBlLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsb3dlclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IG4udmFsaWRQb3NpdGlvbnNbYSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IDAgPT09IGEgfHwgbyAmJiBvLmlucHV0ID09PSBTdHJpbmcuZnJvbUNoYXJDb2RlKHIuZGVmYXVsdC5TUEFDRSkgPyBlLnRvVXBwZXJDYXNlKCkgOiBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBpLmNhc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLnB1c2gobi52YWxpZFBvc2l0aW9ucyksIGUgPSBpLmNhc2luZy5hcHBseSh0aGlzLCBzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYyhlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcywgYSA9IHRoaXMub3B0cywgaSA9IHRoaXMubWFza3NldDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYS5pc0NvbXBsZXRlKSByZXR1cm4gYS5pc0NvbXBsZXRlKGUsIGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCIqXCIgIT09IGEucmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9ICExLCBzID0gby5kZXRlcm1pbmVMYXN0UmVxdWlyZWRQb3NpdGlvbi5jYWxsKHQsICEwKSwgbCA9IG8uc2Vla1ByZXZpb3VzLmNhbGwodCwgcy5sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHMuZGVmIHx8IHMuZGVmLm5ld0Jsb2NrTWFya2VyIHx8IHMuZGVmLm9wdGlvbmFsaXR5IHx8IHMuZGVmLm9wdGlvbmFsUXVhbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB1ID0gMDsgdSA8PSBsOyB1KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBuLmdldFRlc3RUZW1wbGF0ZS5jYWxsKHQsIHUpLm1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoITAgIT09IGMuc3RhdGljICYmIHZvaWQgMCA9PT0gaS52YWxpZFBvc2l0aW9uc1t1XSAmJiAhMCAhPT0gYy5vcHRpb25hbGl0eSAmJiAhMCAhPT0gYy5vcHRpb25hbFF1YW50aWZpZXIgfHwgITAgPT09IGMuc3RhdGljICYmIGVbdV0gIT09IG4uZ2V0UGxhY2Vob2xkZXIuY2FsbCh0LCB1LCBjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKGUsIHQsIGEsIGksIHIsIHMsIGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSB0aGlzLCBnID0gdGhpcy5kZXBlbmRlbmN5TGliLCBrID0gdGhpcy5vcHRzLCB5ID0gbS5tYXNrc2V0O1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBiKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtLmlzUlRMID8gZS5iZWdpbiAtIGUuZW5kID4gMSB8fCBlLmJlZ2luIC0gZS5lbmQgPT0gMSA6IGUuZW5kIC0gZS5iZWdpbiA+IDEgfHwgZS5lbmQgLSBlLmJlZ2luID09IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYSA9ICEwID09PSBhO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGU7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGUucmVtb3ZlICYmIChBcnJheS5pc0FycmF5KGUucmVtb3ZlKSB8fCAoZS5yZW1vdmUgPSBbIGUucmVtb3ZlIF0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZS5zb3J0KChmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LnBvcyAtIGUucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5mb3JFYWNoKChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuY2FsbChtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbjogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZSArIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLCBlLnJlbW92ZSA9IHZvaWQgMCksIHZvaWQgMCAhPT0gZS5pbnNlcnQgJiYgKEFycmF5LmlzQXJyYXkoZS5pbnNlcnQpIHx8IChlLmluc2VydCA9IFsgZS5pbnNlcnQgXSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuaW5zZXJ0LnNvcnQoKGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUucG9zIC0gdC5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLmZvckVhY2goKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiAhPT0gZS5jICYmIGYuY2FsbChtLCBlLnBvcywgZS5jLCB2b2lkIDAgPT09IGUuc3RyaWN0IHx8IGUuc3RyaWN0LCB2b2lkIDAgIT09IGUuZnJvbUlzVmFsaWQgPyBlLmZyb21Jc1ZhbGlkIDogaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLCBlLmluc2VydCA9IHZvaWQgMCksIGUucmVmcmVzaEZyb21CdWZmZXIgJiYgZS5idWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLnJlZnJlc2hGcm9tQnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmNhbGwobSwgITAgPT09IHQgPyB0IDogdC5zdGFydCwgdC5lbmQsIGUuYnVmZmVyKSwgZS5yZWZyZXNoRnJvbUJ1ZmZlciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBlLnJld3JpdGVQb3NpdGlvbiAmJiAoeCA9IGUucmV3cml0ZVBvc2l0aW9uLCBlID0gITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gRSh0LCBhLCByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4uZ2V0VGVzdHMuY2FsbChtLCB0KS5ldmVyeSgoZnVuY3Rpb24obCwgYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gbC5tYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5nZXRCdWZmZXIuY2FsbChtLCAhMCksICExICE9PSAocyA9ICghZi5qaXQgfHwgdm9pZCAwICE9PSB5LnZhbGlkUG9zaXRpb25zW28uc2Vla1ByZXZpb3VzLmNhbGwobSwgdCldKSAmJiAobnVsbCAhPSBmLmZuID8gZi5mbi50ZXN0KGEsIHksIHQsIHIsIGssIGIoZSkpIDogKGEgPT09IGYuZGVmIHx8IGEgPT09IGsuc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlcikgJiYgXCJcIiAhPT0gZi5kZWYgJiYge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjOiBuLmdldFBsYWNlaG9sZGVyLmNhbGwobSwgdCwgZiwgITApIHx8IGYuZGVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSB2b2lkIDAgIT09IHMuYyA/IHMuYyA6IGEsIHAgPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZCA9IGQgPT09IGsuc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlciAmJiAhMCA9PT0gZi5zdGF0aWMgPyBuLmdldFBsYWNlaG9sZGVyLmNhbGwobSwgdCwgZiwgITApIHx8IGYuZGVmIDogZCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICEwICE9PSAocyA9IFAocykpICYmIHZvaWQgMCAhPT0gcy5wb3MgJiYgcy5wb3MgIT09IHQgJiYgKHAgPSBzLnBvcyksICEwICE9PSBzICYmIHZvaWQgMCA9PT0gcy5wb3MgJiYgdm9pZCAwID09PSBzLmMgPyAhMSA6ICghMSA9PT0gdi5jYWxsKG0sIGUsIGcuZXh0ZW5kKHt9LCBsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogdS5jYWxsKG0sIGQsIGYsIHApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBpLCBwKSAmJiAocyA9ICExKSwgITEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSksIHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBlLmJlZ2luICYmICh4ID0gbS5pc1JUTCA/IGUuZW5kIDogZS5iZWdpbik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBTID0gITAsIF8gPSBnLmV4dGVuZCghMCwge30sIHkudmFsaWRQb3NpdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoITEgPT09IGsua2VlcFN0YXRpYyAmJiB2b2lkIDAgIT09IHkuZXhjbHVkZXNbeF0gJiYgITAgIT09IHIgJiYgITAgIT09IGkpIGZvciAodmFyIE0gPSB4OyBNIDwgKG0uaXNSVEwgPyBlLmJlZ2luIDogZS5lbmQpOyBNKyspIHZvaWQgMCAhPT0geS5leGNsdWRlc1tNXSAmJiAoeS5leGNsdWRlc1tNXSA9IHZvaWQgMCwgXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB5LnRlc3RzW01dKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygay5wcmVWYWxpZGF0aW9uICYmICEwICE9PSBpICYmICEwICE9PSBzICYmIChTID0gUChTID0gay5wcmVWYWxpZGF0aW9uLmNhbGwobSwgby5nZXRCdWZmZXIuY2FsbChtKSwgeCwgdCwgYihlKSwgaywgeSwgZSwgYSB8fCByKSkpLCBcbiAgICAgICAgICAgICAgICAgICAgITAgPT09IFMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTID0gRSh4LCB0LCBhKSwgKCFhIHx8ICEwID09PSBpKSAmJiAhMSA9PT0gUyAmJiAhMCAhPT0gcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ID0geS52YWxpZFBvc2l0aW9uc1t4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXcgfHwgITAgIT09IHcubWF0Y2guc3RhdGljIHx8IHcubWF0Y2guZGVmICE9PSB0ICYmIHQgIT09IGsuc2tpcE9wdGlvbmFsUGFydENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoay5pbnNlcnRNb2RlIHx8IHZvaWQgMCA9PT0geS52YWxpZFBvc2l0aW9uc1tvLnNlZWtOZXh0LmNhbGwobSwgeCldIHx8IGUuZW5kID4geCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE8gPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5LmppdE9mZnNldFt4XSAmJiB2b2lkIDAgPT09IHkudmFsaWRQb3NpdGlvbnNbby5zZWVrTmV4dC5jYWxsKG0sIHgpXSAmJiAhMSAhPT0gKFMgPSBmLmNhbGwobSwgeCArIHkuaml0T2Zmc2V0W3hdLCB0LCAhMCwgITApKSAmJiAoITAgIT09IHIgJiYgKFMuY2FyZXQgPSB4KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPID0gITApLCBlLmVuZCA+IHggJiYgKHkudmFsaWRQb3NpdGlvbnNbeF0gPSB2b2lkIDApLCAhTyAmJiAhby5pc01hc2suY2FsbChtLCB4LCBrLmtlZXBTdGF0aWMgJiYgMCA9PT0geCkpIGZvciAodmFyIFQgPSB4ICsgMSwgQyA9IG8uc2Vla05leHQuY2FsbChtLCB4LCAhMSwgMCAhPT0geCk7IFQgPD0gQzsgVCsrKSBpZiAoITEgIT09IChTID0gRShULCB0LCBhKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTID0gaC5jYWxsKG0sIHgsIHZvaWQgMCAhPT0gUy5wb3MgPyBTLnBvcyA6IFQpIHx8IFMsIHggPSBUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIFMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0OiBvLnNlZWtOZXh0LmNhbGwobSwgeClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgITEgIT09IFMgfHwgIWsua2VlcFN0YXRpYyB8fCAhYy5jYWxsKG0sIG8uZ2V0QnVmZmVyLmNhbGwobSkpICYmIDAgIT09IHggfHwgYSB8fCAhMCA9PT0gciA/IGIoZSkgJiYgeS50ZXN0c1t4XSAmJiB5LnRlc3RzW3hdLmxlbmd0aCA+IDEgJiYgay5rZWVwU3RhdGljICYmICFhICYmICEwICE9PSByICYmIChTID0gbC5jYWxsKG0sICEwKSkgOiBTID0gbC5jYWxsKG0sIHgsIHQsIGEsIGksIHZvaWQgMCwgZSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgITAgPT09IFMgJiYgKFMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiB4XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBrLnBvc3RWYWxpZGF0aW9uICYmICEwICE9PSBpICYmICEwICE9PSBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgQSA9IGsucG9zdFZhbGlkYXRpb24uY2FsbChtLCBvLmdldEJ1ZmZlci5jYWxsKG0sICEwKSwgdm9pZCAwICE9PSBlLmJlZ2luID8gbS5pc1JUTCA/IGUuZW5kIDogZS5iZWdpbiA6IGUsIHQsIFMsIGssIHksIGEsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBBICYmIChTID0gITAgPT09IEEgPyBTIDogQSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgUyAmJiB2b2lkIDAgPT09IFMucG9zICYmIChTLnBvcyA9IHgpLCAhMSA9PT0gUyB8fCAhMCA9PT0gcyA/IChvLnJlc2V0TWFza1NldC5jYWxsKG0sICEwKSwgXG4gICAgICAgICAgICAgICAgICAgIHkudmFsaWRQb3NpdGlvbnMgPSBnLmV4dGVuZCghMCwge30sIF8pKSA6IGguY2FsbChtLCB2b2lkIDAsIHgsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIEQgPSBQKFMpO1xuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IG0ubWF4TGVuZ3RoICYmIChvLmdldEJ1ZmZlci5jYWxsKG0pLmxlbmd0aCA+IG0ubWF4TGVuZ3RoICYmICFpICYmIChvLnJlc2V0TWFza1NldC5jYWxsKG0sICEwKSwgXG4gICAgICAgICAgICAgICAgICAgIHkudmFsaWRQb3NpdGlvbnMgPSBnLmV4dGVuZCghMCwge30sIF8pLCBEID0gITEpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGQoZSwgdCwgYSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5tYXNrc2V0LCByID0gITEsIG8gPSBuLmdldFRlc3RzLmNhbGwodGhpcywgZSksIHMgPSAwOyBzIDwgby5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9bc10ubWF0Y2ggJiYgKG9bc10ubWF0Y2gubmF0aXZlRGVmID09PSB0Lm1hdGNoW2Euc2hpZnRQb3NpdGlvbnMgPyBcImRlZlwiIDogXCJuYXRpdmVEZWZcIl0gJiYgKCFhLnNoaWZ0UG9zaXRpb25zIHx8ICF0Lm1hdGNoLnN0YXRpYykgfHwgb1tzXS5tYXRjaC5uYXRpdmVEZWYgPT09IHQubWF0Y2gubmF0aXZlRGVmIHx8IGEucmVnZXggJiYgIW9bc10ubWF0Y2guc3RhdGljICYmIG9bc10ubWF0Y2guZm4udGVzdCh0LmlucHV0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob1tzXS5tYXRjaCAmJiBvW3NdLm1hdGNoLmRlZiA9PT0gdC5tYXRjaC5uYXRpdmVEZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMSA9PT0gciAmJiB2b2lkIDAgIT09IGkuaml0T2Zmc2V0W2VdICYmIChyID0gZC5jYWxsKHRoaXMsIGUgKyBpLmppdE9mZnNldFtlXSwgdCwgYSkpLCBcbiAgICAgICAgICAgICAgICAgICAgcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcChlLCB0LCBhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpLCBuLCByID0gdGhpcywgbCA9IHRoaXMubWFza3NldCwgdSA9IHRoaXMub3B0cywgYyA9IHRoaXMuZGVwZW5kZW5jeUxpYiwgZiA9IHUuc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlciwgZCA9IHIuaXNSVEwgPyBhLnNsaWNlKCkucmV2ZXJzZSgpIDogYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUuc2tpcE9wdGlvbmFsUGFydENoYXJhY3RlciA9IFwiXCIsICEwID09PSBlKSBvLnJlc2V0TWFza1NldC5jYWxsKHIpLCBsLnRlc3RzID0ge30sIFxuICAgICAgICAgICAgICAgICAgICBlID0gMCwgdCA9IGEubGVuZ3RoLCBuID0gby5kZXRlcm1pbmVOZXdDYXJldFBvc2l0aW9uLmNhbGwociwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IDBcbiAgICAgICAgICAgICAgICAgICAgfSwgITEpLmJlZ2luOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGU7IGkgPCB0OyBpKyspIGRlbGV0ZSBsLnZhbGlkUG9zaXRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgYy5FdmVudChcImtleXByZXNzXCIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBlOyBpIDwgdDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLndoaWNoID0gZFtpXS50b1N0cmluZygpLmNoYXJDb2RlQXQoMCksIHIuaWdub3JhYmxlID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IHMuRXZlbnRIYW5kbGVycy5rZXlwcmVzc0V2ZW50LmNhbGwociwgcCwgITAsICExLCAhMSwgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAhMSAhPT0gaCAmJiB2b2lkIDAgIT09IGggJiYgKG4gPSBoLmZvcndhcmRQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdS5za2lwT3B0aW9uYWxQYXJ0Q2hhcmFjdGVyID0gZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaChlLCB0LCBhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcywgciA9IHRoaXMubWFza3NldCwgcyA9IHRoaXMuZGVwZW5kZW5jeUxpYjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgZm9yIChlID0gdCAtIDE7IGUgPiAwICYmICFyLnZhbGlkUG9zaXRpb25zW2VdOyBlLS0pIDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IGU7IGwgPCB0OyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHIudmFsaWRQb3NpdGlvbnNbbF0gJiYgIW8uaXNNYXNrLmNhbGwoaSwgbCwgITEpKSBpZiAoMCA9PSBsID8gbi5nZXRUZXN0LmNhbGwoaSwgbCkgOiByLnZhbGlkUG9zaXRpb25zW2wgLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gbi5nZXRUZXN0cy5jYWxsKGksIGwpLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiA9PT0gdVt1Lmxlbmd0aCAtIDFdLm1hdGNoLmRlZiAmJiB1LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjLCBkID0gbi5kZXRlcm1pbmVUZXN0VGVtcGxhdGUuY2FsbChpLCBsLCB1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCAmJiAoITAgIT09IGQubWF0Y2guaml0IHx8IFwibWFzdGVyXCIgPT09IGQubWF0Y2gubmV3QmxvY2tNYXJrZXIgJiYgKGMgPSByLnZhbGlkUG9zaXRpb25zW2wgKyAxXSkgJiYgITAgPT09IGMubWF0Y2gub3B0aW9uYWxRdWFudGlmaWVyKSAmJiAoKGQgPSBzLmV4dGVuZCh7fSwgZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbi5nZXRQbGFjZWhvbGRlci5jYWxsKGksIGwsIGQubWF0Y2gsICEwKSB8fCBkLm1hdGNoLmRlZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5nZW5lcmF0ZWRJbnB1dCA9ICEwLCB2LmNhbGwoaSwgbCwgZCwgITApLCAhMCAhPT0gYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSByLnZhbGlkUG9zaXRpb25zW3RdLmlucHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gci52YWxpZFBvc2l0aW9uc1t0XSA9IHZvaWQgMCwgZi5jYWxsKGksIHQsIHAsICEwLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHYoZSwgdCwgYSwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMsIHMgPSB0aGlzLm1hc2tzZXQsIGwgPSB0aGlzLm9wdHMsIHUgPSB0aGlzLmRlcGVuZGVuY3lMaWI7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGMoZSwgdCwgYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0W2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gaSAmJiAhMCA9PT0gaS5tYXRjaC5zdGF0aWMgJiYgITAgIT09IGkubWF0Y2gub3B0aW9uYWxpdHkgJiYgKHZvaWQgMCA9PT0gdFswXSB8fCB2b2lkIDAgPT09IHRbMF0uYWx0ZXJuYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBhLmJlZ2luIDw9IGUgLSAxID8gdFtlIC0gMV0gJiYgITAgPT09IHRbZSAtIDFdLm1hdGNoLnN0YXRpYyAmJiB0W2UgLSAxXSA6IHRbZSAtIDFdLCByID0gYS5lbmQgPiBlICsgMSA/IHRbZSArIDFdICYmICEwID09PSB0W2UgKyAxXS5tYXRjaC5zdGF0aWMgJiYgdFtlICsgMV0gOiB0W2UgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiAmJiByO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gMCwgaCA9IHZvaWQgMCAhPT0gZS5iZWdpbiA/IGUuYmVnaW4gOiBlLCB2ID0gdm9pZCAwICE9PSBlLmVuZCA/IGUuZW5kIDogZSwgbSA9ICEwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5iZWdpbiA+IGUuZW5kICYmIChoID0gZS5lbmQsIHYgPSBlLmJlZ2luKSwgaSA9IHZvaWQgMCAhPT0gaSA/IGkgOiBoLCBoICE9PSB2IHx8IGwuaW5zZXJ0TW9kZSAmJiB2b2lkIDAgIT09IHMudmFsaWRQb3NpdGlvbnNbaV0gJiYgdm9pZCAwID09PSBhIHx8IHZvaWQgMCA9PT0gdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGcsIGsgPSB1LmV4dGVuZCghMCwge30sIHMudmFsaWRQb3NpdGlvbnMpLCB5ID0gby5nZXRMYXN0VmFsaWRQb3NpdGlvbi5jYWxsKHIsIHZvaWQgMCwgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChzLnAgPSBoLCBnID0geTsgZyA+PSBoOyBnLS0pIGRlbGV0ZSBzLnZhbGlkUG9zaXRpb25zW2ddLCB2b2lkIDAgPT09IHQgJiYgZGVsZXRlIHMudGVzdHNbZyArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIsIHgsIFAgPSBpLCBFID0gUDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodCAmJiAocy52YWxpZFBvc2l0aW9uc1tpXSA9IHUuZXh0ZW5kKCEwLCB7fSwgdCksIEUrKywgUCsrKSwgZyA9IHQgPyB2IDogdiAtIDE7IGcgPD0geTsgZysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gKGIgPSBrW2ddKSAmJiAhMCAhPT0gYi5nZW5lcmF0ZWRJbnB1dCAmJiAoZyA+PSB2IHx8IGcgPj0gaCAmJiBjKGcsIGssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW46IGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDtcIlwiICE9PSBuLmdldFRlc3QuY2FsbChyLCBFKS5tYXRjaC5kZWY7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCExICE9PSAoeCA9IGQuY2FsbChyLCBFLCBiLCBsKSkgfHwgXCIrXCIgPT09IGIubWF0Y2guZGVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIrXCIgPT09IGIubWF0Y2guZGVmICYmIG8uZ2V0QnVmZmVyLmNhbGwociwgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBTID0gZi5jYWxsKHIsIEUsIGIuaW5wdXQsIFwiK1wiICE9PSBiLm1hdGNoLmRlZiwgITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtID0gITEgIT09IFMsIFAgPSAoUy5wb3MgfHwgRSkgKyAxLCAhbSAmJiB4KSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBtID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gdCAmJiBiLm1hdGNoLnN0YXRpYyAmJiBnID09PSBlLmJlZ2luICYmIHArKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbSAmJiBFID4gcy5tYXNrTGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEUrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiID09IG4uZ2V0VGVzdC5jYWxsKHIsIEUpLm1hdGNoLmRlZiAmJiAobSA9ICExKSwgRSA9IFA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW0pIHJldHVybiBzLnZhbGlkUG9zaXRpb25zID0gdS5leHRlbmQoITAsIHt9LCBrKSwgby5yZXNldE1hc2tTZXQuY2FsbChyLCAhMCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgITE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB0ICYmIG4uZ2V0VGVzdC5jYWxsKHIsIGkpLm1hdGNoLmNkID09PSB0Lm1hdGNoLmNkICYmIChzLnZhbGlkUG9zaXRpb25zW2ldID0gdS5leHRlbmQoITAsIHt9LCB0KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvLnJlc2V0TWFza1NldC5jYWxsKHIsICEwKSwgcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHQgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gYShpKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHRbaV07XG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBuKSByZXR1cm4gbi5leHBvcnRzO1xuICAgICAgICAgICAgdmFyIHIgPSB0W2ldID0ge1xuICAgICAgICAgICAgICAgIGV4cG9ydHM6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGVbaV0ociwgci5leHBvcnRzLCBhKSwgci5leHBvcnRzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0ge307XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlLCB0ID0gaTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgfSksIHQuZGVmYXVsdCA9IHZvaWQgMCwgYSgzODUxKSwgYSgyMTkpLCBhKDIwNyksIGEoNTI5Nik7XG4gICAgICAgICAgICB2YXIgbiA9ICgoZSA9IGEoMjM5NCkpICYmIGUuX19lc01vZHVsZSA/IGUgOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogZVxuICAgICAgICAgICAgfSkuZGVmYXVsdDtcbiAgICAgICAgICAgIHQuZGVmYXVsdCA9IG47XG4gICAgICAgIH0oKSwgaTtcbiAgICB9KCk7XG59KSk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/inputmask/dist/inputmask.js\n");

/***/ }),

/***/ "./node_modules/scroll-lock/dist/scroll-lock.js":
/*!******************************************************!*\
  !*** ./node_modules/scroll-lock/dist/scroll-lock.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/tools.js\nvar argumentAsArray = function argumentAsArray(argument) {\n  return Array.isArray(argument) ? argument : [argument];\n};\nvar isElement = function isElement(target) {\n  return target instanceof Node;\n};\nvar isElementList = function isElementList(nodeList) {\n  return nodeList instanceof NodeList;\n};\nvar eachNode = function eachNode(nodeList, callback) {\n  if (nodeList && callback) {\n    nodeList = isElementList(nodeList) ? nodeList : [nodeList];\n\n    for (var i = 0; i < nodeList.length; i++) {\n      if (callback(nodeList[i], i, nodeList.length) === true) {\n        break;\n      }\n    }\n  }\n};\nvar throwError = function throwError(message) {\n  return console.error(\"[scroll-lock] \".concat(message));\n};\nvar arrayAsSelector = function arrayAsSelector(array) {\n  if (Array.isArray(array)) {\n    var selector = array.join(', ');\n    return selector;\n  }\n};\nvar nodeListAsArray = function nodeListAsArray(nodeList) {\n  var nodes = [];\n  eachNode(nodeList, function (node) {\n    return nodes.push(node);\n  });\n  return nodes;\n};\nvar findParentBySelector = function findParentBySelector($el, selector) {\n  var self = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var $root = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : document;\n\n  if (self && nodeListAsArray($root.querySelectorAll(selector)).indexOf($el) !== -1) {\n    return $el;\n  }\n\n  while (($el = $el.parentElement) && nodeListAsArray($root.querySelectorAll(selector)).indexOf($el) === -1) {\n    ;\n  }\n\n  return $el;\n};\nvar elementHasSelector = function elementHasSelector($el, selector) {\n  var $root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;\n  var has = nodeListAsArray($root.querySelectorAll(selector)).indexOf($el) !== -1;\n  return has;\n};\nvar elementHasOverflowHidden = function elementHasOverflowHidden($el) {\n  if ($el) {\n    var computedStyle = getComputedStyle($el);\n    var overflowIsHidden = computedStyle.overflow === 'hidden';\n    return overflowIsHidden;\n  }\n};\nvar elementScrollTopOnStart = function elementScrollTopOnStart($el) {\n  if ($el) {\n    if (elementHasOverflowHidden($el)) {\n      return true;\n    }\n\n    var scrollTop = $el.scrollTop;\n    return scrollTop <= 0;\n  }\n};\nvar elementScrollTopOnEnd = function elementScrollTopOnEnd($el) {\n  if ($el) {\n    if (elementHasOverflowHidden($el)) {\n      return true;\n    }\n\n    var scrollTop = $el.scrollTop;\n    var scrollHeight = $el.scrollHeight;\n    var scrollTopWithHeight = scrollTop + $el.offsetHeight;\n    return scrollTopWithHeight >= scrollHeight;\n  }\n};\nvar elementScrollLeftOnStart = function elementScrollLeftOnStart($el) {\n  if ($el) {\n    if (elementHasOverflowHidden($el)) {\n      return true;\n    }\n\n    var scrollLeft = $el.scrollLeft;\n    return scrollLeft <= 0;\n  }\n};\nvar elementScrollLeftOnEnd = function elementScrollLeftOnEnd($el) {\n  if ($el) {\n    if (elementHasOverflowHidden($el)) {\n      return true;\n    }\n\n    var scrollLeft = $el.scrollLeft;\n    var scrollWidth = $el.scrollWidth;\n    var scrollLeftWithWidth = scrollLeft + $el.offsetWidth;\n    return scrollLeftWithWidth >= scrollWidth;\n  }\n};\nvar elementIsScrollableField = function elementIsScrollableField($el) {\n  var selector = 'textarea, [contenteditable=\"true\"]';\n  return elementHasSelector($el, selector);\n};\nvar elementIsInputRange = function elementIsInputRange($el) {\n  var selector = 'input[type=\"range\"]';\n  return elementHasSelector($el, selector);\n};\n// CONCATENATED MODULE: ./src/scroll-lock.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"disablePageScroll\", function() { return disablePageScroll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enablePageScroll\", function() { return enablePageScroll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getScrollState\", function() { return getScrollState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clearQueueScrollLocks\", function() { return clearQueueScrollLocks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTargetScrollBarWidth\", function() { return scroll_lock_getTargetScrollBarWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCurrentTargetScrollBarWidth\", function() { return scroll_lock_getCurrentTargetScrollBarWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPageScrollBarWidth\", function() { return getPageScrollBarWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCurrentPageScrollBarWidth\", function() { return getCurrentPageScrollBarWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addScrollableTarget\", function() { return scroll_lock_addScrollableTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeScrollableTarget\", function() { return scroll_lock_removeScrollableTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addScrollableSelector\", function() { return scroll_lock_addScrollableSelector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeScrollableSelector\", function() { return scroll_lock_removeScrollableSelector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addLockableTarget\", function() { return scroll_lock_addLockableTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addLockableSelector\", function() { return scroll_lock_addLockableSelector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setFillGapMethod\", function() { return scroll_lock_setFillGapMethod; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addFillGapTarget\", function() { return scroll_lock_addFillGapTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeFillGapTarget\", function() { return scroll_lock_removeFillGapTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addFillGapSelector\", function() { return scroll_lock_addFillGapSelector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeFillGapSelector\", function() { return scroll_lock_removeFillGapSelector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"refillGaps\", function() { return refillGaps; });\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\nvar FILL_GAP_AVAILABLE_METHODS = ['padding', 'margin', 'width', 'max-width', 'none'];\nvar TOUCH_DIRECTION_DETECT_OFFSET = 3;\nvar state = {\n  scroll: true,\n  queue: 0,\n  scrollableSelectors: ['[data-scroll-lock-scrollable]'],\n  lockableSelectors: ['body', '[data-scroll-lock-lockable]'],\n  fillGapSelectors: ['body', '[data-scroll-lock-fill-gap]', '[data-scroll-lock-lockable]'],\n  fillGapMethod: FILL_GAP_AVAILABLE_METHODS[0],\n  //\n  startTouchY: 0,\n  startTouchX: 0\n};\nvar disablePageScroll = function disablePageScroll(target) {\n  if (state.queue <= 0) {\n    state.scroll = false;\n    scroll_lock_hideLockableOverflow();\n    fillGaps();\n  }\n\n  scroll_lock_addScrollableTarget(target);\n  state.queue++;\n};\nvar enablePageScroll = function enablePageScroll(target) {\n  state.queue > 0 && state.queue--;\n\n  if (state.queue <= 0) {\n    state.scroll = true;\n    scroll_lock_showLockableOverflow();\n    unfillGaps();\n  }\n\n  scroll_lock_removeScrollableTarget(target);\n};\nvar getScrollState = function getScrollState() {\n  return state.scroll;\n};\nvar clearQueueScrollLocks = function clearQueueScrollLocks() {\n  state.queue = 0;\n};\nvar scroll_lock_getTargetScrollBarWidth = function getTargetScrollBarWidth($target) {\n  var onlyExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (isElement($target)) {\n    var currentOverflowYProperty = $target.style.overflowY;\n\n    if (onlyExists) {\n      if (!getScrollState()) {\n        $target.style.overflowY = $target.getAttribute('data-scroll-lock-saved-overflow-y-property');\n      }\n    } else {\n      $target.style.overflowY = 'scroll';\n    }\n\n    var width = scroll_lock_getCurrentTargetScrollBarWidth($target);\n    $target.style.overflowY = currentOverflowYProperty;\n    return width;\n  } else {\n    return 0;\n  }\n};\nvar scroll_lock_getCurrentTargetScrollBarWidth = function getCurrentTargetScrollBarWidth($target) {\n  if (isElement($target)) {\n    if ($target === document.body) {\n      var documentWidth = document.documentElement.clientWidth;\n      var windowWidth = window.innerWidth;\n      var currentWidth = windowWidth - documentWidth;\n      return currentWidth;\n    } else {\n      var borderLeftWidthCurrentProperty = $target.style.borderLeftWidth;\n      var borderRightWidthCurrentProperty = $target.style.borderRightWidth;\n      $target.style.borderLeftWidth = '0px';\n      $target.style.borderRightWidth = '0px';\n\n      var _currentWidth = $target.offsetWidth - $target.clientWidth;\n\n      $target.style.borderLeftWidth = borderLeftWidthCurrentProperty;\n      $target.style.borderRightWidth = borderRightWidthCurrentProperty;\n      return _currentWidth;\n    }\n  } else {\n    return 0;\n  }\n};\nvar getPageScrollBarWidth = function getPageScrollBarWidth() {\n  var onlyExists = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return scroll_lock_getTargetScrollBarWidth(document.body, onlyExists);\n};\nvar getCurrentPageScrollBarWidth = function getCurrentPageScrollBarWidth() {\n  return scroll_lock_getCurrentTargetScrollBarWidth(document.body);\n};\nvar scroll_lock_addScrollableTarget = function addScrollableTarget(target) {\n  if (target) {\n    var targets = argumentAsArray(target);\n    targets.map(function ($targets) {\n      eachNode($targets, function ($target) {\n        if (isElement($target)) {\n          $target.setAttribute('data-scroll-lock-scrollable', '');\n        } else {\n          throwError(\"\\\"\".concat($target, \"\\\" is not a Element.\"));\n        }\n      });\n    });\n  }\n};\nvar scroll_lock_removeScrollableTarget = function removeScrollableTarget(target) {\n  if (target) {\n    var targets = argumentAsArray(target);\n    targets.map(function ($targets) {\n      eachNode($targets, function ($target) {\n        if (isElement($target)) {\n          $target.removeAttribute('data-scroll-lock-scrollable');\n        } else {\n          throwError(\"\\\"\".concat($target, \"\\\" is not a Element.\"));\n        }\n      });\n    });\n  }\n};\nvar scroll_lock_addScrollableSelector = function addScrollableSelector(selector) {\n  if (selector) {\n    var selectors = argumentAsArray(selector);\n    selectors.map(function (selector) {\n      state.scrollableSelectors.push(selector);\n    });\n  }\n};\nvar scroll_lock_removeScrollableSelector = function removeScrollableSelector(selector) {\n  if (selector) {\n    var selectors = argumentAsArray(selector);\n    selectors.map(function (selector) {\n      state.scrollableSelectors = state.scrollableSelectors.filter(function (sSelector) {\n        return sSelector !== selector;\n      });\n    });\n  }\n};\nvar scroll_lock_addLockableTarget = function addLockableTarget(target) {\n  if (target) {\n    var targets = argumentAsArray(target);\n    targets.map(function ($targets) {\n      eachNode($targets, function ($target) {\n        if (isElement($target)) {\n          $target.setAttribute('data-scroll-lock-lockable', '');\n        } else {\n          throwError(\"\\\"\".concat($target, \"\\\" is not a Element.\"));\n        }\n      });\n    });\n\n    if (!getScrollState()) {\n      scroll_lock_hideLockableOverflow();\n    }\n  }\n};\nvar scroll_lock_addLockableSelector = function addLockableSelector(selector) {\n  if (selector) {\n    var selectors = argumentAsArray(selector);\n    selectors.map(function (selector) {\n      state.lockableSelectors.push(selector);\n    });\n\n    if (!getScrollState()) {\n      scroll_lock_hideLockableOverflow();\n    }\n\n    scroll_lock_addFillGapSelector(selector);\n  }\n};\nvar scroll_lock_setFillGapMethod = function setFillGapMethod(method) {\n  if (method) {\n    if (FILL_GAP_AVAILABLE_METHODS.indexOf(method) !== -1) {\n      state.fillGapMethod = method;\n      refillGaps();\n    } else {\n      var methods = FILL_GAP_AVAILABLE_METHODS.join(', ');\n      throwError(\"\\\"\".concat(method, \"\\\" method is not available!\\nAvailable fill gap methods: \").concat(methods, \".\"));\n    }\n  }\n};\nvar scroll_lock_addFillGapTarget = function addFillGapTarget(target) {\n  if (target) {\n    var targets = argumentAsArray(target);\n    targets.map(function ($targets) {\n      eachNode($targets, function ($target) {\n        if (isElement($target)) {\n          $target.setAttribute('data-scroll-lock-fill-gap', '');\n\n          if (!state.scroll) {\n            scroll_lock_fillGapTarget($target);\n          }\n        } else {\n          throwError(\"\\\"\".concat($target, \"\\\" is not a Element.\"));\n        }\n      });\n    });\n  }\n};\nvar scroll_lock_removeFillGapTarget = function removeFillGapTarget(target) {\n  if (target) {\n    var targets = argumentAsArray(target);\n    targets.map(function ($targets) {\n      eachNode($targets, function ($target) {\n        if (isElement($target)) {\n          $target.removeAttribute('data-scroll-lock-fill-gap');\n\n          if (!state.scroll) {\n            scroll_lock_unfillGapTarget($target);\n          }\n        } else {\n          throwError(\"\\\"\".concat($target, \"\\\" is not a Element.\"));\n        }\n      });\n    });\n  }\n};\nvar scroll_lock_addFillGapSelector = function addFillGapSelector(selector) {\n  if (selector) {\n    var selectors = argumentAsArray(selector);\n    selectors.map(function (selector) {\n      if (state.fillGapSelectors.indexOf(selector) === -1) {\n        state.fillGapSelectors.push(selector);\n\n        if (!state.scroll) {\n          scroll_lock_fillGapSelector(selector);\n        }\n      }\n    });\n  }\n};\nvar scroll_lock_removeFillGapSelector = function removeFillGapSelector(selector) {\n  if (selector) {\n    var selectors = argumentAsArray(selector);\n    selectors.map(function (selector) {\n      state.fillGapSelectors = state.fillGapSelectors.filter(function (fSelector) {\n        return fSelector !== selector;\n      });\n\n      if (!state.scroll) {\n        scroll_lock_unfillGapSelector(selector);\n      }\n    });\n  }\n};\nvar refillGaps = function refillGaps() {\n  if (!state.scroll) {\n    fillGaps();\n  }\n};\n\nvar scroll_lock_hideLockableOverflow = function hideLockableOverflow() {\n  var selector = arrayAsSelector(state.lockableSelectors);\n  scroll_lock_hideLockableOverflowSelector(selector);\n};\n\nvar scroll_lock_showLockableOverflow = function showLockableOverflow() {\n  var selector = arrayAsSelector(state.lockableSelectors);\n  scroll_lock_showLockableOverflowSelector(selector);\n};\n\nvar scroll_lock_hideLockableOverflowSelector = function hideLockableOverflowSelector(selector) {\n  var $targets = document.querySelectorAll(selector);\n  eachNode($targets, function ($target) {\n    scroll_lock_hideLockableOverflowTarget($target);\n  });\n};\n\nvar scroll_lock_showLockableOverflowSelector = function showLockableOverflowSelector(selector) {\n  var $targets = document.querySelectorAll(selector);\n  eachNode($targets, function ($target) {\n    scroll_lock_showLockableOverflowTarget($target);\n  });\n};\n\nvar scroll_lock_hideLockableOverflowTarget = function hideLockableOverflowTarget($target) {\n  if (isElement($target) && $target.getAttribute('data-scroll-lock-locked') !== 'true') {\n    var computedStyle = window.getComputedStyle($target);\n    $target.setAttribute('data-scroll-lock-saved-overflow-y-property', computedStyle.overflowY);\n    $target.setAttribute('data-scroll-lock-saved-inline-overflow-property', $target.style.overflow);\n    $target.setAttribute('data-scroll-lock-saved-inline-overflow-y-property', $target.style.overflowY);\n    $target.style.overflow = 'hidden';\n    $target.setAttribute('data-scroll-lock-locked', 'true');\n  }\n};\n\nvar scroll_lock_showLockableOverflowTarget = function showLockableOverflowTarget($target) {\n  if (isElement($target) && $target.getAttribute('data-scroll-lock-locked') === 'true') {\n    $target.style.overflow = $target.getAttribute('data-scroll-lock-saved-inline-overflow-property');\n    $target.style.overflowY = $target.getAttribute('data-scroll-lock-saved-inline-overflow-y-property');\n    $target.removeAttribute('data-scroll-lock-saved-overflow-property');\n    $target.removeAttribute('data-scroll-lock-saved-inline-overflow-property');\n    $target.removeAttribute('data-scroll-lock-saved-inline-overflow-y-property');\n    $target.removeAttribute('data-scroll-lock-locked');\n  }\n};\n\nvar fillGaps = function fillGaps() {\n  state.fillGapSelectors.map(function (selector) {\n    scroll_lock_fillGapSelector(selector);\n  });\n};\n\nvar unfillGaps = function unfillGaps() {\n  state.fillGapSelectors.map(function (selector) {\n    scroll_lock_unfillGapSelector(selector);\n  });\n};\n\nvar scroll_lock_fillGapSelector = function fillGapSelector(selector) {\n  var $targets = document.querySelectorAll(selector);\n  var isLockable = state.lockableSelectors.indexOf(selector) !== -1;\n  eachNode($targets, function ($target) {\n    scroll_lock_fillGapTarget($target, isLockable);\n  });\n};\n\nvar scroll_lock_fillGapTarget = function fillGapTarget($target) {\n  var isLockable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (isElement($target)) {\n    var scrollBarWidth;\n\n    if ($target.getAttribute('data-scroll-lock-lockable') === '' || isLockable) {\n      scrollBarWidth = scroll_lock_getTargetScrollBarWidth($target, true);\n    } else {\n      var $lockableParent = findParentBySelector($target, arrayAsSelector(state.lockableSelectors));\n      scrollBarWidth = scroll_lock_getTargetScrollBarWidth($lockableParent, true);\n    }\n\n    if ($target.getAttribute('data-scroll-lock-filled-gap') === 'true') {\n      scroll_lock_unfillGapTarget($target);\n    }\n\n    var computedStyle = window.getComputedStyle($target);\n    $target.setAttribute('data-scroll-lock-filled-gap', 'true');\n    $target.setAttribute('data-scroll-lock-current-fill-gap-method', state.fillGapMethod);\n\n    if (state.fillGapMethod === 'margin') {\n      var currentMargin = parseFloat(computedStyle.marginRight);\n      $target.style.marginRight = \"\".concat(currentMargin + scrollBarWidth, \"px\");\n    } else if (state.fillGapMethod === 'width') {\n      $target.style.width = \"calc(100% - \".concat(scrollBarWidth, \"px)\");\n    } else if (state.fillGapMethod === 'max-width') {\n      $target.style.maxWidth = \"calc(100% - \".concat(scrollBarWidth, \"px)\");\n    } else if (state.fillGapMethod === 'padding') {\n      var currentPadding = parseFloat(computedStyle.paddingRight);\n      $target.style.paddingRight = \"\".concat(currentPadding + scrollBarWidth, \"px\");\n    }\n  }\n};\n\nvar scroll_lock_unfillGapSelector = function unfillGapSelector(selector) {\n  var $targets = document.querySelectorAll(selector);\n  eachNode($targets, function ($target) {\n    scroll_lock_unfillGapTarget($target);\n  });\n};\n\nvar scroll_lock_unfillGapTarget = function unfillGapTarget($target) {\n  if (isElement($target)) {\n    if ($target.getAttribute('data-scroll-lock-filled-gap') === 'true') {\n      var currentFillGapMethod = $target.getAttribute('data-scroll-lock-current-fill-gap-method');\n      $target.removeAttribute('data-scroll-lock-filled-gap');\n      $target.removeAttribute('data-scroll-lock-current-fill-gap-method');\n\n      if (currentFillGapMethod === 'margin') {\n        $target.style.marginRight = \"\";\n      } else if (currentFillGapMethod === 'width') {\n        $target.style.width = \"\";\n      } else if (currentFillGapMethod === 'max-width') {\n        $target.style.maxWidth = \"\";\n      } else if (currentFillGapMethod === 'padding') {\n        $target.style.paddingRight = \"\";\n      }\n    }\n  }\n};\n\nvar onResize = function onResize(e) {\n  refillGaps();\n};\n\nvar onTouchStart = function onTouchStart(e) {\n  if (!state.scroll) {\n    state.startTouchY = e.touches[0].clientY;\n    state.startTouchX = e.touches[0].clientX;\n  }\n};\n\nvar scroll_lock_onTouchMove = function onTouchMove(e) {\n  if (!state.scroll) {\n    var startTouchY = state.startTouchY,\n        startTouchX = state.startTouchX;\n    var currentClientY = e.touches[0].clientY;\n    var currentClientX = e.touches[0].clientX;\n\n    if (e.touches.length < 2) {\n      var selector = arrayAsSelector(state.scrollableSelectors);\n      var direction = {\n        up: startTouchY < currentClientY,\n        down: startTouchY > currentClientY,\n        left: startTouchX < currentClientX,\n        right: startTouchX > currentClientX\n      };\n      var directionWithOffset = {\n        up: startTouchY + TOUCH_DIRECTION_DETECT_OFFSET < currentClientY,\n        down: startTouchY - TOUCH_DIRECTION_DETECT_OFFSET > currentClientY,\n        left: startTouchX + TOUCH_DIRECTION_DETECT_OFFSET < currentClientX,\n        right: startTouchX - TOUCH_DIRECTION_DETECT_OFFSET > currentClientX\n      };\n\n      var handle = function handle($el) {\n        var skip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if ($el) {\n          var parentScrollableEl = findParentBySelector($el, selector, false);\n\n          if (elementIsInputRange($el)) {\n            return false;\n          }\n\n          if (skip || elementIsScrollableField($el) && findParentBySelector($el, selector) || elementHasSelector($el, selector)) {\n            var prevent = false;\n\n            if (elementScrollLeftOnStart($el) && elementScrollLeftOnEnd($el)) {\n              if (direction.up && elementScrollTopOnStart($el) || direction.down && elementScrollTopOnEnd($el)) {\n                prevent = true;\n              }\n            } else if (elementScrollTopOnStart($el) && elementScrollTopOnEnd($el)) {\n              if (direction.left && elementScrollLeftOnStart($el) || direction.right && elementScrollLeftOnEnd($el)) {\n                prevent = true;\n              }\n            } else if (directionWithOffset.up && elementScrollTopOnStart($el) || directionWithOffset.down && elementScrollTopOnEnd($el) || directionWithOffset.left && elementScrollLeftOnStart($el) || directionWithOffset.right && elementScrollLeftOnEnd($el)) {\n              prevent = true;\n            }\n\n            if (prevent) {\n              if (parentScrollableEl) {\n                handle(parentScrollableEl, true);\n              } else {\n                if (e.cancelable) {\n                  e.preventDefault();\n                }\n              }\n            }\n          } else {\n            handle(parentScrollableEl);\n          }\n        } else {\n          if (e.cancelable) {\n            e.preventDefault();\n          }\n        }\n      };\n\n      handle(e.target);\n    }\n  }\n};\n\nvar onTouchEnd = function onTouchEnd(e) {\n  if (!state.scroll) {\n    state.startTouchY = 0;\n    state.startTouchX = 0;\n  }\n};\n\nif (typeof window !== 'undefined') {\n  window.addEventListener('resize', onResize);\n}\n\nif (typeof document !== 'undefined') {\n  document.addEventListener('touchstart', onTouchStart);\n  document.addEventListener('touchmove', scroll_lock_onTouchMove, {\n    passive: false\n  });\n  document.addEventListener('touchend', onTouchEnd);\n}\n\nvar deprecatedMethods = {\n  hide: function hide(target) {\n    throwError('\"hide\" is deprecated! Use \"disablePageScroll\" instead. \\n https://github.com/FL3NKEY/scroll-lock#disablepagescrollscrollabletarget');\n    disablePageScroll(target);\n  },\n  show: function show(target) {\n    throwError('\"show\" is deprecated! Use \"enablePageScroll\" instead. \\n https://github.com/FL3NKEY/scroll-lock#enablepagescrollscrollabletarget');\n    enablePageScroll(target);\n  },\n  toggle: function toggle(target) {\n    throwError('\"toggle\" is deprecated! Do not use it.');\n\n    if (getScrollState()) {\n      disablePageScroll();\n    } else {\n      enablePageScroll(target);\n    }\n  },\n  getState: function getState() {\n    throwError('\"getState\" is deprecated! Use \"getScrollState\" instead. \\n https://github.com/FL3NKEY/scroll-lock#getscrollstate');\n    return getScrollState();\n  },\n  getWidth: function getWidth() {\n    throwError('\"getWidth\" is deprecated! Use \"getPageScrollBarWidth\" instead. \\n https://github.com/FL3NKEY/scroll-lock#getpagescrollbarwidth');\n    return getPageScrollBarWidth();\n  },\n  getCurrentWidth: function getCurrentWidth() {\n    throwError('\"getCurrentWidth\" is deprecated! Use \"getCurrentPageScrollBarWidth\" instead. \\n https://github.com/FL3NKEY/scroll-lock#getcurrentpagescrollbarwidth');\n    return getCurrentPageScrollBarWidth();\n  },\n  setScrollableTargets: function setScrollableTargets(target) {\n    throwError('\"setScrollableTargets\" is deprecated! Use \"addScrollableTarget\" instead. \\n https://github.com/FL3NKEY/scroll-lock#addscrollabletargetscrollabletarget');\n    scroll_lock_addScrollableTarget(target);\n  },\n  setFillGapSelectors: function setFillGapSelectors(selector) {\n    throwError('\"setFillGapSelectors\" is deprecated! Use \"addFillGapSelector\" instead. \\n https://github.com/FL3NKEY/scroll-lock#addfillgapselectorfillgapselector');\n    scroll_lock_addFillGapSelector(selector);\n  },\n  setFillGapTargets: function setFillGapTargets(target) {\n    throwError('\"setFillGapTargets\" is deprecated! Use \"addFillGapTarget\" instead. \\n https://github.com/FL3NKEY/scroll-lock#addfillgaptargetfillgaptarget');\n    scroll_lock_addFillGapTarget(target);\n  },\n  clearQueue: function clearQueue() {\n    throwError('\"clearQueue\" is deprecated! Use \"clearQueueScrollLocks\" instead. \\n https://github.com/FL3NKEY/scroll-lock#clearqueuescrolllocks');\n    clearQueueScrollLocks();\n  }\n};\n\nvar scrollLock = _objectSpread({\n  disablePageScroll: disablePageScroll,\n  enablePageScroll: enablePageScroll,\n  getScrollState: getScrollState,\n  clearQueueScrollLocks: clearQueueScrollLocks,\n  getTargetScrollBarWidth: scroll_lock_getTargetScrollBarWidth,\n  getCurrentTargetScrollBarWidth: scroll_lock_getCurrentTargetScrollBarWidth,\n  getPageScrollBarWidth: getPageScrollBarWidth,\n  getCurrentPageScrollBarWidth: getCurrentPageScrollBarWidth,\n  addScrollableSelector: scroll_lock_addScrollableSelector,\n  removeScrollableSelector: scroll_lock_removeScrollableSelector,\n  addScrollableTarget: scroll_lock_addScrollableTarget,\n  removeScrollableTarget: scroll_lock_removeScrollableTarget,\n  addLockableSelector: scroll_lock_addLockableSelector,\n  addLockableTarget: scroll_lock_addLockableTarget,\n  addFillGapSelector: scroll_lock_addFillGapSelector,\n  removeFillGapSelector: scroll_lock_removeFillGapSelector,\n  addFillGapTarget: scroll_lock_addFillGapTarget,\n  removeFillGapTarget: scroll_lock_removeFillGapTarget,\n  setFillGapMethod: scroll_lock_setFillGapMethod,\n  refillGaps: refillGaps,\n  _state: state\n}, deprecatedMethods);\n\n/* harmony default export */ var scroll_lock = __webpack_exports__[\"default\"] = (scrollLock);\n\n/***/ })\n/******/ ])[\"default\"];\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2Nyb2xsLWxvY2svZGlzdC9zY3JvbGwtbG9jay5qcz8zMjUxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLMkI7QUFDakMsQ0FBQztBQUNELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQ0FBZ0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRix3SEFBd0gsbUJBQW1CLEVBQUU7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0RBQStEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRywwQkFBMEIsRUFBRTtBQUN2SSwwR0FBMEcseUJBQXlCLEVBQUU7QUFDckksd0dBQXdHLHVCQUF1QixFQUFFO0FBQ2pJLCtHQUErRyw4QkFBOEIsRUFBRTtBQUMvSSxpSEFBaUgsNENBQTRDLEVBQUU7QUFDL0osd0hBQXdILG1EQUFtRCxFQUFFO0FBQzdLLCtHQUErRyw4QkFBOEIsRUFBRTtBQUMvSSxzSEFBc0gscUNBQXFDLEVBQUU7QUFDN0osNkdBQTZHLHdDQUF3QyxFQUFFO0FBQ3ZKLGdIQUFnSCwyQ0FBMkMsRUFBRTtBQUM3SiwrR0FBK0csMENBQTBDLEVBQUU7QUFDM0osa0hBQWtILDZDQUE2QyxFQUFFO0FBQ2pLLDJHQUEyRyxzQ0FBc0MsRUFBRTtBQUNuSiw2R0FBNkcsd0NBQXdDLEVBQUU7QUFDdkosMEdBQTBHLHFDQUFxQyxFQUFFO0FBQ2pKLDBHQUEwRyxxQ0FBcUMsRUFBRTtBQUNqSiw2R0FBNkcsd0NBQXdDLEVBQUU7QUFDdkosNEdBQTRHLHVDQUF1QyxFQUFFO0FBQ3JKLCtHQUErRywwQ0FBMEMsRUFBRTtBQUMzSixvR0FBb0csbUJBQW1CLEVBQUU7QUFDekgsZ0NBQWdDLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsbUNBQW1DLDBEQUEwRCxzRkFBc0YsZ0VBQWdFLEVBQUUsR0FBRyxFQUFFLGlDQUFpQywyQ0FBMkMsRUFBRSxFQUFFLEVBQUUsZUFBZTs7QUFFL2QsMkNBQTJDLGtCQUFrQixrQ0FBa0MscUVBQXFFLEVBQUUsRUFBRSxPQUFPLGtCQUFrQixFQUFFLFlBQVk7OztBQUcvTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zY3JvbGwtbG9jay9kaXN0L3Njcm9sbC1sb2NrLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wic2Nyb2xsTG9ja1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJzY3JvbGxMb2NrXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3Rvb2xzLmpzXG52YXIgYXJndW1lbnRBc0FycmF5ID0gZnVuY3Rpb24gYXJndW1lbnRBc0FycmF5KGFyZ3VtZW50KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyZ3VtZW50KSA/IGFyZ3VtZW50IDogW2FyZ3VtZW50XTtcbn07XG52YXIgaXNFbGVtZW50ID0gZnVuY3Rpb24gaXNFbGVtZW50KHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgTm9kZTtcbn07XG52YXIgaXNFbGVtZW50TGlzdCA9IGZ1bmN0aW9uIGlzRWxlbWVudExpc3Qobm9kZUxpc3QpIHtcbiAgcmV0dXJuIG5vZGVMaXN0IGluc3RhbmNlb2YgTm9kZUxpc3Q7XG59O1xudmFyIGVhY2hOb2RlID0gZnVuY3Rpb24gZWFjaE5vZGUobm9kZUxpc3QsIGNhbGxiYWNrKSB7XG4gIGlmIChub2RlTGlzdCAmJiBjYWxsYmFjaykge1xuICAgIG5vZGVMaXN0ID0gaXNFbGVtZW50TGlzdChub2RlTGlzdCkgPyBub2RlTGlzdCA6IFtub2RlTGlzdF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY2FsbGJhY2sobm9kZUxpc3RbaV0sIGksIG5vZGVMaXN0Lmxlbmd0aCkgPT09IHRydWUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIHRocm93RXJyb3IgPSBmdW5jdGlvbiB0aHJvd0Vycm9yKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJbc2Nyb2xsLWxvY2tdIFwiLmNvbmNhdChtZXNzYWdlKSk7XG59O1xudmFyIGFycmF5QXNTZWxlY3RvciA9IGZ1bmN0aW9uIGFycmF5QXNTZWxlY3RvcihhcnJheSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSBhcnJheS5qb2luKCcsICcpO1xuICAgIHJldHVybiBzZWxlY3RvcjtcbiAgfVxufTtcbnZhciBub2RlTGlzdEFzQXJyYXkgPSBmdW5jdGlvbiBub2RlTGlzdEFzQXJyYXkobm9kZUxpc3QpIHtcbiAgdmFyIG5vZGVzID0gW107XG4gIGVhY2hOb2RlKG5vZGVMaXN0LCBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2Rlcy5wdXNoKG5vZGUpO1xuICB9KTtcbiAgcmV0dXJuIG5vZGVzO1xufTtcbnZhciBmaW5kUGFyZW50QnlTZWxlY3RvciA9IGZ1bmN0aW9uIGZpbmRQYXJlbnRCeVNlbGVjdG9yKCRlbCwgc2VsZWN0b3IpIHtcbiAgdmFyIHNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gIHZhciAkcm9vdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZG9jdW1lbnQ7XG5cbiAgaWYgKHNlbGYgJiYgbm9kZUxpc3RBc0FycmF5KCRyb290LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKS5pbmRleE9mKCRlbCkgIT09IC0xKSB7XG4gICAgcmV0dXJuICRlbDtcbiAgfVxuXG4gIHdoaWxlICgoJGVsID0gJGVsLnBhcmVudEVsZW1lbnQpICYmIG5vZGVMaXN0QXNBcnJheSgkcm9vdC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkuaW5kZXhPZigkZWwpID09PSAtMSkge1xuICAgIDtcbiAgfVxuXG4gIHJldHVybiAkZWw7XG59O1xudmFyIGVsZW1lbnRIYXNTZWxlY3RvciA9IGZ1bmN0aW9uIGVsZW1lbnRIYXNTZWxlY3RvcigkZWwsIHNlbGVjdG9yKSB7XG4gIHZhciAkcm9vdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZG9jdW1lbnQ7XG4gIHZhciBoYXMgPSBub2RlTGlzdEFzQXJyYXkoJHJvb3QucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpLmluZGV4T2YoJGVsKSAhPT0gLTE7XG4gIHJldHVybiBoYXM7XG59O1xudmFyIGVsZW1lbnRIYXNPdmVyZmxvd0hpZGRlbiA9IGZ1bmN0aW9uIGVsZW1lbnRIYXNPdmVyZmxvd0hpZGRlbigkZWwpIHtcbiAgaWYgKCRlbCkge1xuICAgIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSgkZWwpO1xuICAgIHZhciBvdmVyZmxvd0lzSGlkZGVuID0gY29tcHV0ZWRTdHlsZS5vdmVyZmxvdyA9PT0gJ2hpZGRlbic7XG4gICAgcmV0dXJuIG92ZXJmbG93SXNIaWRkZW47XG4gIH1cbn07XG52YXIgZWxlbWVudFNjcm9sbFRvcE9uU3RhcnQgPSBmdW5jdGlvbiBlbGVtZW50U2Nyb2xsVG9wT25TdGFydCgkZWwpIHtcbiAgaWYgKCRlbCkge1xuICAgIGlmIChlbGVtZW50SGFzT3ZlcmZsb3dIaWRkZW4oJGVsKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHNjcm9sbFRvcCA9ICRlbC5zY3JvbGxUb3A7XG4gICAgcmV0dXJuIHNjcm9sbFRvcCA8PSAwO1xuICB9XG59O1xudmFyIGVsZW1lbnRTY3JvbGxUb3BPbkVuZCA9IGZ1bmN0aW9uIGVsZW1lbnRTY3JvbGxUb3BPbkVuZCgkZWwpIHtcbiAgaWYgKCRlbCkge1xuICAgIGlmIChlbGVtZW50SGFzT3ZlcmZsb3dIaWRkZW4oJGVsKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHNjcm9sbFRvcCA9ICRlbC5zY3JvbGxUb3A7XG4gICAgdmFyIHNjcm9sbEhlaWdodCA9ICRlbC5zY3JvbGxIZWlnaHQ7XG4gICAgdmFyIHNjcm9sbFRvcFdpdGhIZWlnaHQgPSBzY3JvbGxUb3AgKyAkZWwub2Zmc2V0SGVpZ2h0O1xuICAgIHJldHVybiBzY3JvbGxUb3BXaXRoSGVpZ2h0ID49IHNjcm9sbEhlaWdodDtcbiAgfVxufTtcbnZhciBlbGVtZW50U2Nyb2xsTGVmdE9uU3RhcnQgPSBmdW5jdGlvbiBlbGVtZW50U2Nyb2xsTGVmdE9uU3RhcnQoJGVsKSB7XG4gIGlmICgkZWwpIHtcbiAgICBpZiAoZWxlbWVudEhhc092ZXJmbG93SGlkZGVuKCRlbCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzY3JvbGxMZWZ0ID0gJGVsLnNjcm9sbExlZnQ7XG4gICAgcmV0dXJuIHNjcm9sbExlZnQgPD0gMDtcbiAgfVxufTtcbnZhciBlbGVtZW50U2Nyb2xsTGVmdE9uRW5kID0gZnVuY3Rpb24gZWxlbWVudFNjcm9sbExlZnRPbkVuZCgkZWwpIHtcbiAgaWYgKCRlbCkge1xuICAgIGlmIChlbGVtZW50SGFzT3ZlcmZsb3dIaWRkZW4oJGVsKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHNjcm9sbExlZnQgPSAkZWwuc2Nyb2xsTGVmdDtcbiAgICB2YXIgc2Nyb2xsV2lkdGggPSAkZWwuc2Nyb2xsV2lkdGg7XG4gICAgdmFyIHNjcm9sbExlZnRXaXRoV2lkdGggPSBzY3JvbGxMZWZ0ICsgJGVsLm9mZnNldFdpZHRoO1xuICAgIHJldHVybiBzY3JvbGxMZWZ0V2l0aFdpZHRoID49IHNjcm9sbFdpZHRoO1xuICB9XG59O1xudmFyIGVsZW1lbnRJc1Njcm9sbGFibGVGaWVsZCA9IGZ1bmN0aW9uIGVsZW1lbnRJc1Njcm9sbGFibGVGaWVsZCgkZWwpIHtcbiAgdmFyIHNlbGVjdG9yID0gJ3RleHRhcmVhLCBbY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiXSc7XG4gIHJldHVybiBlbGVtZW50SGFzU2VsZWN0b3IoJGVsLCBzZWxlY3Rvcik7XG59O1xudmFyIGVsZW1lbnRJc0lucHV0UmFuZ2UgPSBmdW5jdGlvbiBlbGVtZW50SXNJbnB1dFJhbmdlKCRlbCkge1xuICB2YXIgc2VsZWN0b3IgPSAnaW5wdXRbdHlwZT1cInJhbmdlXCJdJztcbiAgcmV0dXJuIGVsZW1lbnRIYXNTZWxlY3RvcigkZWwsIHNlbGVjdG9yKTtcbn07XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zY3JvbGwtbG9jay5qc1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRpc2FibGVQYWdlU2Nyb2xsXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGlzYWJsZVBhZ2VTY3JvbGw7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVuYWJsZVBhZ2VTY3JvbGxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBlbmFibGVQYWdlU2Nyb2xsOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRTY3JvbGxTdGF0ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFNjcm9sbFN0YXRlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjbGVhclF1ZXVlU2Nyb2xsTG9ja3NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjbGVhclF1ZXVlU2Nyb2xsTG9ja3M7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldFRhcmdldFNjcm9sbEJhcldpZHRoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2Nyb2xsX2xvY2tfZ2V0VGFyZ2V0U2Nyb2xsQmFyV2lkdGg7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldEN1cnJlbnRUYXJnZXRTY3JvbGxCYXJXaWR0aFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNjcm9sbF9sb2NrX2dldEN1cnJlbnRUYXJnZXRTY3JvbGxCYXJXaWR0aDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0UGFnZVNjcm9sbEJhcldpZHRoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0UGFnZVNjcm9sbEJhcldpZHRoOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRDdXJyZW50UGFnZVNjcm9sbEJhcldpZHRoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0Q3VycmVudFBhZ2VTY3JvbGxCYXJXaWR0aDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWRkU2Nyb2xsYWJsZVRhcmdldFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNjcm9sbF9sb2NrX2FkZFNjcm9sbGFibGVUYXJnZXQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInJlbW92ZVNjcm9sbGFibGVUYXJnZXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzY3JvbGxfbG9ja19yZW1vdmVTY3JvbGxhYmxlVGFyZ2V0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhZGRTY3JvbGxhYmxlU2VsZWN0b3JcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzY3JvbGxfbG9ja19hZGRTY3JvbGxhYmxlU2VsZWN0b3I7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInJlbW92ZVNjcm9sbGFibGVTZWxlY3RvclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNjcm9sbF9sb2NrX3JlbW92ZVNjcm9sbGFibGVTZWxlY3RvcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWRkTG9ja2FibGVUYXJnZXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzY3JvbGxfbG9ja19hZGRMb2NrYWJsZVRhcmdldDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWRkTG9ja2FibGVTZWxlY3RvclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNjcm9sbF9sb2NrX2FkZExvY2thYmxlU2VsZWN0b3I7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNldEZpbGxHYXBNZXRob2RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzY3JvbGxfbG9ja19zZXRGaWxsR2FwTWV0aG9kOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhZGRGaWxsR2FwVGFyZ2V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2Nyb2xsX2xvY2tfYWRkRmlsbEdhcFRhcmdldDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicmVtb3ZlRmlsbEdhcFRhcmdldFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNjcm9sbF9sb2NrX3JlbW92ZUZpbGxHYXBUYXJnZXQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFkZEZpbGxHYXBTZWxlY3RvclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNjcm9sbF9sb2NrX2FkZEZpbGxHYXBTZWxlY3RvcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicmVtb3ZlRmlsbEdhcFNlbGVjdG9yXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2Nyb2xsX2xvY2tfcmVtb3ZlRmlsbEdhcFNlbGVjdG9yOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJyZWZpbGxHYXBzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVmaWxsR2FwczsgfSk7XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTsgfSkpOyB9IG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cblxudmFyIEZJTExfR0FQX0FWQUlMQUJMRV9NRVRIT0RTID0gWydwYWRkaW5nJywgJ21hcmdpbicsICd3aWR0aCcsICdtYXgtd2lkdGgnLCAnbm9uZSddO1xudmFyIFRPVUNIX0RJUkVDVElPTl9ERVRFQ1RfT0ZGU0VUID0gMztcbnZhciBzdGF0ZSA9IHtcbiAgc2Nyb2xsOiB0cnVlLFxuICBxdWV1ZTogMCxcbiAgc2Nyb2xsYWJsZVNlbGVjdG9yczogWydbZGF0YS1zY3JvbGwtbG9jay1zY3JvbGxhYmxlXSddLFxuICBsb2NrYWJsZVNlbGVjdG9yczogWydib2R5JywgJ1tkYXRhLXNjcm9sbC1sb2NrLWxvY2thYmxlXSddLFxuICBmaWxsR2FwU2VsZWN0b3JzOiBbJ2JvZHknLCAnW2RhdGEtc2Nyb2xsLWxvY2stZmlsbC1nYXBdJywgJ1tkYXRhLXNjcm9sbC1sb2NrLWxvY2thYmxlXSddLFxuICBmaWxsR2FwTWV0aG9kOiBGSUxMX0dBUF9BVkFJTEFCTEVfTUVUSE9EU1swXSxcbiAgLy9cbiAgc3RhcnRUb3VjaFk6IDAsXG4gIHN0YXJ0VG91Y2hYOiAwXG59O1xudmFyIGRpc2FibGVQYWdlU2Nyb2xsID0gZnVuY3Rpb24gZGlzYWJsZVBhZ2VTY3JvbGwodGFyZ2V0KSB7XG4gIGlmIChzdGF0ZS5xdWV1ZSA8PSAwKSB7XG4gICAgc3RhdGUuc2Nyb2xsID0gZmFsc2U7XG4gICAgc2Nyb2xsX2xvY2tfaGlkZUxvY2thYmxlT3ZlcmZsb3coKTtcbiAgICBmaWxsR2FwcygpO1xuICB9XG5cbiAgc2Nyb2xsX2xvY2tfYWRkU2Nyb2xsYWJsZVRhcmdldCh0YXJnZXQpO1xuICBzdGF0ZS5xdWV1ZSsrO1xufTtcbnZhciBlbmFibGVQYWdlU2Nyb2xsID0gZnVuY3Rpb24gZW5hYmxlUGFnZVNjcm9sbCh0YXJnZXQpIHtcbiAgc3RhdGUucXVldWUgPiAwICYmIHN0YXRlLnF1ZXVlLS07XG5cbiAgaWYgKHN0YXRlLnF1ZXVlIDw9IDApIHtcbiAgICBzdGF0ZS5zY3JvbGwgPSB0cnVlO1xuICAgIHNjcm9sbF9sb2NrX3Nob3dMb2NrYWJsZU92ZXJmbG93KCk7XG4gICAgdW5maWxsR2FwcygpO1xuICB9XG5cbiAgc2Nyb2xsX2xvY2tfcmVtb3ZlU2Nyb2xsYWJsZVRhcmdldCh0YXJnZXQpO1xufTtcbnZhciBnZXRTY3JvbGxTdGF0ZSA9IGZ1bmN0aW9uIGdldFNjcm9sbFN0YXRlKCkge1xuICByZXR1cm4gc3RhdGUuc2Nyb2xsO1xufTtcbnZhciBjbGVhclF1ZXVlU2Nyb2xsTG9ja3MgPSBmdW5jdGlvbiBjbGVhclF1ZXVlU2Nyb2xsTG9ja3MoKSB7XG4gIHN0YXRlLnF1ZXVlID0gMDtcbn07XG52YXIgc2Nyb2xsX2xvY2tfZ2V0VGFyZ2V0U2Nyb2xsQmFyV2lkdGggPSBmdW5jdGlvbiBnZXRUYXJnZXRTY3JvbGxCYXJXaWR0aCgkdGFyZ2V0KSB7XG4gIHZhciBvbmx5RXhpc3RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICBpZiAoaXNFbGVtZW50KCR0YXJnZXQpKSB7XG4gICAgdmFyIGN1cnJlbnRPdmVyZmxvd1lQcm9wZXJ0eSA9ICR0YXJnZXQuc3R5bGUub3ZlcmZsb3dZO1xuXG4gICAgaWYgKG9ubHlFeGlzdHMpIHtcbiAgICAgIGlmICghZ2V0U2Nyb2xsU3RhdGUoKSkge1xuICAgICAgICAkdGFyZ2V0LnN0eWxlLm92ZXJmbG93WSA9ICR0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXNjcm9sbC1sb2NrLXNhdmVkLW92ZXJmbG93LXktcHJvcGVydHknKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgJHRhcmdldC5zdHlsZS5vdmVyZmxvd1kgPSAnc2Nyb2xsJztcbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSBzY3JvbGxfbG9ja19nZXRDdXJyZW50VGFyZ2V0U2Nyb2xsQmFyV2lkdGgoJHRhcmdldCk7XG4gICAgJHRhcmdldC5zdHlsZS5vdmVyZmxvd1kgPSBjdXJyZW50T3ZlcmZsb3dZUHJvcGVydHk7XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xudmFyIHNjcm9sbF9sb2NrX2dldEN1cnJlbnRUYXJnZXRTY3JvbGxCYXJXaWR0aCA9IGZ1bmN0aW9uIGdldEN1cnJlbnRUYXJnZXRTY3JvbGxCYXJXaWR0aCgkdGFyZ2V0KSB7XG4gIGlmIChpc0VsZW1lbnQoJHRhcmdldCkpIHtcbiAgICBpZiAoJHRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgdmFyIGRvY3VtZW50V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICB2YXIgd2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIHZhciBjdXJyZW50V2lkdGggPSB3aW5kb3dXaWR0aCAtIGRvY3VtZW50V2lkdGg7XG4gICAgICByZXR1cm4gY3VycmVudFdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYm9yZGVyTGVmdFdpZHRoQ3VycmVudFByb3BlcnR5ID0gJHRhcmdldC5zdHlsZS5ib3JkZXJMZWZ0V2lkdGg7XG4gICAgICB2YXIgYm9yZGVyUmlnaHRXaWR0aEN1cnJlbnRQcm9wZXJ0eSA9ICR0YXJnZXQuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aDtcbiAgICAgICR0YXJnZXQuc3R5bGUuYm9yZGVyTGVmdFdpZHRoID0gJzBweCc7XG4gICAgICAkdGFyZ2V0LnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSAnMHB4JztcblxuICAgICAgdmFyIF9jdXJyZW50V2lkdGggPSAkdGFyZ2V0Lm9mZnNldFdpZHRoIC0gJHRhcmdldC5jbGllbnRXaWR0aDtcblxuICAgICAgJHRhcmdldC5zdHlsZS5ib3JkZXJMZWZ0V2lkdGggPSBib3JkZXJMZWZ0V2lkdGhDdXJyZW50UHJvcGVydHk7XG4gICAgICAkdGFyZ2V0LnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSBib3JkZXJSaWdodFdpZHRoQ3VycmVudFByb3BlcnR5O1xuICAgICAgcmV0dXJuIF9jdXJyZW50V2lkdGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xudmFyIGdldFBhZ2VTY3JvbGxCYXJXaWR0aCA9IGZ1bmN0aW9uIGdldFBhZ2VTY3JvbGxCYXJXaWR0aCgpIHtcbiAgdmFyIG9ubHlFeGlzdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICByZXR1cm4gc2Nyb2xsX2xvY2tfZ2V0VGFyZ2V0U2Nyb2xsQmFyV2lkdGgoZG9jdW1lbnQuYm9keSwgb25seUV4aXN0cyk7XG59O1xudmFyIGdldEN1cnJlbnRQYWdlU2Nyb2xsQmFyV2lkdGggPSBmdW5jdGlvbiBnZXRDdXJyZW50UGFnZVNjcm9sbEJhcldpZHRoKCkge1xuICByZXR1cm4gc2Nyb2xsX2xvY2tfZ2V0Q3VycmVudFRhcmdldFNjcm9sbEJhcldpZHRoKGRvY3VtZW50LmJvZHkpO1xufTtcbnZhciBzY3JvbGxfbG9ja19hZGRTY3JvbGxhYmxlVGFyZ2V0ID0gZnVuY3Rpb24gYWRkU2Nyb2xsYWJsZVRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHRhcmdldCkge1xuICAgIHZhciB0YXJnZXRzID0gYXJndW1lbnRBc0FycmF5KHRhcmdldCk7XG4gICAgdGFyZ2V0cy5tYXAoZnVuY3Rpb24gKCR0YXJnZXRzKSB7XG4gICAgICBlYWNoTm9kZSgkdGFyZ2V0cywgZnVuY3Rpb24gKCR0YXJnZXQpIHtcbiAgICAgICAgaWYgKGlzRWxlbWVudCgkdGFyZ2V0KSkge1xuICAgICAgICAgICR0YXJnZXQuc2V0QXR0cmlidXRlKCdkYXRhLXNjcm9sbC1sb2NrLXNjcm9sbGFibGUnLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihcIlxcXCJcIi5jb25jYXQoJHRhcmdldCwgXCJcXFwiIGlzIG5vdCBhIEVsZW1lbnQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgc2Nyb2xsX2xvY2tfcmVtb3ZlU2Nyb2xsYWJsZVRhcmdldCA9IGZ1bmN0aW9uIHJlbW92ZVNjcm9sbGFibGVUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQpIHtcbiAgICB2YXIgdGFyZ2V0cyA9IGFyZ3VtZW50QXNBcnJheSh0YXJnZXQpO1xuICAgIHRhcmdldHMubWFwKGZ1bmN0aW9uICgkdGFyZ2V0cykge1xuICAgICAgZWFjaE5vZGUoJHRhcmdldHMsIGZ1bmN0aW9uICgkdGFyZ2V0KSB7XG4gICAgICAgIGlmIChpc0VsZW1lbnQoJHRhcmdldCkpIHtcbiAgICAgICAgICAkdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1zY3JvbGwtbG9jay1zY3JvbGxhYmxlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihcIlxcXCJcIi5jb25jYXQoJHRhcmdldCwgXCJcXFwiIGlzIG5vdCBhIEVsZW1lbnQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgc2Nyb2xsX2xvY2tfYWRkU2Nyb2xsYWJsZVNlbGVjdG9yID0gZnVuY3Rpb24gYWRkU2Nyb2xsYWJsZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIGlmIChzZWxlY3Rvcikge1xuICAgIHZhciBzZWxlY3RvcnMgPSBhcmd1bWVudEFzQXJyYXkoc2VsZWN0b3IpO1xuICAgIHNlbGVjdG9ycy5tYXAoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICBzdGF0ZS5zY3JvbGxhYmxlU2VsZWN0b3JzLnB1c2goc2VsZWN0b3IpO1xuICAgIH0pO1xuICB9XG59O1xudmFyIHNjcm9sbF9sb2NrX3JlbW92ZVNjcm9sbGFibGVTZWxlY3RvciA9IGZ1bmN0aW9uIHJlbW92ZVNjcm9sbGFibGVTZWxlY3RvcihzZWxlY3Rvcikge1xuICBpZiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgc2VsZWN0b3JzID0gYXJndW1lbnRBc0FycmF5KHNlbGVjdG9yKTtcbiAgICBzZWxlY3RvcnMubWFwKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgc3RhdGUuc2Nyb2xsYWJsZVNlbGVjdG9ycyA9IHN0YXRlLnNjcm9sbGFibGVTZWxlY3RvcnMuZmlsdGVyKGZ1bmN0aW9uIChzU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHNTZWxlY3RvciAhPT0gc2VsZWN0b3I7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBzY3JvbGxfbG9ja19hZGRMb2NrYWJsZVRhcmdldCA9IGZ1bmN0aW9uIGFkZExvY2thYmxlVGFyZ2V0KHRhcmdldCkge1xuICBpZiAodGFyZ2V0KSB7XG4gICAgdmFyIHRhcmdldHMgPSBhcmd1bWVudEFzQXJyYXkodGFyZ2V0KTtcbiAgICB0YXJnZXRzLm1hcChmdW5jdGlvbiAoJHRhcmdldHMpIHtcbiAgICAgIGVhY2hOb2RlKCR0YXJnZXRzLCBmdW5jdGlvbiAoJHRhcmdldCkge1xuICAgICAgICBpZiAoaXNFbGVtZW50KCR0YXJnZXQpKSB7XG4gICAgICAgICAgJHRhcmdldC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2Nyb2xsLWxvY2stbG9ja2FibGUnLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihcIlxcXCJcIi5jb25jYXQoJHRhcmdldCwgXCJcXFwiIGlzIG5vdCBhIEVsZW1lbnQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoIWdldFNjcm9sbFN0YXRlKCkpIHtcbiAgICAgIHNjcm9sbF9sb2NrX2hpZGVMb2NrYWJsZU92ZXJmbG93KCk7XG4gICAgfVxuICB9XG59O1xudmFyIHNjcm9sbF9sb2NrX2FkZExvY2thYmxlU2VsZWN0b3IgPSBmdW5jdGlvbiBhZGRMb2NrYWJsZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIGlmIChzZWxlY3Rvcikge1xuICAgIHZhciBzZWxlY3RvcnMgPSBhcmd1bWVudEFzQXJyYXkoc2VsZWN0b3IpO1xuICAgIHNlbGVjdG9ycy5tYXAoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICBzdGF0ZS5sb2NrYWJsZVNlbGVjdG9ycy5wdXNoKHNlbGVjdG9yKTtcbiAgICB9KTtcblxuICAgIGlmICghZ2V0U2Nyb2xsU3RhdGUoKSkge1xuICAgICAgc2Nyb2xsX2xvY2tfaGlkZUxvY2thYmxlT3ZlcmZsb3coKTtcbiAgICB9XG5cbiAgICBzY3JvbGxfbG9ja19hZGRGaWxsR2FwU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9XG59O1xudmFyIHNjcm9sbF9sb2NrX3NldEZpbGxHYXBNZXRob2QgPSBmdW5jdGlvbiBzZXRGaWxsR2FwTWV0aG9kKG1ldGhvZCkge1xuICBpZiAobWV0aG9kKSB7XG4gICAgaWYgKEZJTExfR0FQX0FWQUlMQUJMRV9NRVRIT0RTLmluZGV4T2YobWV0aG9kKSAhPT0gLTEpIHtcbiAgICAgIHN0YXRlLmZpbGxHYXBNZXRob2QgPSBtZXRob2Q7XG4gICAgICByZWZpbGxHYXBzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtZXRob2RzID0gRklMTF9HQVBfQVZBSUxBQkxFX01FVEhPRFMuam9pbignLCAnKTtcbiAgICAgIHRocm93RXJyb3IoXCJcXFwiXCIuY29uY2F0KG1ldGhvZCwgXCJcXFwiIG1ldGhvZCBpcyBub3QgYXZhaWxhYmxlIVxcbkF2YWlsYWJsZSBmaWxsIGdhcCBtZXRob2RzOiBcIikuY29uY2F0KG1ldGhvZHMsIFwiLlwiKSk7XG4gICAgfVxuICB9XG59O1xudmFyIHNjcm9sbF9sb2NrX2FkZEZpbGxHYXBUYXJnZXQgPSBmdW5jdGlvbiBhZGRGaWxsR2FwVGFyZ2V0KHRhcmdldCkge1xuICBpZiAodGFyZ2V0KSB7XG4gICAgdmFyIHRhcmdldHMgPSBhcmd1bWVudEFzQXJyYXkodGFyZ2V0KTtcbiAgICB0YXJnZXRzLm1hcChmdW5jdGlvbiAoJHRhcmdldHMpIHtcbiAgICAgIGVhY2hOb2RlKCR0YXJnZXRzLCBmdW5jdGlvbiAoJHRhcmdldCkge1xuICAgICAgICBpZiAoaXNFbGVtZW50KCR0YXJnZXQpKSB7XG4gICAgICAgICAgJHRhcmdldC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2Nyb2xsLWxvY2stZmlsbC1nYXAnLCAnJyk7XG5cbiAgICAgICAgICBpZiAoIXN0YXRlLnNjcm9sbCkge1xuICAgICAgICAgICAgc2Nyb2xsX2xvY2tfZmlsbEdhcFRhcmdldCgkdGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihcIlxcXCJcIi5jb25jYXQoJHRhcmdldCwgXCJcXFwiIGlzIG5vdCBhIEVsZW1lbnQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgc2Nyb2xsX2xvY2tfcmVtb3ZlRmlsbEdhcFRhcmdldCA9IGZ1bmN0aW9uIHJlbW92ZUZpbGxHYXBUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQpIHtcbiAgICB2YXIgdGFyZ2V0cyA9IGFyZ3VtZW50QXNBcnJheSh0YXJnZXQpO1xuICAgIHRhcmdldHMubWFwKGZ1bmN0aW9uICgkdGFyZ2V0cykge1xuICAgICAgZWFjaE5vZGUoJHRhcmdldHMsIGZ1bmN0aW9uICgkdGFyZ2V0KSB7XG4gICAgICAgIGlmIChpc0VsZW1lbnQoJHRhcmdldCkpIHtcbiAgICAgICAgICAkdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1zY3JvbGwtbG9jay1maWxsLWdhcCcpO1xuXG4gICAgICAgICAgaWYgKCFzdGF0ZS5zY3JvbGwpIHtcbiAgICAgICAgICAgIHNjcm9sbF9sb2NrX3VuZmlsbEdhcFRhcmdldCgkdGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihcIlxcXCJcIi5jb25jYXQoJHRhcmdldCwgXCJcXFwiIGlzIG5vdCBhIEVsZW1lbnQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgc2Nyb2xsX2xvY2tfYWRkRmlsbEdhcFNlbGVjdG9yID0gZnVuY3Rpb24gYWRkRmlsbEdhcFNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIGlmIChzZWxlY3Rvcikge1xuICAgIHZhciBzZWxlY3RvcnMgPSBhcmd1bWVudEFzQXJyYXkoc2VsZWN0b3IpO1xuICAgIHNlbGVjdG9ycy5tYXAoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICBpZiAoc3RhdGUuZmlsbEdhcFNlbGVjdG9ycy5pbmRleE9mKHNlbGVjdG9yKSA9PT0gLTEpIHtcbiAgICAgICAgc3RhdGUuZmlsbEdhcFNlbGVjdG9ycy5wdXNoKHNlbGVjdG9yKTtcblxuICAgICAgICBpZiAoIXN0YXRlLnNjcm9sbCkge1xuICAgICAgICAgIHNjcm9sbF9sb2NrX2ZpbGxHYXBTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbnZhciBzY3JvbGxfbG9ja19yZW1vdmVGaWxsR2FwU2VsZWN0b3IgPSBmdW5jdGlvbiByZW1vdmVGaWxsR2FwU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgaWYgKHNlbGVjdG9yKSB7XG4gICAgdmFyIHNlbGVjdG9ycyA9IGFyZ3VtZW50QXNBcnJheShzZWxlY3Rvcik7XG4gICAgc2VsZWN0b3JzLm1hcChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIHN0YXRlLmZpbGxHYXBTZWxlY3RvcnMgPSBzdGF0ZS5maWxsR2FwU2VsZWN0b3JzLmZpbHRlcihmdW5jdGlvbiAoZlNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBmU2VsZWN0b3IgIT09IHNlbGVjdG9yO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghc3RhdGUuc2Nyb2xsKSB7XG4gICAgICAgIHNjcm9sbF9sb2NrX3VuZmlsbEdhcFNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbnZhciByZWZpbGxHYXBzID0gZnVuY3Rpb24gcmVmaWxsR2FwcygpIHtcbiAgaWYgKCFzdGF0ZS5zY3JvbGwpIHtcbiAgICBmaWxsR2FwcygpO1xuICB9XG59O1xuXG52YXIgc2Nyb2xsX2xvY2tfaGlkZUxvY2thYmxlT3ZlcmZsb3cgPSBmdW5jdGlvbiBoaWRlTG9ja2FibGVPdmVyZmxvdygpIHtcbiAgdmFyIHNlbGVjdG9yID0gYXJyYXlBc1NlbGVjdG9yKHN0YXRlLmxvY2thYmxlU2VsZWN0b3JzKTtcbiAgc2Nyb2xsX2xvY2tfaGlkZUxvY2thYmxlT3ZlcmZsb3dTZWxlY3RvcihzZWxlY3Rvcik7XG59O1xuXG52YXIgc2Nyb2xsX2xvY2tfc2hvd0xvY2thYmxlT3ZlcmZsb3cgPSBmdW5jdGlvbiBzaG93TG9ja2FibGVPdmVyZmxvdygpIHtcbiAgdmFyIHNlbGVjdG9yID0gYXJyYXlBc1NlbGVjdG9yKHN0YXRlLmxvY2thYmxlU2VsZWN0b3JzKTtcbiAgc2Nyb2xsX2xvY2tfc2hvd0xvY2thYmxlT3ZlcmZsb3dTZWxlY3RvcihzZWxlY3Rvcik7XG59O1xuXG52YXIgc2Nyb2xsX2xvY2tfaGlkZUxvY2thYmxlT3ZlcmZsb3dTZWxlY3RvciA9IGZ1bmN0aW9uIGhpZGVMb2NrYWJsZU92ZXJmbG93U2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgdmFyICR0YXJnZXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIGVhY2hOb2RlKCR0YXJnZXRzLCBmdW5jdGlvbiAoJHRhcmdldCkge1xuICAgIHNjcm9sbF9sb2NrX2hpZGVMb2NrYWJsZU92ZXJmbG93VGFyZ2V0KCR0YXJnZXQpO1xuICB9KTtcbn07XG5cbnZhciBzY3JvbGxfbG9ja19zaG93TG9ja2FibGVPdmVyZmxvd1NlbGVjdG9yID0gZnVuY3Rpb24gc2hvd0xvY2thYmxlT3ZlcmZsb3dTZWxlY3RvcihzZWxlY3Rvcikge1xuICB2YXIgJHRhcmdldHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgZWFjaE5vZGUoJHRhcmdldHMsIGZ1bmN0aW9uICgkdGFyZ2V0KSB7XG4gICAgc2Nyb2xsX2xvY2tfc2hvd0xvY2thYmxlT3ZlcmZsb3dUYXJnZXQoJHRhcmdldCk7XG4gIH0pO1xufTtcblxudmFyIHNjcm9sbF9sb2NrX2hpZGVMb2NrYWJsZU92ZXJmbG93VGFyZ2V0ID0gZnVuY3Rpb24gaGlkZUxvY2thYmxlT3ZlcmZsb3dUYXJnZXQoJHRhcmdldCkge1xuICBpZiAoaXNFbGVtZW50KCR0YXJnZXQpICYmICR0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXNjcm9sbC1sb2NrLWxvY2tlZCcpICE9PSAndHJ1ZScpIHtcbiAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCR0YXJnZXQpO1xuICAgICR0YXJnZXQuc2V0QXR0cmlidXRlKCdkYXRhLXNjcm9sbC1sb2NrLXNhdmVkLW92ZXJmbG93LXktcHJvcGVydHknLCBjb21wdXRlZFN0eWxlLm92ZXJmbG93WSk7XG4gICAgJHRhcmdldC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2Nyb2xsLWxvY2stc2F2ZWQtaW5saW5lLW92ZXJmbG93LXByb3BlcnR5JywgJHRhcmdldC5zdHlsZS5vdmVyZmxvdyk7XG4gICAgJHRhcmdldC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2Nyb2xsLWxvY2stc2F2ZWQtaW5saW5lLW92ZXJmbG93LXktcHJvcGVydHknLCAkdGFyZ2V0LnN0eWxlLm92ZXJmbG93WSk7XG4gICAgJHRhcmdldC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICR0YXJnZXQuc2V0QXR0cmlidXRlKCdkYXRhLXNjcm9sbC1sb2NrLWxvY2tlZCcsICd0cnVlJyk7XG4gIH1cbn07XG5cbnZhciBzY3JvbGxfbG9ja19zaG93TG9ja2FibGVPdmVyZmxvd1RhcmdldCA9IGZ1bmN0aW9uIHNob3dMb2NrYWJsZU92ZXJmbG93VGFyZ2V0KCR0YXJnZXQpIHtcbiAgaWYgKGlzRWxlbWVudCgkdGFyZ2V0KSAmJiAkdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1zY3JvbGwtbG9jay1sb2NrZWQnKSA9PT0gJ3RydWUnKSB7XG4gICAgJHRhcmdldC5zdHlsZS5vdmVyZmxvdyA9ICR0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXNjcm9sbC1sb2NrLXNhdmVkLWlubGluZS1vdmVyZmxvdy1wcm9wZXJ0eScpO1xuICAgICR0YXJnZXQuc3R5bGUub3ZlcmZsb3dZID0gJHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2Nyb2xsLWxvY2stc2F2ZWQtaW5saW5lLW92ZXJmbG93LXktcHJvcGVydHknKTtcbiAgICAkdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1zY3JvbGwtbG9jay1zYXZlZC1vdmVyZmxvdy1wcm9wZXJ0eScpO1xuICAgICR0YXJnZXQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXNjcm9sbC1sb2NrLXNhdmVkLWlubGluZS1vdmVyZmxvdy1wcm9wZXJ0eScpO1xuICAgICR0YXJnZXQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXNjcm9sbC1sb2NrLXNhdmVkLWlubGluZS1vdmVyZmxvdy15LXByb3BlcnR5Jyk7XG4gICAgJHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtc2Nyb2xsLWxvY2stbG9ja2VkJyk7XG4gIH1cbn07XG5cbnZhciBmaWxsR2FwcyA9IGZ1bmN0aW9uIGZpbGxHYXBzKCkge1xuICBzdGF0ZS5maWxsR2FwU2VsZWN0b3JzLm1hcChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICBzY3JvbGxfbG9ja19maWxsR2FwU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9KTtcbn07XG5cbnZhciB1bmZpbGxHYXBzID0gZnVuY3Rpb24gdW5maWxsR2FwcygpIHtcbiAgc3RhdGUuZmlsbEdhcFNlbGVjdG9ycy5tYXAoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgc2Nyb2xsX2xvY2tfdW5maWxsR2FwU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9KTtcbn07XG5cbnZhciBzY3JvbGxfbG9ja19maWxsR2FwU2VsZWN0b3IgPSBmdW5jdGlvbiBmaWxsR2FwU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgdmFyICR0YXJnZXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIHZhciBpc0xvY2thYmxlID0gc3RhdGUubG9ja2FibGVTZWxlY3RvcnMuaW5kZXhPZihzZWxlY3RvcikgIT09IC0xO1xuICBlYWNoTm9kZSgkdGFyZ2V0cywgZnVuY3Rpb24gKCR0YXJnZXQpIHtcbiAgICBzY3JvbGxfbG9ja19maWxsR2FwVGFyZ2V0KCR0YXJnZXQsIGlzTG9ja2FibGUpO1xuICB9KTtcbn07XG5cbnZhciBzY3JvbGxfbG9ja19maWxsR2FwVGFyZ2V0ID0gZnVuY3Rpb24gZmlsbEdhcFRhcmdldCgkdGFyZ2V0KSB7XG4gIHZhciBpc0xvY2thYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICBpZiAoaXNFbGVtZW50KCR0YXJnZXQpKSB7XG4gICAgdmFyIHNjcm9sbEJhcldpZHRoO1xuXG4gICAgaWYgKCR0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXNjcm9sbC1sb2NrLWxvY2thYmxlJykgPT09ICcnIHx8IGlzTG9ja2FibGUpIHtcbiAgICAgIHNjcm9sbEJhcldpZHRoID0gc2Nyb2xsX2xvY2tfZ2V0VGFyZ2V0U2Nyb2xsQmFyV2lkdGgoJHRhcmdldCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciAkbG9ja2FibGVQYXJlbnQgPSBmaW5kUGFyZW50QnlTZWxlY3RvcigkdGFyZ2V0LCBhcnJheUFzU2VsZWN0b3Ioc3RhdGUubG9ja2FibGVTZWxlY3RvcnMpKTtcbiAgICAgIHNjcm9sbEJhcldpZHRoID0gc2Nyb2xsX2xvY2tfZ2V0VGFyZ2V0U2Nyb2xsQmFyV2lkdGgoJGxvY2thYmxlUGFyZW50LCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAoJHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2Nyb2xsLWxvY2stZmlsbGVkLWdhcCcpID09PSAndHJ1ZScpIHtcbiAgICAgIHNjcm9sbF9sb2NrX3VuZmlsbEdhcFRhcmdldCgkdGFyZ2V0KTtcbiAgICB9XG5cbiAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCR0YXJnZXQpO1xuICAgICR0YXJnZXQuc2V0QXR0cmlidXRlKCdkYXRhLXNjcm9sbC1sb2NrLWZpbGxlZC1nYXAnLCAndHJ1ZScpO1xuICAgICR0YXJnZXQuc2V0QXR0cmlidXRlKCdkYXRhLXNjcm9sbC1sb2NrLWN1cnJlbnQtZmlsbC1nYXAtbWV0aG9kJywgc3RhdGUuZmlsbEdhcE1ldGhvZCk7XG5cbiAgICBpZiAoc3RhdGUuZmlsbEdhcE1ldGhvZCA9PT0gJ21hcmdpbicpIHtcbiAgICAgIHZhciBjdXJyZW50TWFyZ2luID0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLm1hcmdpblJpZ2h0KTtcbiAgICAgICR0YXJnZXQuc3R5bGUubWFyZ2luUmlnaHQgPSBcIlwiLmNvbmNhdChjdXJyZW50TWFyZ2luICsgc2Nyb2xsQmFyV2lkdGgsIFwicHhcIik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5maWxsR2FwTWV0aG9kID09PSAnd2lkdGgnKSB7XG4gICAgICAkdGFyZ2V0LnN0eWxlLndpZHRoID0gXCJjYWxjKDEwMCUgLSBcIi5jb25jYXQoc2Nyb2xsQmFyV2lkdGgsIFwicHgpXCIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZmlsbEdhcE1ldGhvZCA9PT0gJ21heC13aWR0aCcpIHtcbiAgICAgICR0YXJnZXQuc3R5bGUubWF4V2lkdGggPSBcImNhbGMoMTAwJSAtIFwiLmNvbmNhdChzY3JvbGxCYXJXaWR0aCwgXCJweClcIik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5maWxsR2FwTWV0aG9kID09PSAncGFkZGluZycpIHtcbiAgICAgIHZhciBjdXJyZW50UGFkZGluZyA9IHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQpO1xuICAgICAgJHRhcmdldC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcIlwiLmNvbmNhdChjdXJyZW50UGFkZGluZyArIHNjcm9sbEJhcldpZHRoLCBcInB4XCIpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHNjcm9sbF9sb2NrX3VuZmlsbEdhcFNlbGVjdG9yID0gZnVuY3Rpb24gdW5maWxsR2FwU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgdmFyICR0YXJnZXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIGVhY2hOb2RlKCR0YXJnZXRzLCBmdW5jdGlvbiAoJHRhcmdldCkge1xuICAgIHNjcm9sbF9sb2NrX3VuZmlsbEdhcFRhcmdldCgkdGFyZ2V0KTtcbiAgfSk7XG59O1xuXG52YXIgc2Nyb2xsX2xvY2tfdW5maWxsR2FwVGFyZ2V0ID0gZnVuY3Rpb24gdW5maWxsR2FwVGFyZ2V0KCR0YXJnZXQpIHtcbiAgaWYgKGlzRWxlbWVudCgkdGFyZ2V0KSkge1xuICAgIGlmICgkdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1zY3JvbGwtbG9jay1maWxsZWQtZ2FwJykgPT09ICd0cnVlJykge1xuICAgICAgdmFyIGN1cnJlbnRGaWxsR2FwTWV0aG9kID0gJHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2Nyb2xsLWxvY2stY3VycmVudC1maWxsLWdhcC1tZXRob2QnKTtcbiAgICAgICR0YXJnZXQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXNjcm9sbC1sb2NrLWZpbGxlZC1nYXAnKTtcbiAgICAgICR0YXJnZXQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXNjcm9sbC1sb2NrLWN1cnJlbnQtZmlsbC1nYXAtbWV0aG9kJyk7XG5cbiAgICAgIGlmIChjdXJyZW50RmlsbEdhcE1ldGhvZCA9PT0gJ21hcmdpbicpIHtcbiAgICAgICAgJHRhcmdldC5zdHlsZS5tYXJnaW5SaWdodCA9IFwiXCI7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRGaWxsR2FwTWV0aG9kID09PSAnd2lkdGgnKSB7XG4gICAgICAgICR0YXJnZXQuc3R5bGUud2lkdGggPSBcIlwiO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50RmlsbEdhcE1ldGhvZCA9PT0gJ21heC13aWR0aCcpIHtcbiAgICAgICAgJHRhcmdldC5zdHlsZS5tYXhXaWR0aCA9IFwiXCI7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRGaWxsR2FwTWV0aG9kID09PSAncGFkZGluZycpIHtcbiAgICAgICAgJHRhcmdldC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIG9uUmVzaXplID0gZnVuY3Rpb24gb25SZXNpemUoZSkge1xuICByZWZpbGxHYXBzKCk7XG59O1xuXG52YXIgb25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcbiAgaWYgKCFzdGF0ZS5zY3JvbGwpIHtcbiAgICBzdGF0ZS5zdGFydFRvdWNoWSA9IGUudG91Y2hlc1swXS5jbGllbnRZO1xuICAgIHN0YXRlLnN0YXJ0VG91Y2hYID0gZS50b3VjaGVzWzBdLmNsaWVudFg7XG4gIH1cbn07XG5cbnZhciBzY3JvbGxfbG9ja19vblRvdWNoTW92ZSA9IGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGUpIHtcbiAgaWYgKCFzdGF0ZS5zY3JvbGwpIHtcbiAgICB2YXIgc3RhcnRUb3VjaFkgPSBzdGF0ZS5zdGFydFRvdWNoWSxcbiAgICAgICAgc3RhcnRUb3VjaFggPSBzdGF0ZS5zdGFydFRvdWNoWDtcbiAgICB2YXIgY3VycmVudENsaWVudFkgPSBlLnRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICB2YXIgY3VycmVudENsaWVudFggPSBlLnRvdWNoZXNbMF0uY2xpZW50WDtcblxuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgdmFyIHNlbGVjdG9yID0gYXJyYXlBc1NlbGVjdG9yKHN0YXRlLnNjcm9sbGFibGVTZWxlY3RvcnMpO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IHtcbiAgICAgICAgdXA6IHN0YXJ0VG91Y2hZIDwgY3VycmVudENsaWVudFksXG4gICAgICAgIGRvd246IHN0YXJ0VG91Y2hZID4gY3VycmVudENsaWVudFksXG4gICAgICAgIGxlZnQ6IHN0YXJ0VG91Y2hYIDwgY3VycmVudENsaWVudFgsXG4gICAgICAgIHJpZ2h0OiBzdGFydFRvdWNoWCA+IGN1cnJlbnRDbGllbnRYXG4gICAgICB9O1xuICAgICAgdmFyIGRpcmVjdGlvbldpdGhPZmZzZXQgPSB7XG4gICAgICAgIHVwOiBzdGFydFRvdWNoWSArIFRPVUNIX0RJUkVDVElPTl9ERVRFQ1RfT0ZGU0VUIDwgY3VycmVudENsaWVudFksXG4gICAgICAgIGRvd246IHN0YXJ0VG91Y2hZIC0gVE9VQ0hfRElSRUNUSU9OX0RFVEVDVF9PRkZTRVQgPiBjdXJyZW50Q2xpZW50WSxcbiAgICAgICAgbGVmdDogc3RhcnRUb3VjaFggKyBUT1VDSF9ESVJFQ1RJT05fREVURUNUX09GRlNFVCA8IGN1cnJlbnRDbGllbnRYLFxuICAgICAgICByaWdodDogc3RhcnRUb3VjaFggLSBUT1VDSF9ESVJFQ1RJT05fREVURUNUX09GRlNFVCA+IGN1cnJlbnRDbGllbnRYXG4gICAgICB9O1xuXG4gICAgICB2YXIgaGFuZGxlID0gZnVuY3Rpb24gaGFuZGxlKCRlbCkge1xuICAgICAgICB2YXIgc2tpcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgICAgaWYgKCRlbCkge1xuICAgICAgICAgIHZhciBwYXJlbnRTY3JvbGxhYmxlRWwgPSBmaW5kUGFyZW50QnlTZWxlY3RvcigkZWwsIHNlbGVjdG9yLCBmYWxzZSk7XG5cbiAgICAgICAgICBpZiAoZWxlbWVudElzSW5wdXRSYW5nZSgkZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNraXAgfHwgZWxlbWVudElzU2Nyb2xsYWJsZUZpZWxkKCRlbCkgJiYgZmluZFBhcmVudEJ5U2VsZWN0b3IoJGVsLCBzZWxlY3RvcikgfHwgZWxlbWVudEhhc1NlbGVjdG9yKCRlbCwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICB2YXIgcHJldmVudCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudFNjcm9sbExlZnRPblN0YXJ0KCRlbCkgJiYgZWxlbWVudFNjcm9sbExlZnRPbkVuZCgkZWwpKSB7XG4gICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24udXAgJiYgZWxlbWVudFNjcm9sbFRvcE9uU3RhcnQoJGVsKSB8fCBkaXJlY3Rpb24uZG93biAmJiBlbGVtZW50U2Nyb2xsVG9wT25FbmQoJGVsKSkge1xuICAgICAgICAgICAgICAgIHByZXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRTY3JvbGxUb3BPblN0YXJ0KCRlbCkgJiYgZWxlbWVudFNjcm9sbFRvcE9uRW5kKCRlbCkpIHtcbiAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbi5sZWZ0ICYmIGVsZW1lbnRTY3JvbGxMZWZ0T25TdGFydCgkZWwpIHx8IGRpcmVjdGlvbi5yaWdodCAmJiBlbGVtZW50U2Nyb2xsTGVmdE9uRW5kKCRlbCkpIHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb25XaXRoT2Zmc2V0LnVwICYmIGVsZW1lbnRTY3JvbGxUb3BPblN0YXJ0KCRlbCkgfHwgZGlyZWN0aW9uV2l0aE9mZnNldC5kb3duICYmIGVsZW1lbnRTY3JvbGxUb3BPbkVuZCgkZWwpIHx8IGRpcmVjdGlvbldpdGhPZmZzZXQubGVmdCAmJiBlbGVtZW50U2Nyb2xsTGVmdE9uU3RhcnQoJGVsKSB8fCBkaXJlY3Rpb25XaXRoT2Zmc2V0LnJpZ2h0ICYmIGVsZW1lbnRTY3JvbGxMZWZ0T25FbmQoJGVsKSkge1xuICAgICAgICAgICAgICBwcmV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXZlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudFNjcm9sbGFibGVFbCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZShwYXJlbnRTY3JvbGxhYmxlRWwsIHRydWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlKHBhcmVudFNjcm9sbGFibGVFbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChlLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGhhbmRsZShlLnRhcmdldCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgb25Ub3VjaEVuZCA9IGZ1bmN0aW9uIG9uVG91Y2hFbmQoZSkge1xuICBpZiAoIXN0YXRlLnNjcm9sbCkge1xuICAgIHN0YXRlLnN0YXJ0VG91Y2hZID0gMDtcbiAgICBzdGF0ZS5zdGFydFRvdWNoWCA9IDA7XG4gIH1cbn07XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUpO1xufVxuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0KTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgc2Nyb2xsX2xvY2tfb25Ub3VjaE1vdmUsIHtcbiAgICBwYXNzaXZlOiBmYWxzZVxuICB9KTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoRW5kKTtcbn1cblxudmFyIGRlcHJlY2F0ZWRNZXRob2RzID0ge1xuICBoaWRlOiBmdW5jdGlvbiBoaWRlKHRhcmdldCkge1xuICAgIHRocm93RXJyb3IoJ1wiaGlkZVwiIGlzIGRlcHJlY2F0ZWQhIFVzZSBcImRpc2FibGVQYWdlU2Nyb2xsXCIgaW5zdGVhZC4gXFxuIGh0dHBzOi8vZ2l0aHViLmNvbS9GTDNOS0VZL3Njcm9sbC1sb2NrI2Rpc2FibGVwYWdlc2Nyb2xsc2Nyb2xsYWJsZXRhcmdldCcpO1xuICAgIGRpc2FibGVQYWdlU2Nyb2xsKHRhcmdldCk7XG4gIH0sXG4gIHNob3c6IGZ1bmN0aW9uIHNob3codGFyZ2V0KSB7XG4gICAgdGhyb3dFcnJvcignXCJzaG93XCIgaXMgZGVwcmVjYXRlZCEgVXNlIFwiZW5hYmxlUGFnZVNjcm9sbFwiIGluc3RlYWQuIFxcbiBodHRwczovL2dpdGh1Yi5jb20vRkwzTktFWS9zY3JvbGwtbG9jayNlbmFibGVwYWdlc2Nyb2xsc2Nyb2xsYWJsZXRhcmdldCcpO1xuICAgIGVuYWJsZVBhZ2VTY3JvbGwodGFyZ2V0KTtcbiAgfSxcbiAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUodGFyZ2V0KSB7XG4gICAgdGhyb3dFcnJvcignXCJ0b2dnbGVcIiBpcyBkZXByZWNhdGVkISBEbyBub3QgdXNlIGl0LicpO1xuXG4gICAgaWYgKGdldFNjcm9sbFN0YXRlKCkpIHtcbiAgICAgIGRpc2FibGVQYWdlU2Nyb2xsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuYWJsZVBhZ2VTY3JvbGwodGFyZ2V0KTtcbiAgICB9XG4gIH0sXG4gIGdldFN0YXRlOiBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICB0aHJvd0Vycm9yKCdcImdldFN0YXRlXCIgaXMgZGVwcmVjYXRlZCEgVXNlIFwiZ2V0U2Nyb2xsU3RhdGVcIiBpbnN0ZWFkLiBcXG4gaHR0cHM6Ly9naXRodWIuY29tL0ZMM05LRVkvc2Nyb2xsLWxvY2sjZ2V0c2Nyb2xsc3RhdGUnKTtcbiAgICByZXR1cm4gZ2V0U2Nyb2xsU3RhdGUoKTtcbiAgfSxcbiAgZ2V0V2lkdGg6IGZ1bmN0aW9uIGdldFdpZHRoKCkge1xuICAgIHRocm93RXJyb3IoJ1wiZ2V0V2lkdGhcIiBpcyBkZXByZWNhdGVkISBVc2UgXCJnZXRQYWdlU2Nyb2xsQmFyV2lkdGhcIiBpbnN0ZWFkLiBcXG4gaHR0cHM6Ly9naXRodWIuY29tL0ZMM05LRVkvc2Nyb2xsLWxvY2sjZ2V0cGFnZXNjcm9sbGJhcndpZHRoJyk7XG4gICAgcmV0dXJuIGdldFBhZ2VTY3JvbGxCYXJXaWR0aCgpO1xuICB9LFxuICBnZXRDdXJyZW50V2lkdGg6IGZ1bmN0aW9uIGdldEN1cnJlbnRXaWR0aCgpIHtcbiAgICB0aHJvd0Vycm9yKCdcImdldEN1cnJlbnRXaWR0aFwiIGlzIGRlcHJlY2F0ZWQhIFVzZSBcImdldEN1cnJlbnRQYWdlU2Nyb2xsQmFyV2lkdGhcIiBpbnN0ZWFkLiBcXG4gaHR0cHM6Ly9naXRodWIuY29tL0ZMM05LRVkvc2Nyb2xsLWxvY2sjZ2V0Y3VycmVudHBhZ2VzY3JvbGxiYXJ3aWR0aCcpO1xuICAgIHJldHVybiBnZXRDdXJyZW50UGFnZVNjcm9sbEJhcldpZHRoKCk7XG4gIH0sXG4gIHNldFNjcm9sbGFibGVUYXJnZXRzOiBmdW5jdGlvbiBzZXRTY3JvbGxhYmxlVGFyZ2V0cyh0YXJnZXQpIHtcbiAgICB0aHJvd0Vycm9yKCdcInNldFNjcm9sbGFibGVUYXJnZXRzXCIgaXMgZGVwcmVjYXRlZCEgVXNlIFwiYWRkU2Nyb2xsYWJsZVRhcmdldFwiIGluc3RlYWQuIFxcbiBodHRwczovL2dpdGh1Yi5jb20vRkwzTktFWS9zY3JvbGwtbG9jayNhZGRzY3JvbGxhYmxldGFyZ2V0c2Nyb2xsYWJsZXRhcmdldCcpO1xuICAgIHNjcm9sbF9sb2NrX2FkZFNjcm9sbGFibGVUYXJnZXQodGFyZ2V0KTtcbiAgfSxcbiAgc2V0RmlsbEdhcFNlbGVjdG9yczogZnVuY3Rpb24gc2V0RmlsbEdhcFNlbGVjdG9ycyhzZWxlY3Rvcikge1xuICAgIHRocm93RXJyb3IoJ1wic2V0RmlsbEdhcFNlbGVjdG9yc1wiIGlzIGRlcHJlY2F0ZWQhIFVzZSBcImFkZEZpbGxHYXBTZWxlY3RvclwiIGluc3RlYWQuIFxcbiBodHRwczovL2dpdGh1Yi5jb20vRkwzTktFWS9zY3JvbGwtbG9jayNhZGRmaWxsZ2Fwc2VsZWN0b3JmaWxsZ2Fwc2VsZWN0b3InKTtcbiAgICBzY3JvbGxfbG9ja19hZGRGaWxsR2FwU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9LFxuICBzZXRGaWxsR2FwVGFyZ2V0czogZnVuY3Rpb24gc2V0RmlsbEdhcFRhcmdldHModGFyZ2V0KSB7XG4gICAgdGhyb3dFcnJvcignXCJzZXRGaWxsR2FwVGFyZ2V0c1wiIGlzIGRlcHJlY2F0ZWQhIFVzZSBcImFkZEZpbGxHYXBUYXJnZXRcIiBpbnN0ZWFkLiBcXG4gaHR0cHM6Ly9naXRodWIuY29tL0ZMM05LRVkvc2Nyb2xsLWxvY2sjYWRkZmlsbGdhcHRhcmdldGZpbGxnYXB0YXJnZXQnKTtcbiAgICBzY3JvbGxfbG9ja19hZGRGaWxsR2FwVGFyZ2V0KHRhcmdldCk7XG4gIH0sXG4gIGNsZWFyUXVldWU6IGZ1bmN0aW9uIGNsZWFyUXVldWUoKSB7XG4gICAgdGhyb3dFcnJvcignXCJjbGVhclF1ZXVlXCIgaXMgZGVwcmVjYXRlZCEgVXNlIFwiY2xlYXJRdWV1ZVNjcm9sbExvY2tzXCIgaW5zdGVhZC4gXFxuIGh0dHBzOi8vZ2l0aHViLmNvbS9GTDNOS0VZL3Njcm9sbC1sb2NrI2NsZWFycXVldWVzY3JvbGxsb2NrcycpO1xuICAgIGNsZWFyUXVldWVTY3JvbGxMb2NrcygpO1xuICB9XG59O1xuXG52YXIgc2Nyb2xsTG9jayA9IF9vYmplY3RTcHJlYWQoe1xuICBkaXNhYmxlUGFnZVNjcm9sbDogZGlzYWJsZVBhZ2VTY3JvbGwsXG4gIGVuYWJsZVBhZ2VTY3JvbGw6IGVuYWJsZVBhZ2VTY3JvbGwsXG4gIGdldFNjcm9sbFN0YXRlOiBnZXRTY3JvbGxTdGF0ZSxcbiAgY2xlYXJRdWV1ZVNjcm9sbExvY2tzOiBjbGVhclF1ZXVlU2Nyb2xsTG9ja3MsXG4gIGdldFRhcmdldFNjcm9sbEJhcldpZHRoOiBzY3JvbGxfbG9ja19nZXRUYXJnZXRTY3JvbGxCYXJXaWR0aCxcbiAgZ2V0Q3VycmVudFRhcmdldFNjcm9sbEJhcldpZHRoOiBzY3JvbGxfbG9ja19nZXRDdXJyZW50VGFyZ2V0U2Nyb2xsQmFyV2lkdGgsXG4gIGdldFBhZ2VTY3JvbGxCYXJXaWR0aDogZ2V0UGFnZVNjcm9sbEJhcldpZHRoLFxuICBnZXRDdXJyZW50UGFnZVNjcm9sbEJhcldpZHRoOiBnZXRDdXJyZW50UGFnZVNjcm9sbEJhcldpZHRoLFxuICBhZGRTY3JvbGxhYmxlU2VsZWN0b3I6IHNjcm9sbF9sb2NrX2FkZFNjcm9sbGFibGVTZWxlY3RvcixcbiAgcmVtb3ZlU2Nyb2xsYWJsZVNlbGVjdG9yOiBzY3JvbGxfbG9ja19yZW1vdmVTY3JvbGxhYmxlU2VsZWN0b3IsXG4gIGFkZFNjcm9sbGFibGVUYXJnZXQ6IHNjcm9sbF9sb2NrX2FkZFNjcm9sbGFibGVUYXJnZXQsXG4gIHJlbW92ZVNjcm9sbGFibGVUYXJnZXQ6IHNjcm9sbF9sb2NrX3JlbW92ZVNjcm9sbGFibGVUYXJnZXQsXG4gIGFkZExvY2thYmxlU2VsZWN0b3I6IHNjcm9sbF9sb2NrX2FkZExvY2thYmxlU2VsZWN0b3IsXG4gIGFkZExvY2thYmxlVGFyZ2V0OiBzY3JvbGxfbG9ja19hZGRMb2NrYWJsZVRhcmdldCxcbiAgYWRkRmlsbEdhcFNlbGVjdG9yOiBzY3JvbGxfbG9ja19hZGRGaWxsR2FwU2VsZWN0b3IsXG4gIHJlbW92ZUZpbGxHYXBTZWxlY3Rvcjogc2Nyb2xsX2xvY2tfcmVtb3ZlRmlsbEdhcFNlbGVjdG9yLFxuICBhZGRGaWxsR2FwVGFyZ2V0OiBzY3JvbGxfbG9ja19hZGRGaWxsR2FwVGFyZ2V0LFxuICByZW1vdmVGaWxsR2FwVGFyZ2V0OiBzY3JvbGxfbG9ja19yZW1vdmVGaWxsR2FwVGFyZ2V0LFxuICBzZXRGaWxsR2FwTWV0aG9kOiBzY3JvbGxfbG9ja19zZXRGaWxsR2FwTWV0aG9kLFxuICByZWZpbGxHYXBzOiByZWZpbGxHYXBzLFxuICBfc3RhdGU6IHN0YXRlXG59LCBkZXByZWNhdGVkTWV0aG9kcyk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNjcm9sbF9sb2NrID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoc2Nyb2xsTG9jayk7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKVtcImRlZmF1bHRcIl07XG59KTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/scroll-lock/dist/scroll-lock.js\n");

/***/ }),

/***/ "./src/blocks/a-anim/a-anim.js":
/*!*************************************!*\
  !*** ./src/blocks/a-anim/a-anim.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/lib */ \"./src/js/lib.js\");\n\n\n(function () {\n  Object(_js_lib__WEBPACK_IMPORTED_MODULE_0__[\"scrollClassToggle\"])(document.querySelectorAll('.a-anim__block'));\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmxvY2tzL2EtYW5pbS9hLWFuaW0uanM/MTkyYyJdLCJuYW1lcyI6WyJzY3JvbGxDbGFzc1RvZ2dsZSIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBOztBQUVBLENBQUMsWUFBTTtBQUNOQSxtRUFBaUIsQ0FBQ0MsUUFBUSxDQUFDQyxnQkFBVCxDQUEwQixnQkFBMUIsQ0FBRCxDQUFqQjtBQUVBLENBSEQiLCJmaWxlIjoiLi9zcmMvYmxvY2tzL2EtYW5pbS9hLWFuaW0uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzY3JvbGxDbGFzc1RvZ2dsZSB9IGZyb20gXCIuLi8uLi9qcy9saWJcIjtcblxuKCgpID0+IHtcblx0c2Nyb2xsQ2xhc3NUb2dnbGUoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmEtYW5pbV9fYmxvY2snKSk7XG5cbn0pKCk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/blocks/a-anim/a-anim.js\n");

/***/ }),

/***/ "./src/blocks/accordeon/accordeon.js":
/*!*******************************************!*\
  !*** ./src/blocks/accordeon/accordeon.js ***!
  \*******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/lib */ \"./src/js/lib.js\");\n\n\n(function () {\n  //    \n  document.querySelectorAll('.accordeon_green').forEach(function (accordion) {\n    Object(_js_lib__WEBPACK_IMPORTED_MODULE_0__[\"roughAccordion\"])(accordion.querySelectorAll('.accordeon__head'), {\n      toggle: true\n    });\n  }); //     \n\n  document.querySelectorAll('.accordeon_yellow').forEach(function (accordion) {\n    Object(_js_lib__WEBPACK_IMPORTED_MODULE_0__[\"smoothAccordion\"])(accordion.querySelectorAll('.accordeon__head'), {\n      toggle: true\n    });\n  }); //     ,  \n\n  document.querySelectorAll('.accordeon_blue').forEach(function (accordion) {\n    var heads = accordion.querySelectorAll('.accordeon__head');\n    heads.forEach(function (head) {\n      head.addEventListener('click', function (e) {\n        var _this = this;\n\n        var sibling = head.nextElementSibling;\n        heads.forEach(function (outhead) {\n          outhead != _this && (outhead.nextElementSibling.style.maxHeight = 0);\n        });\n        sibling.style.maxHeight = sibling.scrollHeight + 'px';\n      });\n    });\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmxvY2tzL2FjY29yZGVvbi9hY2NvcmRlb24uanM/MTYzZiJdLCJuYW1lcyI6WyJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiYWNjb3JkaW9uIiwicm91Z2hBY2NvcmRpb24iLCJ0b2dnbGUiLCJzbW9vdGhBY2NvcmRpb24iLCJoZWFkcyIsImhlYWQiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsInNpYmxpbmciLCJuZXh0RWxlbWVudFNpYmxpbmciLCJvdXRoZWFkIiwic3R5bGUiLCJtYXhIZWlnaHQiLCJzY3JvbGxIZWlnaHQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTs7QUFFQSxDQUFDLFlBQU07QUFFTjtBQUNBQSxVQUFRLENBQUNDLGdCQUFULENBQTBCLGtCQUExQixFQUE4Q0MsT0FBOUMsQ0FBc0QsVUFBQ0MsU0FBRCxFQUFlO0FBQ3BFQyxrRUFBYyxDQUFDRCxTQUFTLENBQUNGLGdCQUFWLENBQTJCLGtCQUEzQixDQUFELEVBQWlEO0FBQUVJLFlBQU0sRUFBRTtBQUFWLEtBQWpELENBQWQ7QUFDQSxHQUZELEVBSE0sQ0FPTjs7QUFDQUwsVUFBUSxDQUFDQyxnQkFBVCxDQUEwQixtQkFBMUIsRUFBK0NDLE9BQS9DLENBQXVELFVBQUNDLFNBQUQsRUFBZTtBQUNyRUcsbUVBQWUsQ0FBQ0gsU0FBUyxDQUFDRixnQkFBVixDQUEyQixrQkFBM0IsQ0FBRCxFQUFpRDtBQUFFSSxZQUFNLEVBQUU7QUFBVixLQUFqRCxDQUFmO0FBQ0EsR0FGRCxFQVJNLENBWU47O0FBQ0FMLFVBQVEsQ0FBQ0MsZ0JBQVQsQ0FBMEIsaUJBQTFCLEVBQTZDQyxPQUE3QyxDQUFxRCxVQUFDQyxTQUFELEVBQWU7QUFDbkUsUUFBSUksS0FBSyxHQUFHSixTQUFTLENBQUNGLGdCQUFWLENBQTJCLGtCQUEzQixDQUFaO0FBQ0FNLFNBQUssQ0FBQ0wsT0FBTixDQUFjLFVBQUFNLElBQUksRUFBSTtBQUNyQkEsVUFBSSxDQUFDQyxnQkFBTCxDQUFzQixPQUF0QixFQUErQixVQUFTQyxDQUFULEVBQVk7QUFBQTs7QUFDMUMsWUFBSUMsT0FBTyxHQUFHSCxJQUFJLENBQUNJLGtCQUFuQjtBQUNBTCxhQUFLLENBQUNMLE9BQU4sQ0FBYyxVQUFBVyxPQUFPLEVBQUk7QUFBRUEsaUJBQU8sSUFBSSxLQUFaLEtBQXNCQSxPQUFPLENBQUNELGtCQUFSLENBQTJCRSxLQUEzQixDQUFpQ0MsU0FBakMsR0FBNkMsQ0FBbkU7QUFBc0UsU0FBaEc7QUFDQUosZUFBTyxDQUFDRyxLQUFSLENBQWNDLFNBQWQsR0FBMEJKLE9BQU8sQ0FBQ0ssWUFBUixHQUF1QixJQUFqRDtBQUNBLE9BSkQ7QUFLQSxLQU5EO0FBT0EsR0FURDtBQVdBLENBeEJEIiwiZmlsZSI6Ii4vc3JjL2Jsb2Nrcy9hY2NvcmRlb24vYWNjb3JkZW9uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcm91Z2hBY2NvcmRpb24sIHNtb290aEFjY29yZGlvbiB9IGZyb20gXCIuLi8uLi9qcy9saWJcIjtcblxuKCgpID0+IHtcblxuXHQvLyDQkNC60LrQvtGA0LTQtdC+0L0g0YfQtdGA0LXQtyDRgdC80LXQvdGDINC60LvQsNGB0YHQvtCyXG5cdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5hY2NvcmRlb25fZ3JlZW4nKS5mb3JFYWNoKChhY2NvcmRpb24pID0+IHtcblx0XHRyb3VnaEFjY29yZGlvbihhY2NvcmRpb24ucXVlcnlTZWxlY3RvckFsbCgnLmFjY29yZGVvbl9faGVhZCcpLCB7IHRvZ2dsZTogdHJ1ZSB9KTtcblx0fSk7XG5cdFxuXHQvLyDQkNC60LrQvtGA0LTQtdC+0L0g0YEg0L/Qu9Cw0LLQvdC+0Lkg0YHQvNC10L3QvtC5INCx0LvQvtC60L7QslxuXHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYWNjb3JkZW9uX3llbGxvdycpLmZvckVhY2goKGFjY29yZGlvbikgPT4ge1xuXHRcdHNtb290aEFjY29yZGlvbihhY2NvcmRpb24ucXVlcnlTZWxlY3RvckFsbCgnLmFjY29yZGVvbl9faGVhZCcpLCB7IHRvZ2dsZTogdHJ1ZSB9KTtcblx0fSk7XG5cdFxuXHQvLyDQkNC60LrQvtGA0LTQtdC+0L0g0YEg0L/Qu9Cw0LLQvdC+0Lkg0YHQvNC10L3QvtC5INCx0LvQvtC60L7Qsiwg0L/RgNC+0YHRgtCw0Y8g0YDQtdCw0LvQuNC30LDRhtC40Y9cblx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmFjY29yZGVvbl9ibHVlJykuZm9yRWFjaCgoYWNjb3JkaW9uKSA9PiB7XG5cdFx0bGV0IGhlYWRzID0gYWNjb3JkaW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hY2NvcmRlb25fX2hlYWQnKTtcblx0XHRoZWFkcy5mb3JFYWNoKGhlYWQgPT4ge1xuXHRcdFx0aGVhZC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0bGV0IHNpYmxpbmcgPSBoZWFkLm5leHRFbGVtZW50U2libGluZztcblx0XHRcdFx0aGVhZHMuZm9yRWFjaChvdXRoZWFkID0+IHsob3V0aGVhZCAhPSB0aGlzKSAmJiAob3V0aGVhZC5uZXh0RWxlbWVudFNpYmxpbmcuc3R5bGUubWF4SGVpZ2h0ID0gMCl9KTtcblx0XHRcdFx0c2libGluZy5zdHlsZS5tYXhIZWlnaHQgPSBzaWJsaW5nLnNjcm9sbEhlaWdodCArICdweCc7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fSk7XG5cbn0pKCk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/blocks/accordeon/accordeon.js\n");

/***/ }),

/***/ "./src/blocks/c-calc/c-calc.js":
/*!*************************************!*\
  !*** ./src/blocks/c-calc/c-calc.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _c_calc_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./c-calc.json */ \"./src/blocks/c-calc/c-calc.json\");\nvar _c_calc_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ./c-calc.json */ \"./src/blocks/c-calc/c-calc.json\", 1);\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\n\n(function () {\n  var $space = $('#c-calc');\n  var $title = $space.find('.c-calc__title');\n  var $page = $space.find('.c-page__controls');\n  var $prev = $space.find('.c-calc__btn_prev');\n  var $next = $space.find('.c-calc__btn_next');\n  var choices = ['vop', 'tech', 'arch', 'geologsquare'];\n  var results = [];\n  var count = []; //   \n\n  var isObject = function isObject(item) {\n    return item && _typeof(item) === 'object' && !Array.isArray(item);\n  };\n  /*             */\n\n\n  var mergeDeep = function mergeDeep(target) {\n    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      sources[_key - 1] = arguments[_key];\n    }\n\n    if (!sources.length) return target;\n    var source = sources.shift();\n\n    if (isObject(target) && isObject(source)) {\n      for (var key in source) {\n        if (isObject(source[key])) {\n          mergeDeep(target[key], source[key]);\n        } else {\n          Object.assign(target, _defineProperty({}, key, source[key]));\n        }\n      }\n    }\n\n    return mergeDeep.apply(void 0, [target].concat(sources));\n  };\n\n  var requiredMiss = function requiredMiss($shell) {\n    var done = false;\n    $shell.find('[data-required!=\"\"][data-required]').each(function () {\n      var match = $(this).find('input:text').filter(function () {\n        return $(this).val() > 0;\n      }).add('input:checked', $(this));\n      if (!match.length) done = true;\n    });\n    return done;\n  };\n  /*     */\n\n\n  var renderPage = function renderPage(index) {\n    var _DATA$pages$choices$i;\n\n    $space.data('step', index); //    \n\n    var rows = mergeDeep(_c_calc_json__WEBPACK_IMPORTED_MODULE_0__.pages[choices[index]].rows, _c_calc_json__WEBPACK_IMPORTED_MODULE_0__[\"default\"]); //  -       ..\n\n    var isInResult = function isInResult(row, name) {\n      return results[choices[index]] && results[choices[index]][row] && name in results[choices[index]][row] || '';\n    }; //    (      )\n\n\n    var getValue = function getValue(row, name) {\n      var _rows$row$name$value;\n\n      if (isInResult(row, name)) {\n        return results[choices[index]][row][name];\n      }\n\n      return (_rows$row$name$value = rows[row][name]['value']) !== null && _rows$row$name$value !== void 0 ? _rows$row$name$value : '';\n    }; //   \n\n\n    $title.find('h4').text((_DATA$pages$choices$i = _c_calc_json__WEBPACK_IMPORTED_MODULE_0__.pages[choices[index]].title) !== null && _DATA$pages$choices$i !== void 0 ? _DATA$pages$choices$i : ''); //   html  \n\n    var html = \"<div class=\\\"c-page__controls\\\" data-page=\\\"\".concat(choices[index], \"\\\">\");\n\n    for (var row in rows) {\n      if (rows.hasOwnProperty(row)) {\n        if (!$.isEmptyObject(rows[row])) {\n          var _rows$row$title, _rows$row$required;\n\n          html += \"<div class=\\\"c-page__row c-page__row_\".concat(row, \"\\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<h5 class=\\\"c-page__name\\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\").concat((_rows$row$title = rows[row]['title']) !== null && _rows$row$title !== void 0 ? _rows$row$title : '', \" \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\").concat(rows[row]['required'] && '<span>*</span>', \"\\n\\t\\t\\t\\t\\t\\t\\t\\t</h5>\\n\\t\\t\\t\\t\\t\\t\\t\\t<div class=\\\"c-page__inputs\\\" data-required=\\\"\").concat((_rows$row$required = rows[row]['required']) !== null && _rows$row$required !== void 0 ? _rows$row$required : '', \"\\\">\");\n\n          for (var elem in rows[row]) {\n            if (rows[row].hasOwnProperty(elem) && elem !== 'title' && elem !== 'required') {\n              var _rows$row$elem$input, _rows$row$elem$input2, _rows$row$elem$title;\n\n              html += \"<label class=\\\"c-page__input-\".concat((_rows$row$elem$input = rows[row][elem]['input']) !== null && _rows$row$elem$input !== void 0 ? _rows$row$elem$input : 'cbox', \"\\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<input\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttype=\\\"\").concat((_rows$row$elem$input2 = rows[row][elem]['input']) !== null && _rows$row$elem$input2 !== void 0 ? _rows$row$elem$input2 : 'checkbox', \"\\\" \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tname=\\\"\").concat(row, \"\\\" \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvalue=\\\"\").concat(getValue(row, elem), \"\\\" \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdata-name=\\\"\").concat(elem, \"\\\" \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\").concat(isInResult(row, elem) && 'checked', \"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t/>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\").concat((_rows$row$elem$title = rows[row][elem]['title']) !== null && _rows$row$elem$title !== void 0 ? _rows$row$elem$title : '', \"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t</label>\");\n            }\n          }\n\n          html += \"</div>\\n\\t\\t\\t\\t\\t\\t</div>\";\n        }\n      }\n    }\n\n    html += \"</div>\"; //     html\n\n    $page.html(html); //  \n\n    $next.prop('disabled', Boolean(!results[choices[index]] || requiredMiss($(html)))).removeAttr('style'); //   \"\"   \n\n    if (!index) $prev.removeAttr('style');\n  }; //   \n\n\n  $space.on('change', 'input', function (e) {\n    var $shell = $(this).parents('.c-page__controls');\n    var page = $shell.data('page');\n    results[page] = [];\n    $shell.find('input:checked').add('input:text').each(function (index, el) {\n      if (el.name in results[page]) {\n        Object.assign(results[page][el.name], _defineProperty({}, el.dataset.name, el.value));\n      } else {\n        Object.assign(results[page], _defineProperty({}, el.name, _defineProperty({}, el.dataset.name, el.value)));\n      }\n    }); // $next.prop('disabled', Boolean(!Object.keys(results[page]).length));\n\n    $next.prop('disabled', requiredMiss($shell));\n  }); //    \n\n  var processingResults = function processingResults() {\n    $space.data('step', choices.length);\n    return false;\n  }; //   \"\"\n\n\n  $space.on('click', '.c-calc__btn_next', function (e) {\n    var nextStep = $space.data('step') + 1;\n\n    if (choices.length <= nextStep) {\n      processingResults();\n    } else {\n      $prev.show();\n      renderPage(nextStep);\n    }\n  }); //   \"\"\n\n  $space.on('click', '.c-calc__btn_prev', function (e) {\n    var prevStep = $space.data('step') - 1;\n    if (prevStep < 0) return;\n    renderPage(prevStep);\n  });\n  renderPage(0);\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmxvY2tzL2MtY2FsYy9jLWNhbGMuanM/NjBlYSJdLCJuYW1lcyI6WyIkc3BhY2UiLCIkIiwiJHRpdGxlIiwiZmluZCIsIiRwYWdlIiwiJHByZXYiLCIkbmV4dCIsImNob2ljZXMiLCJyZXN1bHRzIiwiY291bnQiLCJpc09iamVjdCIsIml0ZW0iLCJBcnJheSIsImlzQXJyYXkiLCJtZXJnZURlZXAiLCJ0YXJnZXQiLCJzb3VyY2VzIiwibGVuZ3RoIiwic291cmNlIiwic2hpZnQiLCJrZXkiLCJPYmplY3QiLCJhc3NpZ24iLCJyZXF1aXJlZE1pc3MiLCIkc2hlbGwiLCJkb25lIiwiZWFjaCIsIm1hdGNoIiwiZmlsdGVyIiwidmFsIiwiYWRkIiwicmVuZGVyUGFnZSIsImluZGV4IiwiZGF0YSIsInJvd3MiLCJEQVRBIiwicGFnZXMiLCJpc0luUmVzdWx0Iiwicm93IiwibmFtZSIsImdldFZhbHVlIiwidGV4dCIsInRpdGxlIiwiaHRtbCIsImhhc093blByb3BlcnR5IiwiaXNFbXB0eU9iamVjdCIsImVsZW0iLCJwcm9wIiwiQm9vbGVhbiIsInJlbW92ZUF0dHIiLCJvbiIsImUiLCJwYXJlbnRzIiwicGFnZSIsImVsIiwiZGF0YXNldCIsInZhbHVlIiwicHJvY2Vzc2luZ1Jlc3VsdHMiLCJuZXh0U3RlcCIsInNob3ciLCJwcmV2U3RlcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUVBLENBQUMsWUFBTTtBQUNOLE1BQU1BLE1BQU0sR0FBR0MsQ0FBQyxDQUFDLFNBQUQsQ0FBaEI7QUFDQSxNQUFNQyxNQUFNLEdBQUdGLE1BQU0sQ0FBQ0csSUFBUCxDQUFZLGdCQUFaLENBQWY7QUFDQSxNQUFNQyxLQUFLLEdBQUdKLE1BQU0sQ0FBQ0csSUFBUCxDQUFZLG1CQUFaLENBQWQ7QUFDQSxNQUFNRSxLQUFLLEdBQUdMLE1BQU0sQ0FBQ0csSUFBUCxDQUFZLG1CQUFaLENBQWQ7QUFDQSxNQUFNRyxLQUFLLEdBQUdOLE1BQU0sQ0FB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QnpELFVBQU0sQ0FBQ2lDLElBQVAsQ0FBWSxNQUFaLEVBQW9CMUIsT0FBTyxDQUFDVSxNQUE1QjtBQUNBLFdBQU8sS0FBUDtBQUNBLEdBSEQsQ0F0SU0sQ0E0SU47OztBQUNBakIsUUFBTSxDQUFDa0QsRUFBUCxDQUFVLE9BQVYsRUFBbUIsbUJBQW5CLEVBQXdDLFVBQVNDLENBQVQsRUFBWTtBQUNuRCxRQUFNTyxRQUFRLEdBQUcxRCxNQUFNLENBQUNpQyxJQUFQLENBQVksTUFBWixJQUFzQixDQUF2Qzs7QUFFQSxRQUFJMUIsT0FBTyxDQUFDVSxNQUFSLElBQWtCeUMsUUFBdEIsRUFBZ0M7QUFDL0JELHVCQUFpQjtBQUNqQixLQUZELE1BRU87QUFDTnBELFdBQUssQ0FBQ3NELElBQU47QUFDQTVCLGdCQUFVLENBQUMyQixRQUFELENBQVY7QUFDQTtBQUNELEdBVEQsRUE3SU0sQ0F5Sk47O0FBQ0ExRCxRQUFNLENBQUNrRCxFQUFQLENBQVUsT0FBVixFQUFtQixtQkFBbkIsRUFBd0MsVUFBU0MsQ0FBVCxFQUFZO0FBQ25ELFFBQUlTLFFBQVEsR0FBRzVELE1BQU0sQ0FBQ2lDLElBQVAsQ0FBWSxNQUFaLElBQXNCLENBQXJDO0FBQ0EsUUFBSTJCLFFBQVEsR0FBRyxDQUFmLEVBQWtCO0FBRWxCN0IsY0FBVSxDQUFDNkIsUUFBRCxDQUFWO0FBQ0EsR0FMRDtBQU9BN0IsWUFBVSxDQUFDLENBQUQsQ0FBVjtBQUVBLENBbktEIiwiZmlsZSI6Ii4vc3JjL2Jsb2Nrcy9jLWNhbGMvYy1jYWxjLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERBVEEgZnJvbSAnLi9jLWNhbGMuanNvbic7XG5cbigoKSA9PiB7XG5cdGNvbnN0ICRzcGFjZSA9ICQoJyNjLWNhbGMnKTtcblx0Y29uc3QgJHRpdGxlID0gJHNwYWNlLmZpbmQoJy5jLWNhbGNfX3RpdGxlJyk7XG5cdGNvbnN0ICRwYWdlID0gJHNwYWNlLmZpbmQoJy5jLXBhZ2VfX2NvbnRyb2xzJyk7XG5cdGNvbnN0ICRwcmV2ID0gJHNwYWNlLmZpbmQoJy5jLWNhbGNfX2J0bl9wcmV2Jyk7XG5cdGNvbnN0ICRuZXh0ID0gJHNwYWNlLmZpbmQoJy5jLWNhbGNfX2J0bl9uZXh0Jyk7XG5cdGNvbnN0IGNob2ljZXMgPSBbJ3ZvcCcsJ3RlY2gnLCdhcmNoJywnZ2VvbG9nc3F1YXJlJ107XG5cdGxldCByZXN1bHRzID0gW107XG5cdGxldCBjb3VudCA9IFtdO1xuXHRcblxuXHQvLyDQv9GA0L7QstC10YDQutCwINC90LAg0L7QsdGK0LXQutGCXG5cdGNvbnN0IGlzT2JqZWN0ID0gKGl0ZW0pID0+IChpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpdGVtKSk7XG5cblx0Lyog0YTQvtGA0LzQuNGA0L7QstCw0L3QuNC1INC+0LHRitC10LrRgtCwINGC0LXQutGD0YnQtdCz0L4g0LjRgdGB0LvQtdC00L7QstCw0L3QuNGPINGH0LXRgNC10Lcg0YHQu9C40Y/QvdC40LUg0LfQsNCz0L7RgtC+0LLQutC4INC00LvRjyDQvdC10LPQviDRgSDQsdCw0LfQvtCy0YvQvCDQvtCx0YrQtdC60YLQvtC8ICovXG5cdGNvbnN0IG1lcmdlRGVlcCA9ICh0YXJnZXQsIC4uLnNvdXJjZXMpID0+IHtcblx0XHRpZiAoIXNvdXJjZXMubGVuZ3RoKSByZXR1cm4gdGFyZ2V0O1xuXHRcdGNvbnN0IHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTtcblx0XG5cdFx0aWYgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkge1xuXHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG5cdFx0XHRcdGlmIChpc09iamVjdChzb3VyY2Vba2V5XSkpIHtcblx0XHRcdFx0XHRtZXJnZURlZXAodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuYXNzaWduKHRhcmdldCwgeyBba2V5XTogc291cmNlW2tleV0gfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1lcmdlRGVlcCh0YXJnZXQsIC4uLnNvdXJjZXMpO1xuXHR9XG5cblx0Y29uc3QgcmVxdWlyZWRNaXNzID0gKCRzaGVsbCkgPT4ge1xuXHRcdGxldCBkb25lID0gZmFsc2U7XG5cdFx0JHNoZWxsLmZpbmQoJ1tkYXRhLXJlcXVpcmVkIT1cIlwiXVtkYXRhLXJlcXVpcmVkXScpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRsZXQgbWF0Y2ggPSAkKHRoaXMpXG5cdFx0XHRcdC5maW5kKCdpbnB1dDp0ZXh0Jylcblx0XHRcdFx0LmZpbHRlcihmdW5jdGlvbigpIHsgcmV0dXJuICQodGhpcykudmFsKCkgPiAwOyB9KVxuXHRcdFx0XHQuYWRkKCdpbnB1dDpjaGVja2VkJywgJCh0aGlzKSk7XG5cdFx0XHRcblx0XHRcdGlmICghbWF0Y2gubGVuZ3RoKVxuXHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHR9KTtcblx0XHRyZXR1cm4gZG9uZTtcblx0fVxuXG5cdC8qINC+0YLRgNC40YHQvtCy0LrQsCDRgdGC0YDQsNC90LjRhtGLINGC0LXQutGD0YnQtdCz0L4g0LjRgdGB0LvQtdC00L7QstCw0L3QuNGPICovXG5cdGNvbnN0IHJlbmRlclBhZ2UgPSAoaW5kZXgpID0+IHtcblx0XHQkc3BhY2UuZGF0YSgnc3RlcCcsIGluZGV4KTtcblxuXHRcdC8vINC/0L7Qu9GD0YfQuNGC0Ywg0L7QsdGK0LXQutGCINGC0LXQutGD0YnQtdCz0L4g0LjRgdGB0LvQtdC00L7QstCw0L3QuNGPXG5cdFx0Y29uc3Qgcm93cyA9IG1lcmdlRGVlcChEQVRBLnBhZ2VzW2Nob2ljZXNbaW5kZXhdXS5yb3dzLCBEQVRBLmRlZmF1bHQpO1xuXG5cdFx0Ly8g0L/RgNC+0LLQtdGA0LrQsCAtINC10YHRgtGMINC70Lgg0Y3RgtC+INC30L3QsNGH0LXQvdC40LUg0LIg0LzQsNGB0YHQuNCy0LUg0YDQtdC30YPQu9GM0YLQsNGC0L7Qsi4uXG5cdFx0Y29uc3QgaXNJblJlc3VsdCA9IChyb3csIG5hbWUpID0+IChyZXN1bHRzW2Nob2ljZXNbaW5kZXhdXSAmJiByZXN1bHRzW2Nob2ljZXNbaW5kZXhdXVtyb3ddICYmIChuYW1lIGluIHJlc3VsdHNbY2hvaWNlc1tpbmRleF1dW3Jvd10pIHx8ICcnKTtcblxuXHRcdC8vINC/0L7Qu9GD0YfQuNGC0Ywg0LfQvdCw0YfQtdC90LjQtSDQuNC90L/Rg9GC0LAgKNGB0YDQsNC30YMg0LjQu9C4INC/0YDQuCDQstC+0LfQstGA0LDRgtC1INC90LAg0L/RgNC10LTRi9C00YPRidGD0Y4g0YHRgtGA0LDQvdC40YbRgylcblx0XHRjb25zdCBnZXRWYWx1ZSA9IChyb3csIG5hbWUpID0+IHtcblx0XHRcdGlmIChpc0luUmVzdWx0KHJvdywgbmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHNbY2hvaWNlc1tpbmRleF1dW3Jvd11bbmFtZV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcm93c1tyb3ddW25hbWVdWyd2YWx1ZSddID8/ICcnXG5cdFx0fVxuXG5cdFx0Ly8g0LfQsNCz0L7Qu9C+0LLQvtC6INGC0LXQutGD0YnQtdC5INGB0YLRgNCw0L3QuNGG0Ytcblx0XHQkdGl0bGUuZmluZCgnaDQnKS50ZXh0KERBVEEucGFnZXNbY2hvaWNlc1tpbmRleF1dLnRpdGxlID8/ICcnKTtcblxuXHRcdC8vINC90LDRh9C40L3QsNGOINGE0L7RgNC80LjRgNC+0LLQsNGC0YwgaHRtbCDRgtC10LrRg9GJ0LXQuSDRgdGC0YDQsNC90LjRhtGLXG5cdFx0bGV0IGh0bWwgPSBgPGRpdiBjbGFzcz1cImMtcGFnZV9fY29udHJvbHNcIiBkYXRhLXBhZ2U9XCIke2Nob2ljZXNbaW5kZXhdfVwiPmA7XG5cdFx0Zm9yIChjb25zdCByb3cgaW4gcm93cykge1xuXHRcdFx0aWYgKHJvd3MuaGFzT3duUHJvcGVydHkocm93KSkge1xuXHRcdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChyb3dzW3Jvd10pKSB7XG5cdFx0XHRcdFx0aHRtbCArPSBgPGRpdiBjbGFzcz1cImMtcGFnZV9fcm93IGMtcGFnZV9fcm93XyR7cm93fVwiPlxuXHRcdFx0XHRcdFx0XHRcdDxoNSBjbGFzcz1cImMtcGFnZV9fbmFtZVwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0JHtyb3dzW3Jvd11bJ3RpdGxlJ10gPz8gJyd9IFxuXHRcdFx0XHRcdFx0XHRcdFx0JHtyb3dzW3Jvd11bJ3JlcXVpcmVkJ10gJiYgJzxzcGFuPio8L3NwYW4+J31cblx0XHRcdFx0XHRcdFx0XHQ8L2g1PlxuXHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJjLXBhZ2VfX2lucHV0c1wiIGRhdGEtcmVxdWlyZWQ9XCIke3Jvd3Nbcm93XVsncmVxdWlyZWQnXSA/PyAnJ31cIj5gO1xuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBlbGVtIGluIHJvd3Nbcm93XSkge1xuXHRcdFx0XHRcdFx0XHRpZiAocm93c1tyb3ddLmhhc093blByb3BlcnR5KGVsZW0pICYmIGVsZW0gIT09ICd0aXRsZScgJiYgZWxlbSAhPT0gJ3JlcXVpcmVkJykge1xuXHRcdFx0XHRcdFx0XHRcdGh0bWwgKz0gYDxsYWJlbCBjbGFzcz1cImMtcGFnZV9faW5wdXQtJHtyb3dzW3Jvd11bZWxlbV1bJ2lucHV0J10gPz8gJ2Nib3gnfVwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxpbnB1dFx0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlPVwiJHtyb3dzW3Jvd11bZWxlbV1bJ2lucHV0J10gPz8gJ2NoZWNrYm94J31cIiBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5hbWU9XCIke3Jvd31cIiBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlPVwiJHtnZXRWYWx1ZShyb3csIGVsZW0pfVwiIFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS1uYW1lPVwiJHtlbGVtfVwiIFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0JHtpc0luUmVzdWx0KHJvdywgZWxlbSkgJiYgJ2NoZWNrZWQnfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0JHtyb3dzW3Jvd11bZWxlbV1bJ3RpdGxlJ10gPz8gJyd9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDwvbGFiZWw+YFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aHRtbCArPSBgPC9kaXY+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5gXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aHRtbCArPSBgPC9kaXY+YFxuXHRcdFxuXHRcdC8vINC00L7QsdCw0LLQu9GP0Y4g0L3QsCDRgdGC0YDQsNC90LjRhtGDINGB0YTQvtGA0LzQuNGA0L7QstCw0L3QvdGL0LkgaHRtbFxuXHRcdCRwYWdlLmh0bWwoaHRtbCk7XG5cblx0XHQvLyDRgdCx0YDQvtGBINGN0LvQtdC80LXQvdGC0L7QslxuXHRcdCRuZXh0XG5cdFx0XHQucHJvcCgnZGlzYWJsZWQnLCBCb29sZWFuKCFyZXN1bHRzW2Nob2ljZXNbaW5kZXhdXSB8fCByZXF1aXJlZE1pc3MoJChodG1sKSkpKVxuXHRcdFx0LnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG5cblx0XHQvLyDRg9Cx0YDQsNGC0Ywg0LrQvdC+0L/QutGDIFwi0L3QsNC30LDQtFwiINC90LAg0L/QtdGA0LLQvtC5INGB0YLRgNCw0L3QuNGH0LrQtVxuXHRcdGlmICghaW5kZXgpICRwcmV2LnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG5cdH07XG5cblxuXHQvLyDQvtCx0YDQsNCx0L7RgtGH0LjQuiDQstGL0LHQvtGA0LAg0L7RgtCy0LXRgtCwXG5cdCRzcGFjZS5vbignY2hhbmdlJywgJ2lucHV0JywgZnVuY3Rpb24oZSkge1xuXHRcdGNvbnN0ICRzaGVsbCA9ICQodGhpcykucGFyZW50cygnLmMtcGFnZV9fY29udHJvbHMnKTtcblx0XHRjb25zdCBwYWdlID0gJHNoZWxsLmRhdGEoJ3BhZ2UnKTtcblx0XHRyZXN1bHRzW3BhZ2VdID0gW107XG5cblx0XHQkc2hlbGxcblx0XHRcdC5maW5kKCdpbnB1dDpjaGVja2VkJylcblx0XHRcdC5hZGQoJ2lucHV0OnRleHQnKVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsKSB7XG5cdFx0XHRcdGlmIChlbC5uYW1lIGluIHJlc3VsdHNbcGFnZV0pIHtcblx0XHRcdFx0XHRPYmplY3QuYXNzaWduKHJlc3VsdHNbcGFnZV1bZWwubmFtZV0sIHsgW2VsLmRhdGFzZXQubmFtZV06IGVsLnZhbHVlIH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5hc3NpZ24ocmVzdWx0c1twYWdlXSwge1tlbC5uYW1lXTogeyBbZWwuZGF0YXNldC5uYW1lXTogZWwudmFsdWUgfX0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdC8vICRuZXh0LnByb3AoJ2Rpc2FibGVkJywgQm9vbGVhbighT2JqZWN0LmtleXMocmVzdWx0c1twYWdlXSkubGVuZ3RoKSk7XG5cdFx0JG5leHQucHJvcCgnZGlzYWJsZWQnLCByZXF1aXJlZE1pc3MoJHNoZWxsKSk7XG5cdH0pO1xuXG5cblx0Ly8g0YTQvtGA0LzQuNGA0L7QstCw0L3QuNC1INGA0LXQt9GD0LvRjNGC0LDRgtC+0LIg0LTQu9GPINC+0YLQv9GA0LDQstC60Lhcblx0Y29uc3QgcHJvY2Vzc2luZ1Jlc3VsdHMgPSAoKSA9PiB7XG5cdFx0JHNwYWNlLmRhdGEoJ3N0ZXAnLCBjaG9pY2VzLmxlbmd0aCk7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cblx0Ly8g0L7QsdGA0LDQsdC+0YLRh9C40Log0LrQvdC+0L/QutC4IFwi0LTQsNC70LXQtVwiXG5cdCRzcGFjZS5vbignY2xpY2snLCAnLmMtY2FsY19fYnRuX25leHQnLCBmdW5jdGlvbihlKSB7XG5cdFx0Y29uc3QgbmV4dFN0ZXAgPSAkc3BhY2UuZGF0YSgnc3RlcCcpICsgMTtcblx0XHRcblx0XHRpZiAoY2hvaWNlcy5sZW5ndGggPD0gbmV4dFN0ZXApIHtcblx0XHRcdHByb2Nlc3NpbmdSZXN1bHRzKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCRwcmV2LnNob3coKTtcblx0XHRcdHJlbmRlclBhZ2UobmV4dFN0ZXApO1xuXHRcdH1cblx0fSk7XG5cblxuXHQvLyDQvtCx0YDQsNCx0L7RgtGH0LjQuiDQutC90L7Qv9C60LggXCLQvdCw0LfQsNC0XCJcblx0JHNwYWNlLm9uKCdjbGljaycsICcuYy1jYWxjX19idG5fcHJldicsIGZ1bmN0aW9uKGUpIHtcblx0XHRsZXQgcHJldlN0ZXAgPSAkc3BhY2UuZGF0YSgnc3RlcCcpIC0gMTtcblx0XHRpZiAocHJldlN0ZXAgPCAwKSByZXR1cm47XG5cblx0XHRyZW5kZXJQYWdlKHByZXZTdGVwKTtcblx0fSk7XG5cblx0cmVuZGVyUGFnZSgwKTtcblxufSkoKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/blocks/c-calc/c-calc.js\n");

/***/ }),

/***/ "./src/blocks/c-calc/c-calc.json":
/*!***************************************!*\
  !*** ./src/blocks/c-calc/c-calc.json ***!
  \***************************************/
/*! exports provided: pages, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"pages\\\":{\\\"vop\\\":{\\\"title\\\":\\\"     ()\\\",\\\"rows\\\":{\\\"size\\\":{\\\"square\\\":{\\\"value\\\":1200}},\\\"location\\\":{\\\"city\\\":{},\\\"rough\\\":{},\\\"facility\\\":{},\\\"onwater\\\":{}},\\\"features\\\":{\\\"highland\\\":{},\\\"marshland\\\":{},\\\"forest\\\":{},\\\"permafrost\\\":{}},\\\"additional\\\":{\\\"maintenance\\\":{},\\\"secure\\\":{}}}},\\\"tech\\\":{\\\"title\\\":\\\"    \\\",\\\"rows\\\":{\\\"size\\\":{\\\"title\\\":\\\"   . \\\",\\\"capacity\\\":{\\\"value\\\":1200}},\\\"location\\\":{\\\"residential\\\":{},\\\"facility\\\":{}},\\\"additional\\\":{\\\"maintenance\\\":{},\\\"secure\\\":{},\\\"dangerous\\\":{}}}},\\\"arch\\\":{\\\"title\\\":\\\" \\\",\\\"rows\\\":{\\\"size\\\":{\\\"square\\\":{\\\"value\\\":1200}},\\\"location\\\":{\\\"city\\\":{},\\\"rough\\\":{},\\\"facility\\\":{},\\\"onwater\\\":{}},\\\"features\\\":{\\\"highland\\\":{},\\\"marshland\\\":{},\\\"forest\\\":{},\\\"permafrost\\\":{}},\\\"additional\\\":{\\\"ike\\\":{},\\\"secure\\\":{}}}},\\\"hydromet\\\":{\\\"title\\\":\\\" \\\",\\\"rows\\\":{\\\"size\\\":{\\\"square\\\":{\\\"value\\\":1200}},\\\"location\\\":{\\\"onland\\\":{},\\\"onwater\\\":{},\\\"presence\\\":{}},\\\"additional\\\":{\\\"maintenance\\\":{},\\\"secure\\\":{}}}},\\\"eco\\\":{\\\"title\\\":\\\" \\\",\\\"rows\\\":{\\\"size\\\":{\\\"square\\\":{\\\"value\\\":1200}},\\\"location\\\":{\\\"residential\\\":{},\\\"rough\\\":{},\\\"facility\\\":{},\\\"onwater\\\":{}},\\\"features\\\":{\\\"highland\\\":{},\\\"marshland\\\":{},\\\"forest\\\":{}}}},\\\"geophys\\\":{\\\"title\\\":\\\"- \\\",\\\"rows\\\":{\\\"size\\\":{\\\"square\\\":{\\\"value\\\":1200}},\\\"location\\\":{\\\"city\\\":{},\\\"rough\\\":{},\\\"facility\\\":{},\\\"onwater\\\":{}},\\\"features\\\":{\\\"highland\\\":{},\\\"marshland\\\":{},\\\"forest\\\":{},\\\"permafrost\\\":{},\\\"karst\\\":{}},\\\"additional\\\":{\\\"maintenance\\\":{},\\\"secure\\\":{},\\\"landslide\\\":{}}}},\\\"geodes\\\":{\\\"title\\\":\\\"-  ()\\\",\\\"rows\\\":{\\\"size\\\":{\\\"square\\\":{\\\"value\\\":1200}},\\\"location\\\":{\\\"city\\\":{},\\\"rough\\\":{},\\\"facility\\\":{},\\\"onwater\\\":{}},\\\"features\\\":{\\\"highland\\\":{},\\\"marshland\\\":{},\\\"forest\\\":{},\\\"permafrost\\\":{}},\\\"additional\\\":{\\\"reconciliation\\\":{},\\\"registration\\\":{},\\\"maintenance\\\":{},\\\"secure\\\":{},\\\"tree\\\":{}}}},\\\"geologlinear\\\":{\\\"title\\\":\\\"    \\\",\\\"rows\\\":{\\\"size\\\":{\\\"title\\\":\\\"   .\\\",\\\"square\\\":{\\\"input\\\":\\\"text\\\",\\\"unit\\\":\\\"M\\\",\\\"value\\\":1200}},\\\"seismicity\\\":{\\\"seism\\\":{}},\\\"object\\\":{\\\"vl\\\":{},\\\"vols\\\":{},\\\"road\\\":{},\\\"pipeline\\\":{},\\\"comms\\\":{}},\\\"location\\\":{\\\"city\\\":{},\\\"rough\\\":{},\\\"facility\\\":{},\\\"onwater\\\":{}},\\\"features\\\":{\\\"highland\\\":{},\\\"marshland\\\":{},\\\"forest\\\":{},\\\"permafrost\\\":{}},\\\"additional\\\":{\\\"registration\\\":{},\\\"maintenance\\\":{},\\\"secure\\\":{}}}},\\\"geologsquare\\\":{\\\"title\\\":\\\"    \\\",\\\"rows\\\":{\\\"size\\\":{\\\"title\\\":\\\"   . .\\\",\\\"square\\\":{\\\"input\\\":\\\"text\\\",\\\"unit\\\":\\\"M2\\\",\\\"value\\\":150}},\\\"floors\\\":{\\\"level\\\":{},\\\"basement\\\":{}},\\\"seismicity\\\":{\\\"seism\\\":{\\\"value\\\":9}},\\\"foundation\\\":{\\\"piles\\\":{},\\\"plate\\\":{},\\\"grillage\\\":{},\\\"unknown\\\":{}},\\\"location\\\":{\\\"city\\\":{},\\\"rough\\\":{},\\\"facility\\\":{},\\\"onwater\\\":{}},\\\"features\\\":{\\\"highland\\\":{},\\\"marshland\\\":{},\\\"forest\\\":{},\\\"permafrost\\\":{}},\\\"additional\\\":{\\\"reconciliation\\\":{},\\\"registration\\\":{},\\\"maintenance\\\":{},\\\"secure\\\":{}}}}},\\\"default\\\":{\\\"size\\\":{\\\"required\\\":true,\\\"title\\\":\\\"   \\\",\\\"square\\\":{\\\"input\\\":\\\"text\\\",\\\"unit\\\":\\\"GA\\\"},\\\"capacity\\\":{\\\"input\\\":\\\"text\\\",\\\"unit\\\":\\\"M3\\\"}},\\\"floors\\\":{\\\"required\\\":true,\\\"title\\\":\\\"  \\\",\\\"level\\\":{\\\"input\\\":\\\"text\\\",\\\"value\\\":1},\\\"basement\\\":{\\\"title\\\":\\\"\\\"}},\\\"seismicity\\\":{\\\"required\\\":\\\"\\\",\\\"title\\\":\\\" ( 6  9)\\\",\\\"seism\\\":{\\\"input\\\":\\\"text\\\"}},\\\"foundation\\\":{\\\"required\\\":true,\\\"title\\\":\\\"\\\",\\\"piles\\\":{\\\"title\\\":\\\"\\\"},\\\"plate\\\":{\\\"title\\\":\\\"\\\"},\\\"grillage\\\":{\\\"title\\\":\\\"-\\\"},\\\"unknown\\\":{\\\"title\\\":\\\" \\\"}},\\\"object\\\":{\\\"required\\\":true,\\\"vl\\\":{\\\"title\\\":\\\"\\\"},\\\"vols\\\":{\\\"title\\\":\\\"\\\"},\\\"road\\\":{\\\"title\\\":\\\"\\\"},\\\"pipeline\\\":{\\\"title\\\":\\\"/\\\"},\\\"comms\\\":{\\\"title\\\":\\\"//\\\"}},\\\"location\\\":{\\\"required\\\":true,\\\"title\\\":\\\" \\\",\\\"city\\\":{\\\"title\\\":\\\" \\\"},\\\"rough\\\":{\\\"title\\\":\\\" \\\"},\\\"residential\\\":{\\\"title\\\":\\\" \\\"},\\\"facility\\\":{\\\"title\\\":\\\" \\\"},\\\"onland\\\":{\\\"title\\\":\\\"  \\\"},\\\"onwater\\\":{\\\"title\\\":\\\"\\\"},\\\"presence\\\":{\\\"title\\\":\\\"      (/)\\\"}},\\\"features\\\":{\\\"required\\\":\\\"\\\",\\\"title\\\":\\\" \\\",\\\"highland\\\":{\\\"title\\\":\\\"\\\"},\\\"marshland\\\":{\\\"title\\\":\\\"\\\"},\\\"forest\\\":{\\\"title\\\":\\\"\\\"},\\\"permafrost\\\":{\\\"title\\\":\\\" \\\"},\\\"karst\\\":{\\\"title\\\":\\\"\\\"}},\\\"additional\\\":{\\\"required\\\":\\\"\\\",\\\"title\\\":\\\" \\\",\\\"reconciliation\\\":{\\\"title\\\":\\\" \\\"},\\\"registration\\\":{\\\"title\\\":\\\"   \\\"},\\\"maintenance\\\":{\\\"title\\\":\\\"C   \\\"},\\\"dangerous\\\":{\\\"title\\\":\\\" \\\"},\\\"secure\\\":{\\\"title\\\":\\\" \\\"},\\\"tree\\\":{\\\"title\\\":\\\" \\\"},\\\"landslide\\\":{\\\"title\\\":\\\"\\\"},\\\"ike\\\":{\\\"title\\\":\\\" \\\"}}}}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIuL3NyYy9ibG9ja3MvYy1jYWxjL2MtY2FsYy5qc29uLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/blocks/c-calc/c-calc.json\n");

/***/ }),

/***/ "./src/blocks/cm-catalog/cm-catalog.js":
/*!*********************************************!*\
  !*** ./src/blocks/cm-catalog/cm-catalog.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function () {\n  $('.cm-catalog__items').on({\n    mouseenter: function mouseenter() {\n      var $self = $(this);\n      $self.height($self.find(':first-child').outerHeight()).addClass('hover');\n    },\n    mouseleave: function mouseleave() {\n      $(this).removeAttr('style').removeClass('hover');\n    }\n  }, '.cm-catalog__item');\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmxvY2tzL2NtLWNhdGFsb2cvY20tY2F0YWxvZy5qcz85NTQ3Il0sIm5hbWVzIjpbIiQiLCJvbiIsIm1vdXNlZW50ZXIiLCIkc2VsZiIsImhlaWdodCIsImZpbmQiLCJvdXRlckhlaWdodCIsImFkZENsYXNzIiwibW91c2VsZWF2ZSIsInJlbW92ZUF0dHIiLCJyZW1vdmVDbGFzcyJdLCJtYXBwaW5ncyI6IkFBQUEsQ0FBQyxZQUFNO0FBRU5BLEdBQUMsQ0FBQyxvQkFBRCxDQUFELENBQXdCQyxFQUF4QixDQUEyQjtBQUMxQkMsY0FBVSxFQUFFLHNCQUFXO0FBQ3RCLFVBQUlDLEtBQUssR0FBR0gsQ0FBQyxDQUFDLElBQUQsQ0FBYjtBQUNBRyxXQUFLLENBQ0hDLE1BREYsQ0FDU0QsS0FBSyxDQUFDRSxJQUFOLENBQVcsY0FBWCxFQUEyQkMsV0FBM0IsRUFEVCxFQUVFQyxRQUZGLENBRVcsT0FGWDtBQUdBLEtBTnlCO0FBTzFCQyxjQUFVLEVBQUUsc0JBQVc7QUFDdEJSLE9BQUMsQ0FBQyxJQUFELENBQUQsQ0FDRVMsVUFERixDQUNhLE9BRGIsRUFFRUMsV0FGRixDQUVjLE9BRmQ7QUFHQTtBQVh5QixHQUEzQixFQVlHLG1CQVpIO0FBY0EsQ0FoQkQiLCJmaWxlIjoiLi9zcmMvYmxvY2tzL2NtLWNhdGFsb2cvY20tY2F0YWxvZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIigoKSA9PiB7XG5cblx0JCgnLmNtLWNhdGFsb2dfX2l0ZW1zJykub24oe1xuXHRcdG1vdXNlZW50ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0bGV0ICRzZWxmID0gJCh0aGlzKTtcblx0XHRcdCRzZWxmXG5cdFx0XHRcdC5oZWlnaHQoJHNlbGYuZmluZCgnOmZpcnN0LWNoaWxkJykub3V0ZXJIZWlnaHQoKSlcblx0XHRcdFx0LmFkZENsYXNzKCdob3ZlcicpO1xuXHRcdH0sXG5cdFx0bW91c2VsZWF2ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHQkKHRoaXMpXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCdzdHlsZScpXG5cdFx0XHRcdC5yZW1vdmVDbGFzcygnaG92ZXInKTtcblx0XHR9XG5cdH0sICcuY20tY2F0YWxvZ19faXRlbScpO1xuXG59KSgpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/blocks/cm-catalog/cm-catalog.js\n");

/***/ }),

/***/ "./src/blocks/datepicker/datepicker.js":
/*!*********************************************!*\
  !*** ./src/blocks/datepicker/datepicker.js ***!
  \*********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var air_datepicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! air-datepicker */ \"./node_modules/air-datepicker/src/js/air-datepicker.js\");\n/* harmony import */ var air_datepicker__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(air_datepicker__WEBPACK_IMPORTED_MODULE_0__);\n\n\n(function () {// $('.datepicker-here').data({ inline: true });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmxvY2tzL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5qcz8wMTExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBLENBQUMsWUFBTSxDQUNOO0FBRUEsQ0FIRCIsImZpbGUiOiIuL3NyYy9ibG9ja3MvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRhdGVwaWNrZXIgZnJvbSBcImFpci1kYXRlcGlja2VyXCI7XHJcblxyXG4oKCkgPT4ge1xyXG5cdC8vICQoJy5kYXRlcGlja2VyLWhlcmUnKS5kYXRhKHsgaW5saW5lOiB0cnVlIH0pO1xyXG5cclxufSkoKTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/blocks/datepicker/datepicker.js\n");

/***/ }),

/***/ "./src/blocks/f-form/f-form.js":
/*!*************************************!*\
  !*** ./src/blocks/f-form/f-form.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/lib */ \"./src/js/lib.js\");\n/* harmony import */ var inputmask__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! inputmask */ \"./node_modules/inputmask/dist/inputmask.js\");\n/* harmony import */ var inputmask__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(inputmask__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n(function () {\n  Object(_js_lib__WEBPACK_IMPORTED_MODULE_0__[\"selectTweaker\"])(document.querySelectorAll('.f-form__select'));\n  inputmask__WEBPACK_IMPORTED_MODULE_1___default()({\n    \"mask\": \"+7 (999) 999-99-99\",\n    showMaskOnHover: false\n  }).mask(document.querySelectorAll('input[type=\"tel\"]'));\n  $('.f-form__checkbox_toggle').on('change', function (e) {\n    return $('.f-form__citizenship').toggle();\n  });\n  $('.f-form__file').on('change', 'input[type=\"file\"]', function (e) {\n    var $self = $(this);\n    var $label = $self.next('span');\n    var $wrapper = $self.parent('.f-form__file');\n\n    if (!!$self.val()) {\n      $label.text($self[0].files[0].name);\n      $wrapper.addClass('f-form__file_selected');\n    } else {\n      $label.text('');\n      $wrapper.removeClass('f-form__file_selected');\n    }\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmxvY2tzL2YtZm9ybS9mLWZvcm0uanM/MDMwNyJdLCJuYW1lcyI6WyJzZWxlY3RUd2Vha2VyIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiSW5wdXRtYXNrIiwic2hvd01hc2tPbkhvdmVyIiwibWFzayIsIiQiLCJvbiIsImUiLCJ0b2dnbGUiLCIkc2VsZiIsIiRsYWJlbCIsIm5leHQiLCIkd3JhcHBlciIsInBhcmVudCIsInZhbCIsInRleHQiLCJmaWxlcyIsIm5hbWUiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUEsQ0FBQyxZQUFNO0FBQ05BLCtEQUFhLENBQUNDLFFBQVEsQ0FBQ0MsZ0JBQVQsQ0FBMEIsaUJBQTFCLENBQUQsQ0FBYjtBQUVBQyxrREFBUyxDQUFDO0FBQ1QsWUFBUSxvQkFEQztBQUVUQyxtQkFBZSxFQUFFO0FBRlIsR0FBRCxDQUFULENBR0dDLElBSEgsQ0FHUUosUUFBUSxDQUFDQyxnQkFBVCxDQUEwQixtQkFBMUIsQ0FIUjtBQUtBSSxHQUFDLENBQUMsMEJBQUQsQ0FBRCxDQUE4QkMsRUFBOUIsQ0FBaUMsUUFBakMsRUFBMkMsVUFBQ0MsQ0FBRDtBQUFBLFdBQU9GLENBQUMsQ0FBQyxzQkFBRCxDQUFELENBQTBCRyxNQUExQixFQUFQO0FBQUEsR0FBM0M7QUFFQUgsR0FBQyxDQUFDLGVBQUQsQ0FBRCxDQUFtQkMsRUFBbkIsQ0FBc0IsUUFBdEIsRUFBZ0Msb0JBQWhDLEVBQXNELFVBQVNDLENBQVQsRUFBWTtBQUNqRSxRQUFJRSxLQUFLLEdBQUdKLENBQUMsQ0FBQyxJQUFELENBQWI7QUFDQSxRQUFJSyxNQUFNLEdBQUdELEtBQUssQ0FBQ0UsSUFBTixDQUFXLE1BQVgsQ0FBYjtBQUNBLFFBQUlDLFFBQVEsR0FBR0gsS0FBSyxDQUFDSSxNQUFOLENBQWEsZUFBYixDQUFmOztBQUVBLFFBQUksQ0FBQyxDQUFFSixLQUFLLENBQUNLLEdBQU4sRUFBUCxFQUFvQjtBQUNuQkosWUFBTSxDQUFDSyxJQUFQLENBQVlOLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU08sS0FBVCxDQUFlLENBQWYsRUFBa0JDLElBQTlCO0FBQ0FMLGNBQVEsQ0FBQ00sUUFBVCxDQUFrQix1QkFBbEI7QUFDQSxLQUhELE1BR087QUFDTlIsWUFBTSxDQUFDSyxJQUFQLENBQVksV0FBWjtBQUNBSCxjQUFRLENBQUNPLFdBQVQsQ0FBcUIsdUJBQXJCO0FBQ0E7QUFDRCxHQVpEO0FBY0EsQ0F4QkQiLCJmaWxlIjoiLi9zcmMvYmxvY2tzL2YtZm9ybS9mLWZvcm0uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZWxlY3RUd2Vha2VyIH0gZnJvbSBcIi4uLy4uL2pzL2xpYlwiO1xuaW1wb3J0IElucHV0bWFzayBmcm9tIFwiaW5wdXRtYXNrXCI7XG5cbigoKSA9PiB7XG5cdHNlbGVjdFR3ZWFrZXIoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmYtZm9ybV9fc2VsZWN0JykpO1xuXG5cdElucHV0bWFzayh7XG5cdFx0XCJtYXNrXCI6IFwiKzcgKDk5OSkgOTk5LTk5LTk5XCIsIFxuXHRcdHNob3dNYXNrT25Ib3ZlcjogZmFsc2Vcblx0fSkubWFzayhkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwidGVsXCJdJykpO1xuXG5cdCQoJy5mLWZvcm1fX2NoZWNrYm94X3RvZ2dsZScpLm9uKCdjaGFuZ2UnLCAoZSkgPT4gJCgnLmYtZm9ybV9fY2l0aXplbnNoaXAnKS50b2dnbGUoKSk7XG5cblx0JCgnLmYtZm9ybV9fZmlsZScpLm9uKCdjaGFuZ2UnLCAnaW5wdXRbdHlwZT1cImZpbGVcIl0nLCBmdW5jdGlvbihlKSB7XG5cdFx0bGV0ICRzZWxmID0gJCh0aGlzKTtcblx0XHRsZXQgJGxhYmVsID0gJHNlbGYubmV4dCgnc3BhbicpO1xuXHRcdGxldCAkd3JhcHBlciA9ICRzZWxmLnBhcmVudCgnLmYtZm9ybV9fZmlsZScpO1xuXG5cdFx0aWYgKCEhICRzZWxmLnZhbCgpKSB7XG5cdFx0XHQkbGFiZWwudGV4dCgkc2VsZlswXS5maWxlc1swXS5uYW1lKTtcblx0XHRcdCR3cmFwcGVyLmFkZENsYXNzKCdmLWZvcm1fX2ZpbGVfc2VsZWN0ZWQnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0JGxhYmVsLnRleHQoJ9CX0LDQs9GA0YPQt9C40YLRjCcpO1xuXHRcdFx0JHdyYXBwZXIucmVtb3ZlQ2xhc3MoJ2YtZm9ybV9fZmlsZV9zZWxlY3RlZCcpO1xuXHRcdH1cblx0fSk7XG5cbn0pKCk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/blocks/f-form/f-form.js\n");

/***/ }),

/***/ "./src/blocks/m-quiz/m-quiz.js":
/*!*************************************!*\
  !*** ./src/blocks/m-quiz/m-quiz.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _m_quiz_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m-quiz.json */ \"./src/blocks/m-quiz/m-quiz.json\");\nvar _m_quiz_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ./m-quiz.json */ \"./src/blocks/m-quiz/m-quiz.json\", 1);\n\n\n(function () {\n  var $quiz = $('#m-quiz');\n  var $step = $('.m-page__top-left span');\n  var numeral = $step.data(\"numeral\");\n  var $page = $quiz.find('.m-page__content');\n  var $results = $quiz.find('.m-results');\n  var $submit = $quiz.find('.m-quiz__btn_submit');\n  var $next = $quiz.find('.m-quiz__btn_next');\n  var $prev = $quiz.find('.m-quiz__btn_prev');\n  var results = {};\n  var comments = {};\n  if (!$quiz.length) return; //    \n\n  var renderPage = function renderPage(index) {\n    var _comments$index;\n\n    $quiz.data('step', index); //   \n\n    var left = _m_quiz_json__WEBPACK_IMPORTED_MODULE_0__.length + 1 - index; // \n\n    var getChecked = function getChecked(id) {\n      var _results$index;\n\n      return (_results$index = results[index]) !== null && _results$index !== void 0 && _results$index.includes(id) ? 'checked' : '';\n    };\n\n    var renderAnswers = function renderAnswers() {\n      return _m_quiz_json__WEBPACK_IMPORTED_MODULE_0__[index].answers.map(function (answer, id) {\n        var _DATA$index$type;\n\n        return \"<label>\\n\\t\\t\\t\\t\\t<input type=\\\"\".concat((_DATA$index$type = _m_quiz_json__WEBPACK_IMPORTED_MODULE_0__[index].type) !== null && _DATA$index$type !== void 0 ? _DATA$index$type : 'checkbox', \"\\\" name=\\\"\").concat(index, \"\\\" value=\\\"\").concat(id, \"\\\" \").concat(getChecked(id), \">\\n\\t\\t\\t\\t\\t<span>\").concat(answer, \"</span>\\n\\t\\t\\t\\t</label>\");\n      }).join('');\n    };\n\n    $page.html(\"\\n\\t\\t\\t<h4 class=\\\"m-page__question\\\">\".concat(_m_quiz_json__WEBPACK_IMPORTED_MODULE_0__[index].question, \"</h4>\\n\\t\\t\\t<div class=\\\"m-page__answers\\\">\").concat(renderAnswers(), \"</div>\\n\\t\\t\\t<input class=\\\"m-page__comment\\\" type=\\\"text\\\" name=\\\"\").concat(index, \"\\\" value=\\\"\").concat((_comments$index = comments[index]) !== null && _comments$index !== void 0 ? _comments$index : '', \"\\\" placeholder=\\\"\\u041A\\u043E\\u043C\\u043C\\u0435\\u043D\\u0442\\u0430\\u0440\\u0438\\u0439\\\">\\n\\t\\t\")); //      \n\n    $step.text(\"\".concat(left, \" \").concat(declOfNum(left, numeral))); //  \n\n    $next.prop('disabled', Boolean(!results[index] || !results[index].length)).add($page).add($results).add($next).add($submit).removeAttr('style'); //   \"\"   \n\n    if (!index) $prev.removeAttr('style');\n  }; //    \n\n\n  var processingResults = function processingResults() {\n    $quiz.data('step', _m_quiz_json__WEBPACK_IMPORTED_MODULE_0__.length);\n    var content = '<table cellpadding=\"0\" cellspacing=\"0\" border=\"1\" style=\"border-collapse: collapse; border: 1px solid #aaaaaa; width: 100%;\">'; //          \n\n    var getAnswers = function getAnswers(index) {\n      return results[index].map(function (result) {\n        return \"\".concat(_m_quiz_json__WEBPACK_IMPORTED_MODULE_0__[index].answers[result], \"</br>\");\n      }).join('');\n    };\n\n    _m_quiz_json__WEBPACK_IMPORTED_MODULE_0__.forEach(function (item, index) {\n      var style = \"style=\\\"padding: 5px; \".concat(index % 2 ? '' : 'background-color: #e2e2e2', \"\\\"\");\n      content += \"<tr>\\n\\t\\t\\t\\t\\t<td \".concat(style, \">\").concat(item.question, \"</td>\\n\\t\\t\\t\\t\\t<td \").concat(style, \">\").concat(getAnswers(index), \"</td>\\n\\t\\t\\t\\t</tr>\");\n      if (comments[index]) content += \"<tr><td colspan=\\\"2\\\" \".concat(style, \">\").concat(comments[index], \"</td></tr>\");\n    });\n    content += '</table>'; //      \n\n    $step.text(\"1 \".concat(declOfNum(1, numeral))); //   \n\n    $results.find('.m-results__data').html(content).end().add($page.html('')).add($next).add($submit).toggle();\n  }; //   \n\n\n  $quiz.on('change', 'input', function (e) {\n    var $shell = $(this).parents('.m-page__content');\n    results[e.target.name] = [];\n    $shell.find('input:checked').each(function (index, el) {\n      results[e.target.name].push(Number(el.value));\n    });\n    comments[e.target.name] = $shell.find('input:text').val();\n    $next.prop('disabled', Boolean(!results[e.target.name].length));\n  }); //   \"\"\n\n  $quiz.on('click', '.m-quiz__btn_next', function (e) {\n    var nextStep = $quiz.data('step') + 1;\n\n    if (_m_quiz_json__WEBPACK_IMPORTED_MODULE_0__.length <= nextStep) {\n      processingResults();\n    } else {\n      $prev.show();\n      renderPage(nextStep);\n    }\n  }); //   \"\"\n\n  $quiz.on('click', '.m-quiz__btn_prev', function (e) {\n    var prevStep = $quiz.data('step') - 1;\n    if (prevStep < 0) return;\n    renderPage(prevStep);\n  }); //   ( ,  ,    )\n\n  $submit.on('click', function (e) {\n    e.preventDefault();\n    $quiz.find('#m-form input.m-form__submit[type=\"submit\"]').trigger('click');\n  }); //  \t\n\n  var declOfNum = function declOfNum(n, data) {\n    if (!data) {\n      return '';\n    }\n\n    ;\n    var text_forms = data.split(\",\");\n    n = Math.abs(n) % 100;\n    var n1 = n % 10;\n\n    if (n > 10 && n < 20) {\n      return text_forms[2].trim();\n    }\n\n    if (n1 > 1 && n1 < 5) {\n      return text_forms[1].trim();\n    }\n\n    if (n1 == 1) {\n      return text_forms[0].trim();\n    }\n\n    return text_forms[2].trim();\n  }; //  ,   \n\n\n  renderPage(0); //   \n\n  $quiz.on('submit', '#m-form', function (e) {\n    e.preventDefault();\n    var $form = $(this);\n    var formdata = new FormData($form[0]);\n    var $elements = $form.find('input, textarea').add('.m-quiz__btn_prev').add('.m-quiz__btn_submit');\n    formdata.set('m-quiz', $form.find('.m-results__data').html());\n    $elements.prop(\"disabled\", true);\n    $.ajax({\n      type: 'post',\n      url: 'mailto.php',\n      //     ( PHPMailer)\n      data: formdata,\n      processData: false,\n      contentType: false\n    }).done(function (response) {\n      var data = JSON.parse(response);\n      $tmp = $form.children().detach();\n\n      if (data.status == 'error') {\n        $form.append(\"<div class=\\\"m-form__echo m-form__echo_error\\\">\".concat(data.text, \"</div>\"));\n        setTimeout(function () {\n          $form.children().remove();\n          $form.append($tmp);\n          $elements.prop(\"disabled\", false);\n        }, 2000);\n      } else {\n        $form.append(\"<div class=\\\"m-form__echo m-form__echo_success\\\">\".concat(data.text, \"</div>\"));\n      }\n    });\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmxvY2tzL20tcXVpei9tLXF1aXouanM/YmQ2ZSJdLCJuYW1lcyI6WyIkcXVpeiIsIiQiLCIkc3RlcCIsIm51bWVyYWwiLCJkYXRhIiwiJHBhZ2UiLCJmaW5kIiwiJHJlc3VsdHMiLCIkc3VibWl0IiwiJG5leHQiLCIkcHJldiIsInJlc3VsdHMiLCJjb21tZW50cyIsImxlbmd0aCIsInJlbmRlclBhZ2UiLCJpbmRleCIsImxlZnQiLCJEQVRBIiwiZ2V0Q2hlY2tlZCIsImlkIiwiaW5jbHVkZXMiLCJyZW5kZXJBbnN3ZXJzIiwiYW5zd2VycyIsIm1hcCIsImFuc3dlciIsInR5cGUiLCJqb2luIiwiaHRtbCIsInF1ZXN0aW9uIiwidGV4dCIsImRlY2xPZk51bSIsInByb3AiLCJCb29sZWFuIiwiYWRkIiwicmVtb3ZlQXR0ciIsInByb2Nlc3NpbmdSZXN1bHRzIiwiY29udGVudCIsImdldEFuc3dlcnMiLCJyZXN1bHQiLCJmb3JFYWNoIiwiaXRlbSIsInN0eWxlIiwiZW5kIiwidG9nZ2xlIiwib24iLCJlIiwiJHNoZWxsIiwicGFyZW50cyIsInRhcmdldCIsIm5hbWUiLCJlYWNoIiwiZWwiLCJwdXNoIiwiTnVtYmVyIiwidmFsdWUiLCJ2YWwiLCJuZXh0U3RlcCIsInNob3ciLCJwcmV2U3RlcCIsInByZXZlbnREZWZhdWx0IiwidHJpZ2dlciIsIm4iLCJ0ZXh0X2Zvcm1zIiwic3BsaXQiLCJNYXRoIiwiYWJzIiwibjEiLCJ0cmltIiwiJGZvcm0iLCJmb3JtZGF0YSIsIkZvcm1EYXRhIiwiJGVsZW1lbnRzIiwic2V0IiwiYWpheCIsInVybCIsInByb2Nlc3NEYXRhIiwiY29udGVudFR5cGUiLCJkb25lIiwicmVzcG9uc2UiLCJKU09OIiwicGFyc2UiLCIkdG1wIiwiY2hpbGRyZW4iLCJkZXRhY2giLCJzdGF0dXMiLCJhcHBlbmQiLCJzZXRUaW1lb3V0IiwicmVtb3ZlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTs7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QUkxRSxJQUFJLEdBQUcyRSxJQUFJLENBQUNDLEtBQUwsQ0FBV0YsUUFBWCxDQUFYO0FBQ0FHLFVBQUksR0FBR2IsS0FBSyxDQUFDYyxRQUFOLEdBQWlCQyxNQUFqQixFQUFQOztBQUVBLFVBQUcvRSxJQUFJLENBQUNnRixNQUFMLElBQWEsT0FBaEIsRUFBeUI7QUFDeEJoQixhQUFLLENBQUNpQixNQUFOLDBEQUE2RGpGLElBQUksQ0FBQ3lCLElBQWxFO0FBRUF5RCxrQkFBVSxDQUFDLFlBQVc7QUFDckJsQixlQUFLLENBQUNjLFFBQU4sR0FBaUJLLE1BQWpCO0FBQ0FuQixlQUFLLENBQUNpQixNQUFOLENBQWFKLElBQWI7QUFDQVYsbUJBQVMsQ0FBQ3hDLElBQVYsQ0FBZSxVQUFmLEVBQTJCLEtBQTNCO0FBQ0EsU0FKUyxFQUlQLElBSk8sQ0FBVjtBQU1BLE9BVEQsTUFTTztBQUNOcUMsYUFBSyxDQUFDaUIsTUFBTiw0REFBK0RqRixJQUFJLENBQUN5QixJQUFwRTtBQUNBO0FBQ0QsS0F0QkQ7QUF1QkEsR0FwQ0Q7QUFzQ0EsQ0F4TUQiLCJmaWxlIjoiLi9zcmMvYmxvY2tzL20tcXVpei9tLXF1aXouanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgREFUQSBmcm9tICcuL20tcXVpei5qc29uJztcblxuKCgpID0+IHtcblxuXHRjb25zdCAkcXVpeiA9ICQoJyNtLXF1aXonKTtcblx0Y29uc3QgJHN0ZXAgPSAkKCcubS1wYWdlX190b3AtbGVmdCBzcGFuJyk7XG5cdGNvbnN0IG51bWVyYWwgPSAkc3RlcC5kYXRhKFwibnVtZXJhbFwiKVxuXHRjb25zdCAkcGFnZSA9ICRxdWl6LmZpbmQoJy5tLXBhZ2VfX2NvbnRlbnQnKTtcblx0Y29uc3QgJHJlc3VsdHMgPSAkcXVpei5maW5kKCcubS1yZXN1bHRzJyk7XG5cdGNvbnN0ICRzdWJtaXQgPSAkcXVpei5maW5kKCcubS1xdWl6X19idG5fc3VibWl0Jyk7XG5cdGNvbnN0ICRuZXh0ID0gJHF1aXouZmluZCgnLm0tcXVpel9fYnRuX25leHQnKTtcblx0Y29uc3QgJHByZXYgPSAkcXVpei5maW5kKCcubS1xdWl6X19idG5fcHJldicpO1xuXHRsZXQgcmVzdWx0cyA9IHt9O1xuXHRsZXQgY29tbWVudHMgPSB7fTtcblxuXHRpZiAoISRxdWl6Lmxlbmd0aCkgcmV0dXJuO1xuXG5cblx0Ly8g0L7RgtGA0LjRgdC+0LLQutCwINGC0LXQutGD0YnQtdCz0L4g0LHQu9C+0LrQsCDQstC+0L/RgNC+0YHQvtCyXG5cdGNvbnN0IHJlbmRlclBhZ2UgPSAoaW5kZXgpID0+IHtcblx0XHQkcXVpei5kYXRhKCdzdGVwJywgaW5kZXgpO1xuXHRcdFxuXHRcdC8vINC60L7Qu9C40YfQtdGB0YLQstC+INC+0YHRgtCw0LLRiNC40YXRgdGPINGI0LDQs9C+0LJcblx0XHRjb25zdCBsZWZ0ID0gKERBVEEubGVuZ3RoICsgMSkgLSBpbmRleDtcblx0XHRcdFx0XG5cdFx0Ly8g0L7RgtGA0LjRgdC+0LLQutCwXG5cdFx0Y29uc3QgZ2V0Q2hlY2tlZCA9IChpZCkgPT4gcmVzdWx0c1tpbmRleF0/LmluY2x1ZGVzKGlkKSA/ICdjaGVja2VkJyA6ICcnO1xuXG5cdFx0Y29uc3QgcmVuZGVyQW5zd2VycyA9ICgpID0+IERBVEFbaW5kZXhdLmFuc3dlcnNcblx0XHRcdC5tYXAoKGFuc3dlciwgaWQpID0+XG5cdFx0XHRcdGA8bGFiZWw+XG5cdFx0XHRcdFx0PGlucHV0IHR5cGU9XCIke0RBVEFbaW5kZXhdLnR5cGUgPz8gJ2NoZWNrYm94J31cIiBuYW1lPVwiJHtpbmRleH1cIiB2YWx1ZT1cIiR7aWR9XCIgJHtnZXRDaGVja2VkKGlkKX0+XG5cdFx0XHRcdFx0PHNwYW4+JHthbnN3ZXJ9PC9zcGFuPlxuXHRcdFx0XHQ8L2xhYmVsPmBcblx0XHRcdCkuam9pbignJyk7XG5cblx0XHQkcGFnZS5odG1sKGBcblx0XHRcdDxoNCBjbGFzcz1cIm0tcGFnZV9fcXVlc3Rpb25cIj4ke0RBVEFbaW5kZXhdLnF1ZXN0aW9ufTwvaDQ+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwibS1wYWdlX19hbnN3ZXJzXCI+JHtyZW5kZXJBbnN3ZXJzKCl9PC9kaXY+XG5cdFx0XHQ8aW5wdXQgY2xhc3M9XCJtLXBhZ2VfX2NvbW1lbnRcIiB0eXBlPVwidGV4dFwiIG5hbWU9XCIke2luZGV4fVwiIHZhbHVlPVwiJHtjb21tZW50c1tpbmRleF0gPz8gJyd9XCIgcGxhY2Vob2xkZXI9XCLQmtC+0LzQvNC10L3RgtCw0YDQuNC5XCI+XG5cdFx0YCk7XG5cblx0XHQvLyDQv9C+0LTRgdGC0LDQstC40YLRjCDQutC+0LvQuNGH0LXRgdGC0LLQviDRiNCw0LPQvtCyINCyINGI0LDQv9C60YMg0LHQu9C+0LrQsFxuXHRcdCRzdGVwLnRleHQoYCR7bGVmdH0gJHtkZWNsT2ZOdW0obGVmdCwgbnVtZXJhbCl9YCk7XG5cblx0XHQvLyDRgdCx0YDQvtGBINGN0LvQtdC80LXQvdGC0L7QslxuXHRcdCRuZXh0XG5cdFx0XHQucHJvcCgnZGlzYWJsZWQnLCBCb29sZWFuKCFyZXN1bHRzW2luZGV4XSB8fCAhcmVzdWx0c1tpbmRleF0ubGVuZ3RoKSlcblx0XHRcdC5hZGQoJHBhZ2UpXG5cdFx0XHQuYWRkKCRyZXN1bHRzKVxuXHRcdFx0LmFkZCgkbmV4dClcblx0XHRcdC5hZGQoJHN1Ym1pdClcblx0XHRcdC5yZW1vdmVBdHRyKCdzdHlsZScpO1xuXG5cdFx0Ly8g0YPQsdGA0LDRgtGMINC60L3QvtC/0LrRgyBcItC90LDQt9Cw0LRcIiDQvdCwINC/0LXRgNCy0L7QuSDRgdGC0YDQsNC90LjRh9C60LVcblx0XHRpZiAoIWluZGV4KSAkcHJldi5yZW1vdmVBdHRyKCdzdHlsZScpO1xuXHR9O1xuXG5cblx0Ly8g0YTQvtGA0LzQuNGA0L7QstCw0L3QuNC1INGA0LXQt9GD0LvRjNGC0LDRgtC+0LIg0LTQu9GPINC+0YLQv9GA0LDQstC60Lhcblx0Y29uc3QgcHJvY2Vzc2luZ1Jlc3VsdHMgPSAoKSA9PiB7XG5cdFx0JHF1aXouZGF0YSgnc3RlcCcsIERBVEEubGVuZ3RoKTtcblx0XHRsZXQgY29udGVudCA9ICc8dGFibGUgY2VsbHBhZGRpbmc9XCIwXCIgY2VsbHNwYWNpbmc9XCIwXCIgYm9yZGVyPVwiMVwiIHN0eWxlPVwiYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTsgYm9yZGVyOiAxcHggc29saWQgI2FhYWFhYTsgd2lkdGg6IDEwMCU7XCI+JztcblxuXHRcdC8vINGE0L7RgNC80LDRgtC40YDQvtCy0LDQvdC40LUg0YDQtdC30YPQu9GM0YLQsNGC0L7QsiDQsiDQstC40LTQtSDRgtCw0LHQu9C40YbRiyDQtNC70Y8g0L7RgtC+0LHRgNCw0LbQtdC90LjRjyDQsiDRgtC10LvQtSDQv9C40YHRjNC80LBcblx0XHRjb25zdCBnZXRBbnN3ZXJzID0gKGluZGV4KSA9PiByZXN1bHRzW2luZGV4XVxuXHRcdFx0Lm1hcCgocmVzdWx0KSA9PiBgJHtEQVRBW2luZGV4XS5hbnN3ZXJzW3Jlc3VsdF19PC9icj5gKVxuXHRcdFx0LmpvaW4oJycpO1xuXG5cdFx0REFUQS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuXHRcdFx0bGV0IHN0eWxlID0gYHN0eWxlPVwicGFkZGluZzogNXB4OyAkeyhpbmRleCAlIDIpID8gJyc6J2JhY2tncm91bmQtY29sb3I6ICNlMmUyZTInfVwiYDtcblxuXHRcdFx0Y29udGVudCArPSBcblx0XHRcdFx0YDx0cj5cblx0XHRcdFx0XHQ8dGQgJHtzdHlsZX0+JHtpdGVtLnF1ZXN0aW9ufTwvdGQ+XG5cdFx0XHRcdFx0PHRkICR7c3R5bGV9PiR7Z2V0QW5zd2VycyhpbmRleCl9PC90ZD5cblx0XHRcdFx0PC90cj5gXG5cblx0XHRcdGlmIChjb21tZW50c1tpbmRleF0pXG5cdFx0XHRcdGNvbnRlbnQgKz0gYDx0cj48dGQgY29sc3Bhbj1cIjJcIiAke3N0eWxlfT4ke2NvbW1lbnRzW2luZGV4XX08L3RkPjwvdHI+YDtcblx0XHRcdFx0XG5cdFx0fSk7XG5cdFx0Y29udGVudCArPSAnPC90YWJsZT4nO1xuXG5cdFx0Ly8g0L/QvtC00YHRgtCw0LLQuNGC0Ywg0LrQvtC70LjRh9C10YHRgtCy0L4g0YjQsNCz0L7QsiDQsiDRiNCw0L/QutGDINCx0LvQvtC60LBcblx0XHQkc3RlcC50ZXh0KGAxICR7ZGVjbE9mTnVtKDEsIG51bWVyYWwpfWApO1xuXG5cdFx0Ly8g0L/QtdGA0LXQutC70Y7Rh9C10L3QuNC1INCy0LjQtNC40LzQvtGB0YLQuCDRjdC70LXQvNC10L3RgtC+0LJcblx0XHQkcmVzdWx0c1xuXHRcdFx0LmZpbmQoJy5tLXJlc3VsdHNfX2RhdGEnKVxuXHRcdFx0Lmh0bWwoY29udGVudClcblx0XHRcdC5lbmQoKVxuXHRcdFx0LmFkZCgkcGFnZS5odG1sKCcnKSlcblx0XHRcdC5hZGQoJG5leHQpXG5cdFx0XHQuYWRkKCRzdWJtaXQpXG5cdFx0XHQudG9nZ2xlKCk7XG5cdH07XG5cblxuXHQvLyDQvtCx0YDQsNCx0L7RgtGH0LjQuiDQstGL0LHQvtGA0LAg0L7RgtCy0LXRgtCwXG5cdCRxdWl6Lm9uKCdjaGFuZ2UnLCAnaW5wdXQnLCBmdW5jdGlvbihlKSB7XG5cdFx0Y29uc3QgJHNoZWxsID0gJCh0aGlzKS5wYXJlbnRzKCcubS1wYWdlX19jb250ZW50Jyk7XG5cdFx0cmVzdWx0c1tlLnRhcmdldC5uYW1lXSA9IFtdO1xuXG5cdFx0JHNoZWxsXG5cdFx0XHQuZmluZCgnaW5wdXQ6Y2hlY2tlZCcpXG5cdFx0XHQuZWFjaChmdW5jdGlvbihpbmRleCwgZWwpe1xuXHRcdFx0XHRyZXN1bHRzW2UudGFyZ2V0Lm5hbWVdLnB1c2goTnVtYmVyKGVsLnZhbHVlKSk7XG5cdFx0XHR9KTtcblxuXHRcdGNvbW1lbnRzW2UudGFyZ2V0Lm5hbWVdID0gJHNoZWxsLmZpbmQoJ2lucHV0OnRleHQnKS52YWwoKTtcblx0XHQkbmV4dC5wcm9wKCdkaXNhYmxlZCcsIEJvb2xlYW4oIXJlc3VsdHNbZS50YXJnZXQubmFtZV0ubGVuZ3RoKSk7XG5cdH0pO1xuXG5cblx0Ly8g0L7QsdGA0LDQsdC+0YLRh9C40Log0LrQvdC+0L/QutC4IFwi0LTQsNC70LXQtVwiXG5cdCRxdWl6Lm9uKCdjbGljaycsICcubS1xdWl6X19idG5fbmV4dCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRjb25zdCBuZXh0U3RlcCA9ICRxdWl6LmRhdGEoJ3N0ZXAnKSArIDE7XG5cblx0XHRpZiAoREFUQS5sZW5ndGggPD0gbmV4dFN0ZXApIHtcblx0XHRcdHByb2Nlc3NpbmdSZXN1bHRzKCk7XHRcdFx0XG5cdFx0fSBlbHNlIHtcblx0XHRcdCRwcmV2LnNob3coKTtcblx0XHRcdHJlbmRlclBhZ2UobmV4dFN0ZXApO1xuXHRcdH1cblx0fSk7XG5cblxuXHQvLyDQvtCx0YDQsNCx0L7RgtGH0LjQuiDQutC90L7Qv9C60LggXCLQvdCw0LfQsNC0XCJcblx0JHF1aXoub24oJ2NsaWNrJywgJy5tLXF1aXpfX2J0bl9wcmV2JywgZnVuY3Rpb24oZSkge1xuXHRcdGxldCBwcmV2U3RlcCA9ICRxdWl6LmRhdGEoJ3N0ZXAnKSAtIDE7XG5cdFx0aWYgKHByZXZTdGVwIDwgMCkgcmV0dXJuO1xuXG5cdFx0cmVuZGVyUGFnZShwcmV2U3RlcCk7XG5cdH0pO1xuXG5cblx0Ly8g0L7RgtC/0YDQsNCy0LrQsCDRhNC+0YDQvNGLICjQvtGC0L/RgNCw0LLQu9GP0Y7RidCw0Y8g0LrQvdC+0L/QutCwLCDQv9C+INC00LjQt9Cw0LnQvdGDLCDQvdCw0YXQvtC00LjRgtGB0Y8g0LfQsCDQv9GA0LXQtNC10LvQsNC80Lgg0YTQvtGA0LzRiylcblx0JHN1Ym1pdC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdCRxdWl6LmZpbmQoJyNtLWZvcm0gaW5wdXQubS1mb3JtX19zdWJtaXRbdHlwZT1cInN1Ym1pdFwiXScpLnRyaWdnZXIoJ2NsaWNrJylcblx0fSk7XG5cblxuXHQvLyDRgdC60LvQvtC90LXQvdC40LUg0YfQuNGB0LvQuNGC0LXQu9GM0L3Ri9GFXHRcblx0Y29uc3QgZGVjbE9mTnVtID0gKG4sIGRhdGEpID0+IHsgXG5cdFx0aWYgKCFkYXRhKSB7IHJldHVybiAnJyB9O1xuXG5cdFx0Y29uc3QgdGV4dF9mb3JtcyA9IGRhdGEuc3BsaXQoXCIsXCIpO1xuXHRcdG4gPSBNYXRoLmFicyhuKSAlIDEwMDsgXG5cdFx0Y29uc3QgbjEgPSBuICUgMTA7XG5cblx0XHRpZiAobiA+IDEwICYmIG4gPCAyMCkgeyByZXR1cm4gdGV4dF9mb3Jtc1syXS50cmltKCk7IH1cblx0XHRpZiAobjEgPiAxICYmIG4xIDwgNSkgeyByZXR1cm4gdGV4dF9mb3Jtc1sxXS50cmltKCk7IH1cblx0XHRpZiAobjEgPT0gMSkgeyByZXR1cm4gdGV4dF9mb3Jtc1swXS50cmltKCk7IH1cblx0XHRyZXR1cm4gdGV4dF9mb3Jtc1syXS50cmltKCk7XG5cdH1cblxuXHRcblx0Ly8g0L3QsNGH0LDQu9C+INGA0LDQsdC+0YLRiywg0YHQsNC80YvQuSDQv9C10YDQstGL0Lkg0LLRi9C30L7QslxuXHRyZW5kZXJQYWdlKDApO1xuXG5cblx0Ly8g0L7QsdGA0LDQsdC+0YLRh9C40Log0L7RgtC/0YDQsNCy0LrQuCDRhNC+0YDQvNGLXG5cdCRxdWl6Lm9uKCdzdWJtaXQnLCAnI20tZm9ybScsIGZ1bmN0aW9uKGUpIHtcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XG5cdFx0bGV0ICRmb3JtID0gJCh0aGlzKTtcblx0XHRsZXQgZm9ybWRhdGEgPSBuZXcgRm9ybURhdGEoJGZvcm1bMF0pO1xuXHRcdGxldCAkZWxlbWVudHMgPSAkZm9ybVxuXHRcdFx0LmZpbmQoJ2lucHV0LCB0ZXh0YXJlYScpXG5cdFx0XHQuYWRkKCcubS1xdWl6X19idG5fcHJldicpXG5cdFx0XHQuYWRkKCcubS1xdWl6X19idG5fc3VibWl0Jyk7XG5cblx0XHRmb3JtZGF0YS5zZXQoJ20tcXVpeicsICRmb3JtLmZpbmQoJy5tLXJlc3VsdHNfX2RhdGEnKS5odG1sKCkpO1xuXHRcdCRlbGVtZW50cy5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG5cblx0XHQkLmFqYXgoe1xuXHRcdFx0dHlwZTogJ3Bvc3QnLFxuXHRcdFx0dXJsOiAnbWFpbHRvLnBocCcsIC8vINC+0LHRgNCw0LHQvtGC0YfQuNC6INCw0Y/QutGB0LAg0L3QsCDRgdC10YDQstC10YDQtSAo0LjRgdC/0L7Qu9GM0LfRg9C10YIgUEhQTWFpbGVyKVxuXHRcdFx0ZGF0YTogZm9ybWRhdGEsXG5cdFx0XHRwcm9jZXNzRGF0YTogZmFsc2UsXG5cdFx0XHRjb250ZW50VHlwZTpmYWxzZSxcblx0XHR9KS5kb25lKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG5cdFx0XHRsZXQgZGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UpO1xuXHRcdFx0JHRtcCA9ICRmb3JtLmNoaWxkcmVuKCkuZGV0YWNoKCk7XG5cblx0XHRcdGlmKGRhdGEuc3RhdHVzPT0nZXJyb3InKSB7XG5cdFx0XHRcdCRmb3JtLmFwcGVuZChgPGRpdiBjbGFzcz1cIm0tZm9ybV9fZWNobyBtLWZvcm1fX2VjaG9fZXJyb3JcIj4ke2RhdGEudGV4dH08L2Rpdj5gKTtcblxuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCRmb3JtLmNoaWxkcmVuKCkucmVtb3ZlKCk7XG5cdFx0XHRcdFx0JGZvcm0uYXBwZW5kKCR0bXApO1xuXHRcdFx0XHRcdCRlbGVtZW50cy5wcm9wKFwiZGlzYWJsZWRcIiwgZmFsc2UpO1xuXHRcdFx0XHR9LCAyMDAwKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JGZvcm0uYXBwZW5kKGA8ZGl2IGNsYXNzPVwibS1mb3JtX19lY2hvIG0tZm9ybV9fZWNob19zdWNjZXNzXCI+JHtkYXRhLnRleHR9PC9kaXY+YCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXG59KSgpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/blocks/m-quiz/m-quiz.js\n");

/***/ }),

/***/ "./src/blocks/m-quiz/m-quiz.json":
/*!***************************************!*\
  !*** ./src/blocks/m-quiz/m-quiz.json ***!
  \***************************************/
/*! exports provided: 0, 1, 2, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"[{\\\"question\\\":\\\"    ,   \\\",\\\"comment\\\":true,\\\"answers\\\":[\\\" \\\",\\\" \\\",\\\"  \\\",\\\" \\\",\\\"\\\",\\\"  \\\",\\\" \\\",\\\"  \\\",\\\" (   )\\\"]},{\\\"question\\\":\\\"      ?\\\",\\\"comment\\\":true,\\\"type\\\":\\\"radio\\\",\\\"answers\\\":[\\\". 1-5 \\\",\\\" 1-2 \\\",\\\"  \\\",\\\" 2022\\\",\\\" \\\"]},{\\\"question\\\":\\\"    ?\\\",\\\"comment\\\":true,\\\"type\\\":\\\"radio\\\",\\\"answers\\\":[\\\" 0  500 . \\\",\\\" 500   1,5 \\\",\\\" 1,5   5 \\\",\\\" 5   15 \\\"]}]\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIuL3NyYy9ibG9ja3MvbS1xdWl6L20tcXVpei5qc29uLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/blocks/m-quiz/m-quiz.json\n");

/***/ }),

/***/ "./src/blocks/modal/modal.js":
/*!***********************************!*\
  !*** ./src/blocks/modal/modal.js ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var scroll_lock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! scroll-lock */ \"./node_modules/scroll-lock/dist/scroll-lock.js\");\n/* harmony import */ var scroll_lock__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(scroll_lock__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _js_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../js/lib */ \"./src/js/lib.js\");\n\n // import Inputmask from \"inputmask\";\n\n(function () {\n  var cls = 'modal';\n  Object(_js_lib__WEBPACK_IMPORTED_MODULE_1__[\"addUnderlay\"])(cls);\n  Object(_js_lib__WEBPACK_IMPORTED_MODULE_1__[\"makeModalFrame\"])({\n    cls: cls,\n    scrollLock: scroll_lock__WEBPACK_IMPORTED_MODULE_0___default.a\n    /* Inputmask: Inputmask({\n    \t\"mask\": \"+7 (999) 999-99-99\", \n    \tshowMaskOnHover: false\n    }) */\n\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmxvY2tzL21vZGFsL21vZGFsLmpzPzRjNzciXSwibmFtZXMiOlsiY2xzIiwiYWRkVW5kZXJsYXkiLCJtYWtlTW9kYWxGcmFtZSIsInNjcm9sbExvY2siXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Q0FFQTs7QUFFQSxDQUFDLFlBQU07QUFFTixNQUFNQSxHQUFHLEdBQUcsT0FBWjtBQUVBQyw2REFBVyxDQUFDRCxHQUFELENBQVg7QUFDQUUsZ0VBQWMsQ0FBQztBQUNkRixPQUFHLEVBQUVBLEdBRFM7QUFFZEcsY0FBVSxFQUFWQSxrREFBVUE7QUFDVjtBQUNGO0FBQ0E7QUFDQTs7QUFOZ0IsR0FBRCxDQUFkO0FBU0EsQ0FkRCIsImZpbGUiOiIuL3NyYy9ibG9ja3MvbW9kYWwvbW9kYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc2Nyb2xsTG9jayBmcm9tICdzY3JvbGwtbG9jayc7XG5pbXBvcnQgeyBhZGRVbmRlcmxheSwgbWFrZU1vZGFsRnJhbWUgfSBmcm9tIFwiLi4vLi4vanMvbGliXCI7XG4vLyBpbXBvcnQgSW5wdXRtYXNrIGZyb20gXCJpbnB1dG1hc2tcIjtcblxuKCgpID0+IHtcblxuXHRjb25zdCBjbHMgPSAnbW9kYWwnO1xuXG5cdGFkZFVuZGVybGF5KGNscyk7XG5cdG1ha2VNb2RhbEZyYW1lKHsgXG5cdFx0Y2xzOiBjbHMsXG5cdFx0c2Nyb2xsTG9jayxcblx0XHQvKiBJbnB1dG1hc2s6IElucHV0bWFzayh7XG5cdFx0XHRcIm1hc2tcIjogXCIrNyAoOTk5KSA5OTktOTktOTlcIiwgXG5cdFx0XHRzaG93TWFza09uSG92ZXI6IGZhbHNlXG5cdFx0fSkgKi9cblx0IH0pO1xuXG59KSgpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/blocks/modal/modal.js\n");

/***/ }),

/***/ "./src/blocks/observ/observ.js":
/*!*************************************!*\
  !*** ./src/blocks/observ/observ.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function () {\n  var sections = document.querySelectorAll('.observ__section');\n  var menu = document.querySelector('.observ__side');\n\n  if (sections && menu) {\n    var ul = document.createElement('ul');\n    menu.appendChild(ul);\n    sections.forEach(function (section, index) {\n      var h2 = section.querySelector('h2');\n      var li = document.createElement('li');\n      var a = document.createElement('a');\n      section.id = 'block-' + index;\n      a.href = '#' + section.id;\n      a.textContent = h2.textContent;\n      li.appendChild(a);\n      ul.appendChild(li);\n    });\n    var observer = new IntersectionObserver(function (items, observer) {\n      items.forEach(function (item) {\n        var a = document.querySelector(\".observ__side a[href='#\".concat(item.target.id, \"']\"));\n        a.parentNode.classList[item.isIntersecting ? 'add' : 'remove']('active');\n      });\n    }, {\n      threshold: 0.5\n    });\n    document.querySelectorAll('.observ__section').forEach(function (items) {\n      observer.observe(items);\n    });\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmxvY2tzL29ic2Vydi9vYnNlcnYuanM/NjlmZCJdLCJuYW1lcyI6WyJzZWN0aW9ucyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsIm1lbnUiLCJxdWVyeVNlbGVjdG9yIiwidWwiLCJjcmVhdGVFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJmb3JFYWNoIiwic2VjdGlvbiIsImluZGV4IiwiaDIiLCJsaSIsImEiLCJpZCIsImhyZWYiLCJ0ZXh0Q29udGVudCIsIm9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJpdGVtcyIsIml0ZW0iLCJ0YXJnZXQiLCJwYXJlbnROb2RlIiwiY2xhc3NMaXN0IiwiaXNJbnRlcnNlY3RpbmciLCJ0aHJlc2hvbGQiLCJvYnNlcnZlIl0sIm1hcHBpbmdzIjoiQUFBQSxDQUFDLFlBQU07QUFFTixNQUFNQSxRQUFRLEdBQUdDLFFBQVEsQ0FBQ0MsZ0JBQVQsQ0FBMEIsa0JBQTFCLENBQWpCO0FBQ0EsTUFBTUMsSUFBSSxHQUFHRixRQUFRLENBQUNHLGFBQVQsQ0FBdUIsZUFBdkIsQ0FBYjs7QUFFQSxNQUFJSixRQUFRLElBQUlHLElBQWhCLEVBQXNCO0FBQ3JCLFFBQU1FLEVBQUUsR0FBR0osUUFBUSxDQUFDSyxhQUFULENBQXVCLElBQXZCLENBQVg7QUFDQUgsUUFBSSxDQUFDSSxXQUFMLENBQWlCRixFQUFqQjtBQUVBTCxZQUFRLENBQUNRLE9BQVQsQ0FBaUIsVUFBQ0MsT0FBRCxFQUFVQyxLQUFWLEVBQW9CO0FBQ3BDLFVBQU1DLEVBQUUsR0FBR0YsT0FBTyxDQUFDTCxhQUFSLENBQXNCLElBQXRCLENBQVg7QUFDQSxVQUFNUSxFQUFFLEdBQUdYLFFBQVEsQ0FBQ0ssYUFBVCxDQUF1QixJQUF2QixDQUFYO0FBQ0EsVUFBTU8sQ0FBQyxHQUFHWixRQUFRLENBQUNLLGFBQVQsQ0FBdUIsR0FBdkIsQ0FBVjtBQUVBRyxhQUFPLENBQUNLLEVBQVIsR0FBYSxXQUFXSixLQUF4QjtBQUNBRyxPQUFDLENBQUNFLElBQUYsR0FBUyxNQUFNTixPQUFPLENBQUNLLEVBQXZCO0FBQ0FELE9BQUMsQ0FBQ0csV0FBRixHQUFnQkwsRUFBRSxDQUFDSyxXQUFuQjtBQUNBSixRQUFFLENBQUNMLFdBQUgsQ0FBZU0sQ0FBZjtBQUNBUixRQUFFLENBQUNFLFdBQUgsQ0FBZUssRUFBZjtBQUNBLEtBVkQ7QUFZQSxRQUFNSyxRQUFRLEdBQUcsSUFBSUMsb0JBQUosQ0FBeUIsVUFBQ0MsS0FBRCxFQUFRRixRQUFSLEVBQXFCO0FBQzlERSxXQUFLLENBQUNYLE9BQU4sQ0FBYyxVQUFBWSxJQUFJLEVBQUk7QUFDckIsWUFBTVAsQ0FBQyxHQUFHWixRQUFRLENBQUNHLGFBQVQsa0NBQWlEZ0IsSUFBSSxDQUFDQyxNQUFMLENBQVlQLEVBQTdELFFBQVY7QUFDQUQsU0FBQyxDQUFDUyxVQUFGLENBQWFDLFNBQWIsQ0FBdUJILElBQUksQ0FBQ0ksY0FBTCxHQUFzQixLQUF0QixHQUE0QixRQUFuRCxFQUE2RCxRQUE3RDtBQUNBLE9BSEQ7QUFJQSxLQUxnQixFQUtkO0FBQUVDLGVBQVMsRUFBRTtBQUFiLEtBTGMsQ0FBakI7QUFPQXhCLFlBQVEsQ0FBQ0MsZ0JBQVQsQ0FBMEIsa0JBQTFCLEVBQThDTSxPQUE5QyxDQUF1RCxVQUFBVyxLQUFLLEVBQUk7QUFBRUYsY0FBUSxDQUFDUyxPQUFULENBQWlCUCxLQUFqQjtBQUF5QixLQUEzRjtBQUNBO0FBRUQsQ0EvQkQiLCJmaWxlIjoiLi9zcmMvYmxvY2tzL29ic2Vydi9vYnNlcnYuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoKCkgPT4ge1xuXG5cdGNvbnN0IHNlY3Rpb25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm9ic2Vydl9fc2VjdGlvbicpO1xuXHRjb25zdCBtZW51ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm9ic2Vydl9fc2lkZScpO1xuXG5cdGlmIChzZWN0aW9ucyAmJiBtZW51KSB7XG5cdFx0Y29uc3QgdWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuXHRcdG1lbnUuYXBwZW5kQ2hpbGQodWwpO1xuXHRcblx0XHRzZWN0aW9ucy5mb3JFYWNoKChzZWN0aW9uLCBpbmRleCkgPT4ge1xuXHRcdFx0Y29uc3QgaDIgPSBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJ2gyJyk7XG5cdFx0XHRjb25zdCBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG5cdFx0XHRjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHRcblx0XHRcdHNlY3Rpb24uaWQgPSAnYmxvY2stJyArIGluZGV4O1xuXHRcdFx0YS5ocmVmID0gJyMnICsgc2VjdGlvbi5pZDtcblx0XHRcdGEudGV4dENvbnRlbnQgPSBoMi50ZXh0Q29udGVudDtcblx0XHRcdGxpLmFwcGVuZENoaWxkKGEpXG5cdFx0XHR1bC5hcHBlbmRDaGlsZChsaSk7ICBcblx0XHR9KTtcblx0XHRcblx0XHRjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoaXRlbXMsIG9ic2VydmVyKSA9PiB7XG5cdFx0XHRpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuXHRcdFx0XHRjb25zdCBhID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgLm9ic2Vydl9fc2lkZSBhW2hyZWY9JyMke2l0ZW0udGFyZ2V0LmlkfSddYCk7XG5cdFx0XHRcdGEucGFyZW50Tm9kZS5jbGFzc0xpc3RbaXRlbS5pc0ludGVyc2VjdGluZyA/ICdhZGQnOidyZW1vdmUnXSgnYWN0aXZlJyk7XG5cdFx0XHR9KTtcblx0XHR9LCB7IHRocmVzaG9sZDogMC41IH0pO1xuXHRcdFxuXHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5vYnNlcnZfX3NlY3Rpb24nKS5mb3JFYWNoKCBpdGVtcyA9PiB7IG9ic2VydmVyLm9ic2VydmUoaXRlbXMpIH0pO1xuXHR9XG5cbn0pKCk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/blocks/observ/observ.js\n");

/***/ }),

/***/ "./src/blocks/p-quiz/p-quiz.js":
/*!*************************************!*\
  !*** ./src/blocks/p-quiz/p-quiz.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _p_quiz_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./p-quiz.json */ \"./src/blocks/p-quiz/p-quiz.json\");\nvar _p_quiz_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ./p-quiz.json */ \"./src/blocks/p-quiz/p-quiz.json\", 1);\n\n\n(function () {\n  var $quiz = $('#p-quiz');\n  var $page = $quiz.find('.p-page');\n  var $results = $quiz.find('.p-results');\n  var $progress = $quiz.find('.p-quiz__progress');\n  var $restart = $quiz.find('.p-quiz__btn_restart');\n  var $next = $quiz.find('.p-quiz__btn_next');\n  var results = {};\n  if (!$quiz.length) return; //   \n\n  var renderPage = function renderPage(index) {\n    $quiz.data('step', index);\n\n    var renderAnswers = function renderAnswers() {\n      return _p_quiz_json__WEBPACK_IMPORTED_MODULE_0__[index].answers.map(function (answer, id) {\n        return \"<label>\\n\\t\\t\\t\\t\\t<input type=\\\"radio\\\" name=\\\"\".concat(index, \"\\\" value=\\\"\").concat(index, \"_\").concat(id, \"\\\">\\n\\t\\t\\t\\t\\t<span>\").concat(answer.text, \"</span>\\n\\t\\t\\t\\t</label>\");\n      }).join('');\n    };\n\n    $page.html(\"\\n\\t\\t\\t<div class=\\\"p-page__item\\\">\\n\\t\\t\\t\\t<h4 class=\\\"p-page__question\\\">\".concat(_p_quiz_json__WEBPACK_IMPORTED_MODULE_0__[index].question, \"</h4>\\n\\t\\t\\t\\t<div class=\\\"p-page__answers\\\">\").concat(renderAnswers(), \"</div>\\t\\t\\t\\t\\n\\t\\t\\t</div>\\n\\t\\t\"));\n  }; //   \n\n\n  var renderResults = function renderResults() {\n    var content = '';\n\n    var getCorrect = function getCorrect(answer, index, id) {\n      var classname = '';\n\n      if (!answer.correct && results[index] === \"\".concat(index, \"_\").concat(id)) {\n        classname = 'invalid';\n      } else if (answer.correct) {\n        classname = 'valid';\n      }\n\n      return classname;\n    };\n\n    var getAnswers = function getAnswers(index) {\n      return _p_quiz_json__WEBPACK_IMPORTED_MODULE_0__[index].answers.map(function (answer, id) {\n        return \"<li class=\\\"p-results__answer \".concat(getCorrect(answer, index, id), \"\\\">\").concat(answer.text, \"</li>\");\n      }).join('');\n    };\n\n    _p_quiz_json__WEBPACK_IMPORTED_MODULE_0__.forEach(function (item, index) {\n      content += \"<div class=\\\"p-results__item\\\">\\n\\t\\t\\t\\t\\t<h4 class=\\\"p-results__question\\\">\".concat(item.question, \"</h4>\\n\\t\\t\\t\\t\\t<ul class=\\\"p-results__answers\\\">\").concat(getAnswers(index), \"</ul>\\n\\t\\t\\t\\t</div>\");\n    });\n    $results.html(content).show();\n  }; //   \n\n\n  $quiz.on('change', '.p-page__answers input', function (e) {\n    results[e.target.name] = e.target.value;\n    $progress.find('span').css({\n      width: ($quiz.data('step') + 1) / _p_quiz_json__WEBPACK_IMPORTED_MODULE_0__.length * 100 + '%'\n    });\n    $next.prop('disabled', false);\n  }); //   \"\"\n\n  $quiz.on('click', '.p-quiz__btn_next', function (e) {\n    var nextStep = $quiz.data('step') + 1;\n\n    if (_p_quiz_json__WEBPACK_IMPORTED_MODULE_0__.length <= nextStep) {\n      $page.hide();\n      $next.hide();\n      $progress.hide();\n      $restart.show();\n      renderResults();\n    } else {\n      renderPage(nextStep);\n    }\n\n    $next.prop('disabled', true);\n  }); //   \"\"\n\n  $quiz.on('click', '.p-quiz__btn_restart', function (e) {\n    results = {};\n    $results.html('').add($page).add($next).add($restart).add($progress).add($progress.find('span')).removeAttr('style');\n    renderPage(0);\n  });\n  renderPage(0);\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmxvY2tzL3AtcXVpei9wLXF1aXouanM/OGQxNiJdLCJuYW1lcyI6WyIkcXVpeiIsIiQiLCIkcGFnZSIsImZpbmQiLCIkcmVzdWx0cyIsIiRwcm9ncmVzcyIsIiRyZXN0YXJ0IiwiJG5leHQiLCJyZXN1bHRzIiwibGVuZ3RoIiwicmVuZGVyUGFnZSIsImluZGV4IiwiZGF0YSIsInJlbmRlckFuc3dlcnMiLCJEQVRBIiwiYW5zd2VycyIsIm1hcCIsImFuc3dlciIsImlkIiwidGV4dCIsImpvaW4iLCJodG1sIiwicXVlc3Rpb24iLCJyZW5kZXJSZXN1bHRzIiwiY29udGVudCIsImdldENvcnJlY3QiLCJjbGFzc25hbWUiLCJjb3JyZWN0IiwiZ2V0QW5zd2VycyIsImZvckVhY2giLCJpdGVtIiwic2hvdyIsIm9uIiwiZSIsInRhcmdldCIsIm5hbWUiLCJ2YWx1ZSIsImNzcyIsIndpZHRoIiwicHJvcCIsIm5leHRTdGVwIiwiaGlkZSIsImFkZCIsInJlbW92ZUF0dHIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBLENBQUMsWUFBTTtBQUVOLE1BQU1BLEtBQUssR0FBR0MsQ0FBQyxDQUFDLFNBQUQsQ0FBZjtBQUNBLE1BQU1DLEtBQUssR0FBR0YsS0FBSyxDQUFDRyxJQUFOLENBQVcsU0FBWCxDQUFkO0FBQ0EsTUFBTUMsUUFBUSxHQUFHSixLQUFLLENBQUNHLElBQU4sQ0FBVyxZQUFYLENBQWpCO0FBQ0EsTUFBTUUsU0FBUyxHQUFHTCxLQUFLLENBQUNHLElBQU4sQ0FBVyxtQkFBWCxDQUFsQjtBQUNBLE1BQU1HLFFBQVEsR0FBR04sS0FBSyxDQUFDRyxJQUFOLENBQVcsc0JBQVgsQ0FBakI7QUFDQSxNQUFNSSxLQUFLLEdBQUdQLEtBQUssQ0FBQ0csSUFBTixDQUFXLG1CQUFYLENBQWQ7QUFDQSxNQUFJSyxPQUFPLEdBQUcsRUFBZDtBQUVBLE1BQUksQ0FBQ1IsS0FBSyxDQUFDUyxNQUFYLEVBQW1CLE9B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USxHQUFHeEMsS0FBSyxDQUFDWSxJQUFOLENBQVcsTUFBWCxJQUFxQixDQUF0Qzs7QUFFQSxRQUFJRSx5Q0FBSSxDQUFDTCxNQUFMLElBQWUrQixRQUFuQixFQUE2QjtBQUM1QnRDLFdBQUssQ0FBQ3VDLElBQU47QUFDQWxDLFdBQUssQ0FBQ2tDLElBQU47QUFDQXBDLGVBQVMsQ0FBQ29DLElBQVY7QUFDQW5DLGNBQVEsQ0FBQ3lCLElBQVQ7QUFDQVIsbUJBQWE7QUFDYixLQU5ELE1BTU87QUFDTmIsZ0JBQVUsQ0FBQzhCLFFBQUQsQ0FBVjtBQUNBOztBQUVEakMsU0FBSyxDQUFDZ0MsSUFBTixDQUFXLFVBQVgsRUFBdUIsSUFBdkI7QUFDQSxHQWRELEVBN0VNLENBOEZOOztBQUNBdkMsT0FBSyxDQUFDZ0MsRUFBTixDQUFTLE9BQVQsRUFBa0Isc0JBQWxCLEVBQTBDLFVBQVNDLENBQVQsRUFBWTtBQUNyRHpCLFdBQU8sR0FBRyxFQUFWO0FBQ0FKLFlBQVEsQ0FDTmlCLElBREYsQ0FDTyxFQURQLEVBRUVxQixHQUZGLENBRU14QyxLQUZOLEVBR0V3QyxHQUhGLENBR01uQyxLQUhOLEVBSUVtQyxHQUpGLENBSU1wQyxRQUpOLEVBS0VvQyxHQUxGLENBS01yQyxTQUxOLEVBTUVxQyxHQU5GLENBTU1yQyxTQUFTLENBQUNGLElBQVYsQ0FBZSxNQUFmLENBTk4sRUFPRXdDLFVBUEYsQ0FPYSxPQVBiO0FBU0FqQyxjQUFVLENBQUMsQ0FBRCxDQUFWO0FBQ0EsR0FaRDtBQWNBQSxZQUFVLENBQUMsQ0FBRCxDQUFWO0FBQ0EsQ0E5R0QiLCJmaWxlIjoiLi9zcmMvYmxvY2tzL3AtcXVpei9wLXF1aXouanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgREFUQSBmcm9tICcuL3AtcXVpei5qc29uJztcblxuKCgpID0+IHtcblxuXHRjb25zdCAkcXVpeiA9ICQoJyNwLXF1aXonKTtcblx0Y29uc3QgJHBhZ2UgPSAkcXVpei5maW5kKCcucC1wYWdlJyk7XG5cdGNvbnN0ICRyZXN1bHRzID0gJHF1aXouZmluZCgnLnAtcmVzdWx0cycpO1xuXHRjb25zdCAkcHJvZ3Jlc3MgPSAkcXVpei5maW5kKCcucC1xdWl6X19wcm9ncmVzcycpO1xuXHRjb25zdCAkcmVzdGFydCA9ICRxdWl6LmZpbmQoJy5wLXF1aXpfX2J0bl9yZXN0YXJ0Jyk7XG5cdGNvbnN0ICRuZXh0ID0gJHF1aXouZmluZCgnLnAtcXVpel9fYnRuX25leHQnKTtcblx0bGV0IHJlc3VsdHMgPSB7fTtcblxuXHRpZiAoISRxdWl6Lmxlbmd0aCkgcmV0dXJuO1xuXG5cblx0Ly8g0L7RgtGA0LjRgdC+0LLQutCwINCx0LvQvtC60LAg0LLQvtC/0YDQvtGB0L7QslxuXHRjb25zdCByZW5kZXJQYWdlID0gKGluZGV4KSA9PiB7XG5cdFx0JHF1aXouZGF0YSgnc3RlcCcsIGluZGV4KTtcblxuXHRcdGNvbnN0IHJlbmRlckFuc3dlcnMgPSAoKSA9PiBEQVRBW2luZGV4XS5hbnN3ZXJzXG5cdFx0XHQubWFwKChhbnN3ZXIsIGlkKSA9PlxuXHRcdFx0XHRgPGxhYmVsPlxuXHRcdFx0XHRcdDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwiJHtpbmRleH1cIiB2YWx1ZT1cIiR7aW5kZXh9XyR7aWR9XCI+XG5cdFx0XHRcdFx0PHNwYW4+JHthbnN3ZXIudGV4dH08L3NwYW4+XG5cdFx0XHRcdDwvbGFiZWw+YFxuXHRcdFx0KS5qb2luKCcnKTtcblxuXHRcdCRwYWdlLmh0bWwoYFxuXHRcdFx0PGRpdiBjbGFzcz1cInAtcGFnZV9faXRlbVwiPlxuXHRcdFx0XHQ8aDQgY2xhc3M9XCJwLXBhZ2VfX3F1ZXN0aW9uXCI+JHtEQVRBW2luZGV4XS5xdWVzdGlvbn08L2g0PlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwicC1wYWdlX19hbnN3ZXJzXCI+JHtyZW5kZXJBbnN3ZXJzKCl9PC9kaXY+XHRcdFx0XHRcblx0XHRcdDwvZGl2PlxuXHRcdGApO1xuXHR9O1xuXG5cblx0Ly8g0L7RgtGA0LjRgdC+0LLQutCwINCx0LvQvtC60LAg0YDQtdC30YPQu9GM0YLQsNGC0L7QslxuXHRjb25zdCByZW5kZXJSZXN1bHRzID0gKCkgPT4ge1xuXHRcdGxldCBjb250ZW50ID0gJyc7XG5cblx0XHRjb25zdCBnZXRDb3JyZWN0ID0gKGFuc3dlciwgaW5kZXgsIGlkKSA9PiB7XG5cdFx0XHRsZXQgY2xhc3NuYW1lID0gJyc7XG5cblx0XHRcdGlmKCFhbnN3ZXIuY29ycmVjdCAmJiByZXN1bHRzW2luZGV4XSA9PT0gYCR7aW5kZXh9XyR7aWR9YCkge1xuXHRcdFx0XHRjbGFzc25hbWUgPSAnaW52YWxpZCc7XG5cdFx0XHR9IGVsc2UgaWYgKGFuc3dlci5jb3JyZWN0KSB7XG5cdFx0XHRcdGNsYXNzbmFtZSA9ICd2YWxpZCc7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjbGFzc25hbWU7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZ2V0QW5zd2VycyA9IChpbmRleCkgPT4gREFUQVtpbmRleF0uYW5zd2Vyc1xuXHRcdFx0Lm1hcCgoYW5zd2VyLCBpZCkgPT4gXG5cdFx0XHRcdGA8bGkgY2xhc3M9XCJwLXJlc3VsdHNfX2Fuc3dlciAke2dldENvcnJlY3QoYW5zd2VyLCBpbmRleCwgaWQpfVwiPiR7YW5zd2VyLnRleHR9PC9saT5gXG5cdFx0XHQpXG5cdFx0XHQuam9pbignJyk7XG5cblx0XHREQVRBLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG5cdFx0XHRjb250ZW50ICs9IFxuXHRcdFx0XHRgPGRpdiBjbGFzcz1cInAtcmVzdWx0c19faXRlbVwiPlxuXHRcdFx0XHRcdDxoNCBjbGFzcz1cInAtcmVzdWx0c19fcXVlc3Rpb25cIj4ke2l0ZW0ucXVlc3Rpb259PC9oND5cblx0XHRcdFx0XHQ8dWwgY2xhc3M9XCJwLXJlc3VsdHNfX2Fuc3dlcnNcIj4ke2dldEFuc3dlcnMoaW5kZXgpfTwvdWw+XG5cdFx0XHRcdDwvZGl2PmA7XG5cdFx0fSk7XG5cblx0XHQkcmVzdWx0cy5odG1sKGNvbnRlbnQpLnNob3coKTtcblx0fTtcblxuXG5cdC8vINC+0LHRgNCw0LHQvtGC0YfQuNC6INCy0YvQsdC+0YDQsCDQvtGC0LLQtdGC0LBcblx0JHF1aXoub24oJ2NoYW5nZScsICcucC1wYWdlX19hbnN3ZXJzIGlucHV0JywgZnVuY3Rpb24oZSkge1xuXHRcdHJlc3VsdHNbZS50YXJnZXQubmFtZV0gPSBlLnRhcmdldC52YWx1ZTtcblx0XHQkcHJvZ3Jlc3MuZmluZCgnc3BhbicpLmNzcyh7IHdpZHRoOiAoKCRxdWl6LmRhdGEoJ3N0ZXAnKSArIDEpIC8gREFUQS5sZW5ndGggKiAxMDApICsgJyUnIH0pO1xuXHRcdCRuZXh0LnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuXHR9KTtcblxuXG5cdC8vINC+0LHRgNCw0LHQvtGC0YfQuNC6INC60L3QvtC/0LrQuCBcItC00LDQu9C10LVcIlxuXHQkcXVpei5vbignY2xpY2snLCAnLnAtcXVpel9fYnRuX25leHQnLCBmdW5jdGlvbihlKSB7XG5cdFx0Y29uc3QgbmV4dFN0ZXAgPSAkcXVpei5kYXRhKCdzdGVwJykgKyAxO1xuXHRcdFxuXHRcdGlmIChEQVRBLmxlbmd0aCA8PSBuZXh0U3RlcCkge1xuXHRcdFx0JHBhZ2UuaGlkZSgpO1xuXHRcdFx0JG5leHQuaGlkZSgpO1xuXHRcdFx0JHByb2dyZXNzLmhpZGUoKTtcblx0XHRcdCRyZXN0YXJ0LnNob3coKTtcblx0XHRcdHJlbmRlclJlc3VsdHMoKTtcdFx0XHRcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVuZGVyUGFnZShuZXh0U3RlcCk7XG5cdFx0fVxuXHRcdFxuXHRcdCRuZXh0LnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XG5cdH0pO1xuXG5cdFxuXHQvLyDQvtCx0YDQsNCx0L7RgtGH0LjQuiDQutC90L7Qv9C60LggXCLRgNC10YHRgtCw0YDRglwiXG5cdCRxdWl6Lm9uKCdjbGljaycsICcucC1xdWl6X19idG5fcmVzdGFydCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRyZXN1bHRzID0ge307XG5cdFx0JHJlc3VsdHNcblx0XHRcdC5odG1sKCcnKVxuXHRcdFx0LmFkZCgkcGFnZSlcblx0XHRcdC5hZGQoJG5leHQpXG5cdFx0XHQuYWRkKCRyZXN0YXJ0KVxuXHRcdFx0LmFkZCgkcHJvZ3Jlc3MpXG5cdFx0XHQuYWRkKCRwcm9ncmVzcy5maW5kKCdzcGFuJykpXG5cdFx0XHQucmVtb3ZlQXR0cignc3R5bGUnKVxuXG5cdFx0cmVuZGVyUGFnZSgwKTtcblx0fSk7XG5cblx0cmVuZGVyUGFnZSgwKTtcbn0pKCk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/blocks/p-quiz/p-quiz.js\n");

/***/ }),

/***/ "./src/blocks/p-quiz/p-quiz.json":
/*!***************************************!*\
  !*** ./src/blocks/p-quiz/p-quiz.json ***!
  \***************************************/
/*! exports provided: 0, 1, 2, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"[{\\\"question\\\":\\\" \\\",\\\"answers\\\":[{\\\"text\\\":\\\" 1\\\",\\\"correct\\\":true},{\\\"text\\\":\\\" 2\\\",\\\"correct\\\":false},{\\\"text\\\":\\\" 3\\\",\\\"correct\\\":false}]},{\\\"question\\\":\\\" \\\",\\\"answers\\\":[{\\\"text\\\":\\\" 1\\\",\\\"correct\\\":false},{\\\"text\\\":\\\" 2\\\",\\\"correct\\\":true}]},{\\\"question\\\":\\\" \\\",\\\"answers\\\":[{\\\"text\\\":\\\" 1\\\",\\\"correct\\\":false},{\\\"text\\\":\\\" 2\\\",\\\"correct\\\":true},{\\\"text\\\":\\\" 3\\\",\\\"correct\\\":false}]}]\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIuL3NyYy9ibG9ja3MvcC1xdWl6L3AtcXVpei5qc29uLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/blocks/p-quiz/p-quiz.json\n");

/***/ }),

/***/ "./src/blocks/pr-gallery/pr-gallery.js":
/*!*********************************************!*\
  !*** ./src/blocks/pr-gallery/pr-gallery.js ***!
  \*********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/lib */ \"./src/js/lib.js\");\n\n\n(function () {\n  Object(_js_lib__WEBPACK_IMPORTED_MODULE_0__[\"makeGallery\"])(document.querySelectorAll('.pr-gallery__gallery'), {\n    navigation: true\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmxvY2tzL3ByLWdhbGxlcnkvcHItZ2FsbGVyeS5qcz81MTc4Il0sIm5hbWVzIjpbIm1ha2VHYWxsZXJ5IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwibmF2aWdhdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBOztBQUVBLENBQUMsWUFBTTtBQUNOQSw2REFBVyxDQUFDQyxRQUFRLENBQUNDLGdCQUFULENBQTBCLHNCQUExQixDQUFELEVBQW9EO0FBQUVDLGNBQVUsRUFBRTtBQUFkLEdBQXBELENBQVg7QUFFQSxDQUhEIiwiZmlsZSI6Ii4vc3JjL2Jsb2Nrcy9wci1nYWxsZXJ5L3ByLWdhbGxlcnkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtYWtlR2FsbGVyeSB9IGZyb20gXCIuLi8uLi9qcy9saWJcIjtcblxuKCgpID0+IHtcblx0bWFrZUdhbGxlcnkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnByLWdhbGxlcnlfX2dhbGxlcnknKSwgeyBuYXZpZ2F0aW9uOiB0cnVlIH0pO1xuXHRcbn0pKCk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/blocks/pr-gallery/pr-gallery.js\n");

/***/ }),

/***/ "./src/blocks/prlx/prlx.js":
/*!*********************************!*\
  !*** ./src/blocks/prlx/prlx.js ***!
  \*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/lib */ \"./src/js/lib.js\");\n\n\n(function () {\n  Object(_js_lib__WEBPACK_IMPORTED_MODULE_0__[\"makeParallax\"])(document.querySelectorAll('.prlx__effect'));\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmxvY2tzL3BybHgvcHJseC5qcz8xOTQ3Il0sIm5hbWVzIjpbIm1ha2VQYXJhbGxheCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBOztBQUVBLENBQUMsWUFBTTtBQUNOQSw4REFBWSxDQUFDQyxRQUFRLENBQUNDLGdCQUFULENBQTBCLGVBQTFCLENBQUQsQ0FBWjtBQUVBLENBSEQiLCJmaWxlIjoiLi9zcmMvYmxvY2tzL3BybHgvcHJseC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1ha2VQYXJhbGxheCB9IGZyb20gXCIuLi8uLi9qcy9saWJcIjtcblxuKCgpID0+IHtcblx0bWFrZVBhcmFsbGF4KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wcmx4X19lZmZlY3QnKSk7XG5cbn0pKCk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/blocks/prlx/prlx.js\n");

/***/ }),

/***/ "./src/blocks/q-quiz/q-quiz.js":
/*!*************************************!*\
  !*** ./src/blocks/q-quiz/q-quiz.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _q_quiz_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./q-quiz.json */ \"./src/blocks/q-quiz/q-quiz.json\");\nvar _q_quiz_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ./q-quiz.json */ \"./src/blocks/q-quiz/q-quiz.json\", 1);\n\n\n(function () {\n  var $quiz = $('#q-quiz');\n  var $page = $quiz.find('.q-page');\n  var $results = $quiz.find('.q-results');\n  var $restart = $quiz.find('.q-quiz__btn_restart');\n  var $next = $quiz.find('.q-quiz__btn_next');\n  var $prev = $quiz.find('.q-quiz__btn_prev');\n  var results = {};\n  if (!$quiz.length) return; //    \n\n  var renderPage = function renderPage(index) {\n    $quiz.data('step', index); // \n\n    var getChecked = function getChecked(id) {\n      var _results$index;\n\n      return (_results$index = results[index]) !== null && _results$index !== void 0 && _results$index.includes(id) ? 'checked' : '';\n    };\n\n    var renderAnswers = function renderAnswers() {\n      return _q_quiz_json__WEBPACK_IMPORTED_MODULE_0__[index].answers.map(function (answer, id) {\n        return \"<label>\\n\\t\\t\\t\\t\\t<input type=\\\"checkbox\\\" name=\\\"\".concat(index, \"\\\" value=\\\"\").concat(id, \"\\\" \").concat(getChecked(id), \">\\n\\t\\t\\t\\t\\t<span>\").concat(answer, \"</span>\\n\\t\\t\\t\\t</label>\");\n      }).join('');\n    };\n\n    $page.html(\"\\n\\t\\t\\t<div class=\\\"q-page__item\\\">\\n\\t\\t\\t\\t<h4 class=\\\"q-page__question\\\">\".concat(_q_quiz_json__WEBPACK_IMPORTED_MODULE_0__[index].question, \"</h4>\\n\\t\\t\\t\\t<div class=\\\"q-page__answers\\\">\").concat(renderAnswers(), \"</div>\\t\\t\\t\\t\\n\\t\\t\\t</div>\\n\\t\\t\")); //  \n\n    $next.prop('disabled', Boolean(!results[index] || !results[index].length)).add($page).add($results).add($next).add($restart).removeAttr('style'); //   \"\"   \n\n    if (!index) $prev.removeAttr('style');\n  }; //   \n\n\n  var processingResults = function processingResults() {\n    $quiz.data('step', _q_quiz_json__WEBPACK_IMPORTED_MODULE_0__.length);\n    var content = ''; // \n\n    var getAnswers = function getAnswers(index) {\n      return results[index].map(function (result) {\n        return \"<li class=\\\"q-results__answer\\\">\".concat(_q_quiz_json__WEBPACK_IMPORTED_MODULE_0__[index].answers[result], \"</li>\");\n      }).join('');\n    };\n\n    _q_quiz_json__WEBPACK_IMPORTED_MODULE_0__.forEach(function (item, index) {\n      content += \"<div class=\\\"q-results__item\\\">\\n\\t\\t\\t\\t\\t<h4 class=\\\"q-results__question\\\">\".concat(item.question, \"</h4>\\n\\t\\t\\t\\t\\t<ul class=\\\"q-results__answers\\\">\").concat(getAnswers(index), \"</ul>\\n\\t\\t\\t\\t</div>\");\n    }); //   \n\n    $results.html(content).add($page.html('')).add($next).add($restart).toggle();\n  }; //   \n\n\n  $quiz.on('change', 'input', function (e) {\n    results[e.target.name] = [];\n    $(this).parents('.q-page__answers').find('input[type=checkbox]:checked').each(function (index, el) {\n      results[e.target.name].push(Number(el.value));\n    });\n    $next.prop('disabled', Boolean(!results[e.target.name].length));\n  }); //   \"\"\n\n  $quiz.on('click', '.q-quiz__btn_next', function (e) {\n    var nextStep = $quiz.data('step') + 1;\n\n    if (_q_quiz_json__WEBPACK_IMPORTED_MODULE_0__.length <= nextStep) {\n      processingResults();\n    } else {\n      $prev.show();\n      renderPage(nextStep);\n    }\n  }); //   \"\"\n\n  $quiz.on('click', '.q-quiz__btn_prev', function (e) {\n    var prevStep = $quiz.data('step') - 1;\n    if (prevStep < 0) return;\n    renderPage(prevStep);\n  }); //   \"\"\n\n  $quiz.on('click', '.q-quiz__btn_restart', function (e) {\n    results = {};\n    $results.html('').add($page).add($next).add($prev).add($restart).removeAttr('style');\n    renderPage(0);\n  }); //   \n\n  renderPage(0);\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmxvY2tzL3EtcXVpei9xLXF1aXouanM/N2ZlZCJdLCJuYW1lcyI6WyIkcXVpeiIsIiQiLCIkcGFnZSIsImZpbmQiLCIkcmVzdWx0cyIsIiRyZXN0YXJ0IiwiJG5leHQiLCIkcHJldiIsInJlc3VsdHMiLCJsZW5ndGgiLCJyZW5kZXJQYWdlIiwiaW5kZXgiLCJkYXRhIiwiZ2V0Q2hlY2tlZCIsImlkIiwiaW5jbHVkZXMiLCJyZW5kZXJBbnN3ZXJzIiwiREFUQSIsImFuc3dlcnMiLCJtYXAiLCJhbnN3ZXIiLCJqb2luIiwiaHRtbCIsInF1ZXN0aW9uIiwicHJvcCIsIkJvb2xlYW4iLCJhZGQiLCJyZW1vdmVBdHRyIiwicHJvY2Vzc2luZ1Jlc3VsdHMiLCJjb250ZW50IiwiZ2V0QW5zd2VycyIsInJlc3VsdCIsImZvckVhY2giLCJpdGVtIiwidG9nZ2xlIiwib24iLCJlIiwidGFyZ2V0IiwibmFtZSIsInBhcmVudHMiLCJlYWNoIiwiZWwiLCJwdXNoIiwiTnVtYmVyIiwidmFsdWUiLCJuZXh0U3RlcCIsInNob3ciLCJwcmV2U3RlcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRUEsQ0FBQyxZQUFNO0FBRU4sTUFBTUEsS0FBSyxHQUFHQyxDQUFDLENBQUMsU0FBRCxDQUFmO0FBQ0EsTUFBTUMsS0FBSyxHQUFHRixLQUFLLENBQUNHLElBQU4sQ0FBVyxTQUFYLENBQWQ7QUFDQSxNQUFNQyxRQUFRLEdBQUdKLEtBQUssQ0FBQ0csSUFBTixDQUFXLFlBQVgsQ0FBakI7QUFDQSxNQUFNRSxRQUFRLEdBQUdMLEtBQUssQ0FBQ0csSUFBTixDQUFXLHNCQUFYLENBQWpCO0FBQ0EsTUFBTUcsS0FBSyxHQUFHTixLQUFLLENBQUNHLElBQU4sQ0FBVyxtQkFBWCxDQUFkO0FBQ0EsTUFBTUksS0FBSyxHQUFHUCxLQUFLLENBQUNHLElBQU4sQ0FBVyxtQkFBWCxDQUFkO0FBQ0EsTUFBSUssT0FBTyxHQUFHLEVBQWQ7QUFF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SE47O0FBQ0EvQyxPQUFLLENBQUNtQyxFQUFOLENBQVMsT0FBVCxFQUFrQixzQkFBbEIsRUFBMEMsVUFBU0MsQ0FBVCxFQUFZO0FBQ3JENUIsV0FBTyxHQUFHLEVBQVY7QUFDQUosWUFBUSxDQUNOa0IsSUFERixDQUNPLEVBRFAsRUFFRUksR0FGRixDQUVNeEIsS0FGTixFQUdFd0IsR0FIRixDQUdNcEIsS0FITixFQUlFb0IsR0FKRixDQUlNbkIsS0FKTixFQUtFbUIsR0FMRixDQUtNckIsUUFMTixFQU1Fc0IsVUFORixDQU1hLE9BTmI7QUFRQWpCLGNBQVUsQ0FBQyxDQUFELENBQVY7QUFDQSxHQVhELEVBcEhNLENBaUlOOztBQUNBQSxZQUFVLENBQUMsQ0FBRCxDQUFWO0FBQ0EsQ0FuSUQiLCJmaWxlIjoiLi9zcmMvYmxvY2tzL3EtcXVpei9xLXF1aXouanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgREFUQSBmcm9tICcuL3EtcXVpei5qc29uJztcblxuKCgpID0+IHtcblxuXHRjb25zdCAkcXVpeiA9ICQoJyNxLXF1aXonKTtcblx0Y29uc3QgJHBhZ2UgPSAkcXVpei5maW5kKCcucS1wYWdlJyk7XG5cdGNvbnN0ICRyZXN1bHRzID0gJHF1aXouZmluZCgnLnEtcmVzdWx0cycpO1xuXHRjb25zdCAkcmVzdGFydCA9ICRxdWl6LmZpbmQoJy5xLXF1aXpfX2J0bl9yZXN0YXJ0Jyk7XG5cdGNvbnN0ICRuZXh0ID0gJHF1aXouZmluZCgnLnEtcXVpel9fYnRuX25leHQnKTtcblx0Y29uc3QgJHByZXYgPSAkcXVpei5maW5kKCcucS1xdWl6X19idG5fcHJldicpO1xuXHRsZXQgcmVzdWx0cyA9IHt9O1xuXG5cdGlmICghJHF1aXoubGVuZ3RoKSByZXR1cm47XG5cblxuXHQvLyDQvtGC0YDQuNGB0L7QstC60LAg0YLQtdC60YPRidC10LPQviDQsdC70L7QutCwINCy0L7Qv9GA0L7RgdC+0LJcblx0Y29uc3QgcmVuZGVyUGFnZSA9IChpbmRleCkgPT4ge1xuXHRcdCRxdWl6LmRhdGEoJ3N0ZXAnLCBpbmRleCk7XG5cdFx0XG5cdFx0Ly8g0L7RgtGA0LjRgdC+0LLQutCwXG5cdFx0Y29uc3QgZ2V0Q2hlY2tlZCA9IChpZCkgPT4gcmVzdWx0c1tpbmRleF0/LmluY2x1ZGVzKGlkKSA/ICdjaGVja2VkJyA6ICcnO1xuXG5cdFx0Y29uc3QgcmVuZGVyQW5zd2VycyA9ICgpID0+IERBVEFbaW5kZXhdLmFuc3dlcnNcblx0XHRcdC5tYXAoKGFuc3dlciwgaWQpID0+XG5cdFx0XHRcdGA8bGFiZWw+XG5cdFx0XHRcdFx0PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5hbWU9XCIke2luZGV4fVwiIHZhbHVlPVwiJHtpZH1cIiAke2dldENoZWNrZWQoaWQpfT5cblx0XHRcdFx0XHQ8c3Bhbj4ke2Fuc3dlcn08L3NwYW4+XG5cdFx0XHRcdDwvbGFiZWw+YFxuXHRcdFx0KS5qb2luKCcnKTtcblxuXHRcdCRwYWdlLmh0bWwoYFxuXHRcdFx0PGRpdiBjbGFzcz1cInEtcGFnZV9faXRlbVwiPlxuXHRcdFx0XHQ8aDQgY2xhc3M9XCJxLXBhZ2VfX3F1ZXN0aW9uXCI+JHtEQVRBW2luZGV4XS5xdWVzdGlvbn08L2g0PlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwicS1wYWdlX19hbnN3ZXJzXCI+JHtyZW5kZXJBbnN3ZXJzKCl9PC9kaXY+XHRcdFx0XHRcblx0XHRcdDwvZGl2PlxuXHRcdGApO1xuXG5cdFx0Ly8g0YHQsdGA0L7RgSDRjdC70LXQvNC10L3RgtC+0LJcblx0XHQkbmV4dFxuXHRcdFx0LnByb3AoJ2Rpc2FibGVkJywgQm9vbGVhbighcmVzdWx0c1tpbmRleF0gfHwgIXJlc3VsdHNbaW5kZXhdLmxlbmd0aCkpXG5cdFx0XHQuYWRkKCRwYWdlKVxuXHRcdFx0LmFkZCgkcmVzdWx0cylcblx0XHRcdC5hZGQoJG5leHQpXG5cdFx0XHQuYWRkKCRyZXN0YXJ0KVxuXHRcdFx0LnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG5cdFx0XG5cdFx0Ly8g0YPQsdGA0LDRgtGMINC60L3QvtC/0LrRgyBcItC90LDQt9Cw0LRcIiDQvdCwINC/0LXRgNCy0L7QuSDRgdGC0YDQsNC90LjRh9C60LVcblx0XHRpZiAoIWluZGV4KSAkcHJldi5yZW1vdmVBdHRyKCdzdHlsZScpO1xuXG5cdH07XG5cblxuXHQvLyDQvtGC0YDQuNGB0L7QstC60LAg0LHQu9C+0LrQsCDRgNC10LfRg9C70YzRgtCw0YLQvtCyXG5cdGNvbnN0IHByb2Nlc3NpbmdSZXN1bHRzID0gKCkgPT4ge1xuXHRcdCRxdWl6LmRhdGEoJ3N0ZXAnLCBEQVRBLmxlbmd0aCk7XG5cdFx0bGV0IGNvbnRlbnQgPSAnJztcblxuXHRcdC8vINC+0YLRgNC40YHQvtCy0LrQsFxuXHRcdGNvbnN0IGdldEFuc3dlcnMgPSAoaW5kZXgpID0+IHJlc3VsdHNbaW5kZXhdXG5cdFx0XHQubWFwKChyZXN1bHQpID0+IGA8bGkgY2xhc3M9XCJxLXJlc3VsdHNfX2Fuc3dlclwiPiR7REFUQVtpbmRleF0uYW5zd2Vyc1tyZXN1bHRdfTwvbGk+YClcblx0XHRcdC5qb2luKCcnKTtcblxuXHRcdERBVEEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcblx0XHRcdGNvbnRlbnQgKz0gXG5cdFx0XHRcdGA8ZGl2IGNsYXNzPVwicS1yZXN1bHRzX19pdGVtXCI+XG5cdFx0XHRcdFx0PGg0IGNsYXNzPVwicS1yZXN1bHRzX19xdWVzdGlvblwiPiR7aXRlbS5xdWVzdGlvbn08L2g0PlxuXHRcdFx0XHRcdDx1bCBjbGFzcz1cInEtcmVzdWx0c19fYW5zd2Vyc1wiPiR7Z2V0QW5zd2VycyhpbmRleCl9PC91bD5cblx0XHRcdFx0PC9kaXY+YDtcblx0XHR9KTtcblxuXHRcdC8vINC/0LXRgNC10LrQu9GO0YfQtdC90LjQtSDQstC40LTQuNC80L7RgdGC0Lgg0Y3Qu9C10LzQtdC90YLQvtCyXG5cdFx0JHJlc3VsdHNcblx0XHRcdC5odG1sKGNvbnRlbnQpXG5cdFx0XHQuYWRkKCRwYWdlLmh0bWwoJycpKVxuXHRcdFx0LmFkZCgkbmV4dClcblx0XHRcdC5hZGQoJHJlc3RhcnQpXG5cdFx0XHQudG9nZ2xlKCk7XG5cdH07XG5cblxuXHQvLyDQvtCx0YDQsNCx0L7RgtGH0LjQuiDQstGL0LHQvtGA0LAg0L7RgtCy0LXRgtCwXG5cdCRxdWl6Lm9uKCdjaGFuZ2UnLCAnaW5wdXQnLCBmdW5jdGlvbihlKSB7XG5cdFx0cmVzdWx0c1tlLnRhcmdldC5uYW1lXSA9IFtdO1xuXG5cdFx0JCh0aGlzKVxuXHRcdFx0LnBhcmVudHMoJy5xLXBhZ2VfX2Fuc3dlcnMnKVxuXHRcdFx0LmZpbmQoJ2lucHV0W3R5cGU9Y2hlY2tib3hdOmNoZWNrZWQnKVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsKXtcblx0XHRcdFx0cmVzdWx0c1tlLnRhcmdldC5uYW1lXS5wdXNoKE51bWJlcihlbC52YWx1ZSkpO1xuXHRcdFx0fSk7XG5cblx0XHQkbmV4dC5wcm9wKCdkaXNhYmxlZCcsIEJvb2xlYW4oIXJlc3VsdHNbZS50YXJnZXQubmFtZV0ubGVuZ3RoKSk7XG5cdH0pO1xuXG5cblx0Ly8g0L7QsdGA0LDQsdC+0YLRh9C40Log0LrQvdC+0L/QutC4IFwi0LTQsNC70LXQtVwiXG5cdCRxdWl6Lm9uKCdjbGljaycsICcucS1xdWl6X19idG5fbmV4dCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRjb25zdCBuZXh0U3RlcCA9ICRxdWl6LmRhdGEoJ3N0ZXAnKSArIDE7XG5cblx0XHRpZiAoREFUQS5sZW5ndGggPD0gbmV4dFN0ZXApIHtcblx0XHRcdHByb2Nlc3NpbmdSZXN1bHRzKCk7XHRcdFx0XG5cdFx0fSBlbHNlIHtcblx0XHRcdCRwcmV2LnNob3coKTtcblx0XHRcdHJlbmRlclBhZ2UobmV4dFN0ZXApO1xuXHRcdH1cblx0fSk7XG5cblxuXHQvLyDQvtCx0YDQsNCx0L7RgtGH0LjQuiDQutC90L7Qv9C60LggXCLQvdCw0LfQsNC0XCJcblx0JHF1aXoub24oJ2NsaWNrJywgJy5xLXF1aXpfX2J0bl9wcmV2JywgZnVuY3Rpb24oZSkge1xuXHRcdGxldCBwcmV2U3RlcCA9ICRxdWl6LmRhdGEoJ3N0ZXAnKSAtIDE7XG5cdFx0aWYgKHByZXZTdGVwIDwgMCkgcmV0dXJuO1xuXG5cdFx0cmVuZGVyUGFnZShwcmV2U3RlcCk7XG5cdH0pO1xuXG5cdFxuXHQvLyDQvtCx0YDQsNCx0L7RgtGH0LjQuiDQutC90L7Qv9C60LggXCLRgNC10YHRgtCw0YDRglwiXG5cdCRxdWl6Lm9uKCdjbGljaycsICcucS1xdWl6X19idG5fcmVzdGFydCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRyZXN1bHRzID0ge307XG5cdFx0JHJlc3VsdHNcblx0XHRcdC5odG1sKCcnKVxuXHRcdFx0LmFkZCgkcGFnZSlcblx0XHRcdC5hZGQoJG5leHQpXG5cdFx0XHQuYWRkKCRwcmV2KVxuXHRcdFx0LmFkZCgkcmVzdGFydClcblx0XHRcdC5yZW1vdmVBdHRyKCdzdHlsZScpO1xuXG5cdFx0cmVuZGVyUGFnZSgwKTtcblx0fSk7XG5cblx0Ly8g0YHQsNC80YvQuSDQv9C10YDQstGL0Lkg0LLRi9C30L7QslxuXHRyZW5kZXJQYWdlKDApO1xufSkoKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/blocks/q-quiz/q-quiz.js\n");

/***/ }),

/***/ "./src/blocks/q-quiz/q-quiz.json":
/*!***************************************!*\
  !*** ./src/blocks/q-quiz/q-quiz.json ***!
  \***************************************/
/*! exports provided: 0, 1, 2, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"[{\\\"question\\\":\\\" \\\",\\\"answers\\\":[\\\" 1\\\",\\\" 2\\\",\\\" 3\\\",\\\" 4\\\"]},{\\\"question\\\":\\\" \\\",\\\"answers\\\":[\\\" 1\\\",\\\" 2\\\",\\\" 3\\\",\\\" 4\\\",\\\" 5\\\"]},{\\\"question\\\":\\\" \\\",\\\"answers\\\":[\\\" 1\\\",\\\" 2\\\",\\\" 3\\\"]}]\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIuL3NyYy9ibG9ja3MvcS1xdWl6L3EtcXVpei5qc29uLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/blocks/q-quiz/q-quiz.json\n");

/***/ }),

/***/ "./src/blocks/scroll/scroll.js":
/*!*************************************!*\
  !*** ./src/blocks/scroll/scroll.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../js/lib */ \"./src/js/lib.js\");\n\n\n(function () {\n  var sticky = document.querySelector('.scroll__items');\n  var items = sticky === null || sticky === void 0 ? void 0 : sticky.querySelectorAll('.scroll__item');\n  if (sticky && items) Object(_js_lib__WEBPACK_IMPORTED_MODULE_0__[\"scrollBasedToggle\"])(sticky, items, {\n    first: false\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmxvY2tzL3Njcm9sbC9zY3JvbGwuanM/MDg5NiJdLCJuYW1lcyI6WyJzdGlja3kiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJpdGVtcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJzY3JvbGxCYXNlZFRvZ2dsZSIsImZpcnN0Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7O0FBRUEsQ0FBQyxZQUFNO0FBRU4sTUFBTUEsTUFBTSxHQUFHQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsZ0JBQXZCLENBQWY7QUFDQSxNQUFNQyxLQUFLLEdBQUdILE1BQUgsYUFBR0EsTUFBSCx1QkFBR0EsTUFBTSxDQUFFSSxnQkFBUixDQUF5QixlQUF6QixDQUFkO0FBRUEsTUFBSUosTUFBTSxJQUFJRyxLQUFkLEVBQ0NFLGlFQUFpQixDQUFDTCxNQUFELEVBQVNHLEtBQVQsRUFBZ0I7QUFBRUcsU0FBSyxFQUFFO0FBQVQsR0FBaEIsQ0FBakI7QUFFRCxDQVJEIiwiZmlsZSI6Ii4vc3JjL2Jsb2Nrcy9zY3JvbGwvc2Nyb2xsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2Nyb2xsQmFzZWRUb2dnbGUgfSBmcm9tIFwiLi4vLi4vanMvbGliXCI7XG5cbigoKSA9PiB7XG5cblx0Y29uc3Qgc3RpY2t5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNjcm9sbF9faXRlbXMnKTtcblx0Y29uc3QgaXRlbXMgPSBzdGlja3k/LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zY3JvbGxfX2l0ZW0nKTtcblxuXHRpZiAoc3RpY2t5ICYmIGl0ZW1zKVxuXHRcdHNjcm9sbEJhc2VkVG9nZ2xlKHN0aWNreSwgaXRlbXMsIHsgZmlyc3Q6IGZhbHNlIH0pO1xuXG59KSgpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/blocks/scroll/scroll.js\n");

/***/ }),

/***/ "./src/js/blocks.js":
/*!**************************!*\
  !*** ./src/js/blocks.js ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _blocks_f_form_f_form_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../blocks/f-form/f-form.js */ \"./src/blocks/f-form/f-form.js\");\n/* harmony import */ var _blocks_modal_modal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../blocks/modal/modal.js */ \"./src/blocks/modal/modal.js\");\n/* harmony import */ var _blocks_datepicker_datepicker_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../blocks/datepicker/datepicker.js */ \"./src/blocks/datepicker/datepicker.js\");\n/* harmony import */ var _blocks_cm_catalog_cm_catalog_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../blocks/cm-catalog/cm-catalog.js */ \"./src/blocks/cm-catalog/cm-catalog.js\");\n/* harmony import */ var _blocks_cm_catalog_cm_catalog_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_blocks_cm_catalog_cm_catalog_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _blocks_q_quiz_q_quiz_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../blocks/q-quiz/q-quiz.js */ \"./src/blocks/q-quiz/q-quiz.js\");\n/* harmony import */ var _blocks_p_quiz_p_quiz_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../blocks/p-quiz/p-quiz.js */ \"./src/blocks/p-quiz/p-quiz.js\");\n/* harmony import */ var _blocks_c_calc_c_calc_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../blocks/c-calc/c-calc.js */ \"./src/blocks/c-calc/c-calc.js\");\n/* harmony import */ var _blocks_m_quiz_m_quiz_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../blocks/m-quiz/m-quiz.js */ \"./src/blocks/m-quiz/m-quiz.js\");\n/* harmony import */ var _blocks_a_anim_a_anim_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../blocks/a-anim/a-anim.js */ \"./src/blocks/a-anim/a-anim.js\");\n/* harmony import */ var _blocks_pr_gallery_pr_gallery_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../blocks/pr-gallery/pr-gallery.js */ \"./src/blocks/pr-gallery/pr-gallery.js\");\n/* harmony import */ var _blocks_observ_observ_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../blocks/observ/observ.js */ \"./src/blocks/observ/observ.js\");\n/* harmony import */ var _blocks_observ_observ_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_blocks_observ_observ_js__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _blocks_prlx_prlx_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../blocks/prlx/prlx.js */ \"./src/blocks/prlx/prlx.js\");\n/* harmony import */ var _blocks_accordeon_accordeon_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../blocks/accordeon/accordeon.js */ \"./src/blocks/accordeon/accordeon.js\");\n/* harmony import */ var _blocks_scroll_scroll_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../blocks/scroll/scroll.js */ \"./src/blocks/scroll/scroll.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvYmxvY2tzLmpzPzVlM2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL2pzL2Jsb2Nrcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBcIi4uL2Jsb2Nrcy9mLWZvcm0vZi1mb3JtLmpzXCI7XHJcbmltcG9ydCBcIi4uL2Jsb2Nrcy9tb2RhbC9tb2RhbC5qc1wiO1xyXG5pbXBvcnQgXCIuLi9ibG9ja3MvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmpzXCI7XHJcbmltcG9ydCBcIi4uL2Jsb2Nrcy9jbS1jYXRhbG9nL2NtLWNhdGFsb2cuanNcIjtcclxuaW1wb3J0IFwiLi4vYmxvY2tzL3EtcXVpei9xLXF1aXouanNcIjtcclxuaW1wb3J0IFwiLi4vYmxvY2tzL3AtcXVpei9wLXF1aXouanNcIjtcclxuaW1wb3J0IFwiLi4vYmxvY2tzL2MtY2FsYy9jLWNhbGMuanNcIjtcclxuaW1wb3J0IFwiLi4vYmxvY2tzL20tcXVpei9tLXF1aXouanNcIjtcclxuaW1wb3J0IFwiLi4vYmxvY2tzL2EtYW5pbS9hLWFuaW0uanNcIjtcclxuaW1wb3J0IFwiLi4vYmxvY2tzL3ByLWdhbGxlcnkvcHItZ2FsbGVyeS5qc1wiO1xyXG5pbXBvcnQgXCIuLi9ibG9ja3Mvb2JzZXJ2L29ic2Vydi5qc1wiO1xyXG5pbXBvcnQgXCIuLi9ibG9ja3MvcHJseC9wcmx4LmpzXCI7XHJcbmltcG9ydCBcIi4uL2Jsb2Nrcy9hY2NvcmRlb24vYWNjb3JkZW9uLmpzXCI7XHJcbmltcG9ydCBcIi4uL2Jsb2Nrcy9zY3JvbGwvc2Nyb2xsLmpzXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/blocks.js\n");

/***/ }),

/***/ "./src/js/common.js":
/*!**************************!*\
  !*** ./src/js/common.js ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _blocks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blocks.js */ \"./src/js/blocks.js\");\n\n/* Polyfills */\n\n(function (e) {\n  e.matches = e.matches || e.mozMatchesSelector || e.msMatchesSelector || e.oMatchesSelector || e.webkitMatchesSelector;\n\n  e.closest = e.closest || function closest(selector) {\n    if (!this) return null;\n    if (this.matches(selector)) return this;\n\n    if (!this.parentElement) {\n      return null;\n    } else return this.parentElement.closest(selector);\n  };\n})(Element.prototype);\n\n(function (e) {\n  var matches = e.matches || e.matchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector || e.oMatchesSelector;\n  !matches ? e.matches = e.matchesSelector = function matches(selector) {\n    var matches = document.querySelectorAll(selector);\n    var th = this;\n    return Array.prototype.some.call(matches, function (e) {\n      return e === th;\n    });\n  } : e.matches = e.matchesSelector = matches;\n})(Element.prototype);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tbW9uLmpzPzQ0MGEiXSwibmFtZXMiOlsiZSIsIm1hdGNoZXMiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJjbG9zZXN0Iiwic2VsZWN0b3IiLCJwYXJlbnRFbGVtZW50IiwiRWxlbWVudCIsInByb3RvdHlwZSIsIm1hdGNoZXNTZWxlY3RvciIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsInRoIiwiQXJyYXkiLCJzb21lIiwiY2FsbCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBRUE7O0FBQ0MsV0FBU0EsQ0FBVCxFQUFZO0FBQ1pBLEdBQUMsQ0FBQ0MsT0FBRixHQUFZRCxDQUFDLENBQUNDLE9BQUYsSUFBYUQsQ0FBQyxDQUFDRSxrQkFBZixJQUFxQ0YsQ0FBQyxDQUFDRyxpQkFBdkMsSUFBNERILENBQUMsQ0FBQ0ksZ0JBQTlELElBQWtGSixDQUFDLENBQUNLLHFCQUFoRzs7QUFDQUwsR0FBQyxDQUFDTSxPQUFGLEdBQVlOLENBQUMsQ0FBQ00sT0FBRixJQUFhLFNBQVNBLE9BQVQsQ0FBaUJDLFFBQWpCLEVBQTJCO0FBQ25ELFFBQUksQ0FBQyxJQUFMLEVBQVcsT0FBTyxJQUFQO0FBQ1gsUUFBSSxLQUFLTixPQUFMLENBQWFNLFFBQWIsQ0FBSixFQUE0QixPQUFPLElBQVA7O0FBQzVCLFFBQUksQ0FBQyxLQUFLQyxhQUFWLEVBQXlCO0FBQUMsYUFBTyxJQUFQO0FBQVksS0FBdEMsTUFDTSxPQUFPLEtBQUtBLGFBQUwsQ0FBbUJGLE9BQW5CLENBQTJCQyxRQUEzQixDQUFQO0FBQ0wsR0FMRjtBQU1BLENBUkEsRUFRQ0UsT0FBTyxDQUFDQyxTQVJULENBQUQ7O0FBVUEsQ0FBQyxVQUFTVixDQUFULEVBQVk7QUFDWixNQUFJQyxPQUFPLEdBQUdELENBQUMsQ0FBQ0MsT0FBRixJQUFhRCxDQUFDLENBQUNXLGVBQWYsSUFBa0NYLENBQUMsQ0FBQ0sscUJBQXBDLElBQTZETCxDQUFDLENBQUNFLGtCQUEvRCxJQUFxRkYsQ0FBQyxDQUFDRyxpQkFBdkYsSUFBNEdILENBQUMsQ0FBQ0ksZ0JBQTVIO0FBQ0EsR0FBQ0gsT0FBRCxHQUFZRCxDQUFDLENBQUNDLE9BQUYsR0FBWUQsQ0FBQyxDQUFDVyxlQUFGLEdBQW9CLFNBQVNWLE9BQVQsQ0FBaUJNLFFBQWpCLEVBQTJCO0FBQ3RFLFFBQUlOLE9BQU8sR0FBR1csUUFBUSxDQUFDQyxnQkFBVCxDQUEwQk4sUUFBMUIsQ0FBZDtBQUNBLFFBQUlPLEVBQUUsR0FBRyxJQUFUO0FBQ0EsV0FBT0MsS0FBSyxDQUFDTCxTQUFOLENBQWdCTSxJQUFoQixDQUFxQkMsSUFBckIsQ0FBMEJoQixPQUExQixFQUFtQyxVQUFTRCxDQUFULEVBQVk7QUFDckQsYUFBT0EsQ0FBQyxLQUFLYyxFQUFiO0FBQ0EsS0FGTSxDQUFQO0FBR0EsR0FORCxHQU1NZCxDQUFDLENBQUNDLE9BQUYsR0FBWUQsQ0FBQyxDQUFDVyxlQUFGLEdBQW9CVixPQU50QztBQU9BLENBVEQsRUFTR1EsT0FBTyxDQUFDQyxTQVRYIiwiZmlsZSI6Ii4vc3JjL2pzL2NvbW1vbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBcIi4vYmxvY2tzLmpzXCI7XHJcblxyXG4vKiBQb2x5ZmlsbHMgKi9cclxuKGZ1bmN0aW9uKGUpIHtcclxuXHRlLm1hdGNoZXMgPSBlLm1hdGNoZXMgfHwgZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZS5tc01hdGNoZXNTZWxlY3RvciB8fCBlLm9NYXRjaGVzU2VsZWN0b3IgfHwgZS53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XHJcblx0ZS5jbG9zZXN0ID0gZS5jbG9zZXN0IHx8IGZ1bmN0aW9uIGNsb3Nlc3Qoc2VsZWN0b3IpIHtcclxuXHRcdGlmICghdGhpcykgcmV0dXJuIG51bGw7XHJcblx0XHRpZiAodGhpcy5tYXRjaGVzKHNlbGVjdG9yKSkgcmV0dXJuIHRoaXM7XHJcblx0XHRpZiAoIXRoaXMucGFyZW50RWxlbWVudCkge3JldHVybiBudWxsfVxyXG5cdFx0XHRlbHNlIHJldHVybiB0aGlzLnBhcmVudEVsZW1lbnQuY2xvc2VzdChzZWxlY3RvcilcclxuXHRcdH07XHJcbn0oRWxlbWVudC5wcm90b3R5cGUpKTtcclxuXHJcbihmdW5jdGlvbihlKSB7XHJcblx0dmFyIG1hdGNoZXMgPSBlLm1hdGNoZXMgfHwgZS5tYXRjaGVzU2VsZWN0b3IgfHwgZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZS5tc01hdGNoZXNTZWxlY3RvciB8fCBlLm9NYXRjaGVzU2VsZWN0b3I7XHJcblx0IW1hdGNoZXMgPyAoZS5tYXRjaGVzID0gZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiBtYXRjaGVzKHNlbGVjdG9yKSB7XHJcblx0XHR2YXIgbWF0Y2hlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xyXG5cdFx0dmFyIHRoID0gdGhpcztcclxuXHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuc29tZS5jYWxsKG1hdGNoZXMsIGZ1bmN0aW9uKGUpIHtcclxuXHRcdFx0cmV0dXJuIGUgPT09IHRoO1xyXG5cdFx0fSk7XHJcblx0fSkgOiAoZS5tYXRjaGVzID0gZS5tYXRjaGVzU2VsZWN0b3IgPSBtYXRjaGVzKTtcclxufSkoRWxlbWVudC5wcm90b3R5cGUpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/common.js\n");

/***/ }),

/***/ "./src/js/lib.js":
/*!***********************!*\
  !*** ./src/js/lib.js ***!
  \***********************/
/*! exports provided: getHeight, scrollClassToggle, scrollBasedToggle, selectTweaker, roughAccordion, smoothAccordion, makeGallery, makeParallax, addUnderlay, makeModalFrame, slideUp, slideDown, slideToggle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getHeight\", function() { return getHeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scrollClassToggle\", function() { return scrollClassToggle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scrollBasedToggle\", function() { return scrollBasedToggle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"selectTweaker\", function() { return selectTweaker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"roughAccordion\", function() { return roughAccordion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"smoothAccordion\", function() { return smoothAccordion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeGallery\", function() { return makeGallery; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeParallax\", function() { return makeParallax; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addUnderlay\", function() { return addUnderlay; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeModalFrame\", function() { return makeModalFrame; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"slideUp\", function() { return slideUp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"slideDown\", function() { return slideDown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"slideToggle\", function() { return slideToggle; });\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n//    \nvar getHeight = function getHeight(el) {\n  if (!el) return;\n  var computed = window.getComputedStyle(el);\n  var height = computed.boxSizing === \"border-box\" ? el.offsetHeight : el.offsetHeight - parseFloat(computed.paddingTop) - parseFloat(computed.paddingBottom) - parseFloat(computed.borderTopWidth) - parseFloat(computed.borderBottomWidth);\n\n  if (computed.height === 'auto' && computed.display === 'none') {\n    if (!(el !== null && el !== void 0 && el.cloneNode)) return null;\n    var clone = el.cloneNode(true);\n    Object.assign(clone.style, {\n      boxSizing: 'border-box',\n      visibility: 'hidden',\n      overflow: 'visible',\n      maxHeight: 'none',\n      display: 'block',\n      height: 'auto',\n      opacity: '0'\n    });\n    el.after(clone);\n    height = clone.offsetHeight;\n    clone.remove();\n  }\n\n  return height;\n};\nvar scrollClassToggle = function scrollClassToggle(items) {\n  if (items.length) {\n    var classToggle = function classToggle(item) {\n      var repeat = item.dataset['repeat'] != undefined;\n      var box = item.getBoundingClientRect();\n      var shift = box.height / item.dataset['shift'] || 1;\n      var over = box.bottom + shift > 0;\n      var under = box.bottom - shift - window.innerHeight < 0;\n      if (repeat || !item.classList.contains('active')) item.classList[over && under ? 'add' : 'remove']('active');\n    };\n\n    _toConsumableArray(items).forEach(function (item) {\n      window.addEventListener('scroll', function () {\n        return classToggle(item);\n      });\n      classToggle(item);\n    });\n  }\n};\nvar scrollBasedToggle = function scrollBasedToggle(sticky, items) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var current = options.current || 'current';\n  var active = options.active || 'active';\n  var first = options.first || false;\n  var name = sticky.className.split(' ')[0];\n\n  var _wrapper = document.createElement('div');\n\n  _wrapper.className = \"\".concat(name, \"-outer\");\n  sticky.parentNode.append(_wrapper);\n\n  _wrapper.append(sticky);\n\n  Object.assign(sticky.style, {\n    position: 'sticky',\n    top: 0\n  });\n\n  if (items.length) {\n    var classToggle = function classToggle(items, outer, active) {\n      var box = outer.getBoundingClientRect();\n      var step = Math.floor(Math.abs(box.top) / outer.scrollHeight * (items.length + 1));\n\n      if (box.top < 0 && box.bottom - window.innerHeight > 0) {\n        for (var i = 0; i < items.length; i++) {\n          items[i].classList[i <= step ? 'add' : 'remove'](\"\".concat(active));\n          items[i].classList.remove(\"\".concat(current));\n        }\n\n        items[step].classList.add(\"\".concat(current));\n      } else if (box.top > 0 && first) {\n        items[0].classList.remove(\"\".concat(active), \"\".concat(current));\n      }\n    };\n\n    window.addEventListener('scroll', function () {\n      return classToggle(items, _wrapper, active);\n    });\n  }\n};\nvar selectTweaker = function selectTweaker(items) {\n  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'select';\n  var text = arguments.length > 2 ? arguments[2] : undefined;\n\n  var _loop = function _loop(i) {\n    var select = items[i];\n    var options = select.querySelectorAll('option');\n\n    var _wrapper = document.createElement('div');\n\n    var _head = document.createElement('div');\n\n    var _list = document.createElement('ul');\n\n    _wrapper.className = \"\".concat(select.className, \" \").concat(name);\n    _head.className = \"\".concat(name, \"__head\");\n    _list.className = \"\".concat(name, \"__list\");\n    select.style.display = 'none';\n    select.removeAttribute('class');\n    select.parentNode.append(_wrapper);\n\n    _wrapper.append(select, _head, _list);\n\n    _head.textContent = text || options[0].textContent;\n\n    _head.addEventListener('click', function () {\n      return _wrapper.classList.toggle(\"\".concat(name, \"_opened\"));\n    });\n\n    for (var k = 0; k < options.length; k++) {\n      _list.insertAdjacentHTML('beforeend', \"<li class=\\\"\".concat(name, \"__item\\\" data-value=\\\"\").concat(options[k].value, \"\\\">\").concat(options[k].text, \"</li>\"));\n    }\n\n    _toConsumableArray(_list.children).forEach(function (item) {\n      item.addEventListener('click', function () {\n        _wrapper.classList.remove(\"\".concat(name, \"_opened\"));\n\n        _head.textContent = item.textContent;\n        select.value = item.getAttribute('data-value');\n      });\n    });\n\n    document.addEventListener('mouseup', function (e) {\n      if (!_wrapper.contains(e.target)) _wrapper.classList.remove(\"\".concat(name, \"_opened\"));\n    });\n  };\n\n  for (var i = 0; i < items.length; i++) {\n    _loop(i);\n  }\n};\nvar roughAccordion = function roughAccordion(items) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var name = options.name || 'opened';\n  var events = options.events || 'click';\n  var toggle = options.toggle;\n  events.split(' ').forEach(function (event) {\n    items.forEach(function (item) {\n      item.addEventListener(event, function (e) {\n        var _this = this;\n\n        e.stopPropagation();\n        items.forEach(function (item) {\n          return item != _this && item.classList.remove(\"\".concat(name));\n        });\n        if (this.classList != \"\".concat(name)) this.classList[toggle ? 'toggle' : 'add'](\"\".concat(name));\n      });\n    });\n  });\n};\nvar smoothAccordion = function smoothAccordion(items) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var name = options.name || 'opened';\n  var events = options.events || 'click';\n  var duration = options.duration || 400;\n  var toggle = options.toggle;\n  events.split(' ').forEach(function (event) {\n    items.forEach(function (item) {\n      item.addEventListener(event, function (e) {\n        var _this2 = this;\n\n        e.stopPropagation();\n        items.forEach(function (item) {\n          if (item != _this2) {\n            slideUp(item.nextElementSibling, duration);\n            item.classList.remove(\"\".concat(name));\n          }\n        });\n\n        if (toggle) {\n          slideToggle(item.nextElementSibling, duration);\n          this.classList.toggle(\"\".concat(name));\n        } else {\n          slideDown(item.nextElementSibling, duration);\n          this.classList.add(\"\".concat(name));\n        }\n      });\n    });\n  });\n};\nvar makeGallery = function makeGallery(items) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var cls = options.cls || 'gallery';\n  var navigation = options.navigation;\n\n  var _loop2 = function _loop2(i) {\n    var frame = items[i];\n    var images = frame.querySelectorAll('img');\n\n    var _wrapper = document.createElement('div');\n\n    var _thumbs = document.createElement('div');\n\n    _wrapper.className = \"\".concat(frame.className, \" \").concat(cls);\n    _thumbs.className = \"\".concat(cls, \"__thumbs\");\n    frame.className = \"\".concat(cls, \"__frame\");\n\n    for (var j = 0; j < images.length; j++) {\n      var active = j ? '' : 'active';\n\n      var _image = document.createElement('div');\n\n      var _thumb = document.createElement('span');\n\n      _image.className = \"\".concat(cls, \"__image \").concat(active);\n      _thumb.className = \"\".concat(cls, \"__thumb \").concat(active);\n      _thumb.style.backgroundImage = \"url(\".concat(images[j].src, \")\");\n      frame.append(_image);\n\n      _image.append(images[j]);\n\n      _thumbs.append(_thumb);\n    }\n\n    frame.parentNode.append(_wrapper);\n\n    _wrapper.append(frame, _thumbs);\n\n    if (navigation) {\n      var _prev = document.createElement('button');\n\n      var _next = document.createElement('button');\n\n      _prev.className = \"\".concat(cls, \"__prev\");\n      _next.className = \"\".concat(cls, \"__next\");\n\n      _wrapper.append(_prev, _next);\n    }\n\n    _wrapper.addEventListener('click', function (e) {\n      //   \n      var currentActive = _toConsumableArray(images).findIndex(function (el) {\n        return el.parentNode.classList.contains('active');\n      }); //   \"active\"       \n\n\n      var clearActive = function clearActive() {\n        _toConsumableArray(images).forEach(function (el) {\n          el.parentNode.classList.remove('active');\n        });\n\n        _toConsumableArray(_thumbs.children).forEach(function (el) {\n          el.classList.remove('active');\n        });\n      }; //       \n\n\n      var moveActive = function moveActive(direction) {\n        clearActive();\n        currentActive += direction;\n\n        if (currentActive >= images.length) {\n          currentActive = 0;\n        } else if (currentActive < 0) {\n          currentActive = images.length - 1;\n        }\n\n        images[currentActive].parentNode.classList.add('active');\n\n        _thumbs.children[currentActive].classList.add('active');\n      }; //    \n\n\n      if (e.target.classList.contains(\"\".concat(cls, \"__thumb\"))) {\n        clearActive();\n\n        images[_toConsumableArray(_thumbs.children).findIndex(function (el) {\n          return el == e.target;\n        })].parentNode.classList.add('active');\n\n        e.target.classList.add('active');\n      } //     \"prev\"\n\n\n      if (e.target.classList.contains(\"\".concat(cls, \"__prev\"))) moveActive(-1); //     \"next\"\n\n      if (e.target.classList.contains(\"\".concat(cls, \"__next\"))) moveActive(1);\n    });\n  };\n\n  for (var i = 0; i < items.length; i++) {\n    _loop2(i);\n  }\n};\nvar makeParallax = function makeParallax(items) {\n  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"parallax\";\n\n  var _loop3 = function _loop3(i) {\n    var item = items[i];\n\n    var _underlay = document.createElement('div');\n\n    var styles = {\n      backgroundImage: \"url(\".concat(item.dataset.image, \")\"),\n      backgroundColor: 'transparent',\n      backgroundRepeat: 'no-repeat',\n      backgroundPosition: 'center',\n      backgroundSize: 'cover',\n      position: 'absolute',\n      zIndex: 1,\n      bottom: 0,\n      right: 0,\n      left: 0,\n      top: 0\n    };\n    Object.assign(_underlay.style, styles);\n\n    _underlay.classList.add(\"\".concat(name, \"__underlay\"));\n\n    item.classList.add(\"\".concat(name));\n    item.style.position = 'relative';\n    item.style.overflow = 'hidden';\n    item.prepend(_underlay);\n\n    var translateY = function translateY() {\n      var box = item.getBoundingClientRect();\n      var speed = item.dataset.speed || 10;\n      var screen = window.innerHeight;\n\n      if (box.top < screen && box.bottom > 0) {\n        _underlay.style.top = \"\".concat((screen + box.height) / -speed, \"px\");\n        _underlay.style.transform = \"translateY(\".concat(box.bottom / speed, \"px)\");\n      }\n    };\n\n    window.addEventListener('scroll', translateY);\n    translateY();\n  };\n\n  for (var i = 0; i < items.length; i++) {\n    _loop3(i);\n  }\n};\nvar addUnderlay = function addUnderlay() {\n  var cls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'modal';\n\n  if (!document.querySelector(\"#\".concat(cls, \"__underlay\"))) {\n    var _underlay = document.createElement('div');\n\n    var _body = document.createElement('div');\n\n    var _close = document.createElement('span');\n\n    var _content = document.createElement('div');\n\n    _underlay.className = \"\".concat(cls);\n    _underlay.id = \"\".concat(cls, \"__underlay\");\n\n    _underlay.setAttribute('data-scroll-lock-scrollable', '');\n\n    _body.className = \"\".concat(cls, \"__body\");\n    _close.className = \"\".concat(cls, \"__close\");\n    _content.className = \"\".concat(cls, \"__content\");\n\n    _body.append(_close);\n\n    _body.append(_content);\n\n    _underlay.append(_body);\n\n    document.body.append(_underlay);\n  }\n};\nvar makeModalFrame = function makeModalFrame() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var scrollLock = options.scrollLock,\n      Inputmask = options.Inputmask;\n  var cls = options.cls || 'modal';\n  var modal = document.querySelector(\"#\".concat(cls, \"__underlay\"));\n  var body = modal.querySelector(\".\".concat(cls, \"__content\"));\n\n  if (modal) {\n    var close = function close(e) {\n      e.preventDefault();\n\n      if (typeof scrollLock !== 'undefined') {\n        scrollLock.clearQueueScrollLocks();\n        scrollLock.enablePageScroll();\n      }\n\n      modal.className = \"\".concat(cls);\n      modal.style.display = \"none\";\n      body.innerHTML = '';\n    };\n\n    var open = function open(e) {\n      e.preventDefault();\n      if (getComputedStyle(modal).display !== 'none') close(e);\n      var id = e.currentTarget.dataset[\"\".concat(cls)] || 'error';\n      var content = id == '#' ? e.currentTarget.innerHTML : document.querySelector('#' + id).innerHTML;\n      body.insertAdjacentHTML('beforeend', content);\n      modal.classList.add(id != '#' ? \"\".concat(cls, \"_\").concat(id) : \"\".concat(cls, \"_self\"));\n      modal.style.display = \"block\";\n      if (typeof scrollLock !== 'undefined') scrollLock.disablePageScroll();\n      if (typeof Inputmask !== 'undefined') Inputmask.mask(body.querySelectorAll('input[type=\"tel\"]'));\n    };\n\n    document.querySelectorAll(\"[data-\".concat(cls, \"]\")).forEach(function (item) {\n      item.addEventListener('click', open);\n    });\n    document.addEventListener('click', function (e) {\n      // if (e.target.hasAttribute(`data-${cls}`)) \n      // \topen(e);\n      if (e.target == modal || e.target.classList.contains(\"\".concat(cls, \"__close\"))) close(e);\n    });\n  }\n}; //   \n\nvar slideUp = function slideUp(el) {\n  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n  var cb = arguments.length > 2 ? arguments[2] : undefined;\n  if (el.style.transitionDuration && el.style.transitionProperty || window.getComputedStyle(el).display === 'none') return;\n  var set = {\n    overflow: 'hidden',\n    paddingBottom: 0,\n    marginBottom: 0,\n    paddingTop: 0,\n    marginTop: 0,\n    height: 0\n  };\n  var transition = {\n    transitionProperty: 'height, margin, padding',\n    transitionDuration: duration + 'ms',\n    height: el.offsetHeight + 'px',\n    boxSizing: 'border-box'\n  };\n  Object.assign(el.style, transition);\n  el.offsetHeight;\n  Object.assign(el.style, set);\n  window.setTimeout(function () {\n    el.removeAttribute('style');\n    el.style.display = 'none';\n    if (typeof cb === 'function') return cb.call(el);\n  }, duration);\n}; //   \n\nvar slideDown = function slideDown(el) {\n  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n  var cb = arguments.length > 2 ? arguments[2] : undefined;\n  if (el.style.transitionDuration && el.style.transitionProperty || window.getComputedStyle(el).display !== 'none') return;\n  el.style.display = 'block';\n  var set = {\n    overflow: 'hidden',\n    paddingBottom: 0,\n    marginBottom: 0,\n    paddingTop: 0,\n    marginTop: 0,\n    height: 0\n  };\n  var transition = {\n    transitionProperty: 'height, margin, padding',\n    transitionDuration: duration + 'ms',\n    height: el.offsetHeight + 'px',\n    boxSizing: 'border-box'\n  };\n  Object.assign(el.style, set);\n  el.offsetHeight;\n  Object.assign(el.style, transition);\n  el.style.removeProperty('padding-top');\n  el.style.removeProperty('padding-bottom');\n  el.style.removeProperty('margin-top');\n  el.style.removeProperty('margin-bottom');\n  window.setTimeout(function () {\n    el.style.removeProperty('box-sizing');\n    el.style.removeProperty('height');\n    el.style.removeProperty('overflow');\n    el.style.removeProperty('transition-duration');\n    el.style.removeProperty('transition-property');\n    if (typeof cb === 'function') return cb.call(el);\n  }, duration);\n}; //    \n\nvar slideToggle = function slideToggle(el, duration, cb) {\n  if (window.getComputedStyle(el).display === 'none') {\n    return slideDown(el, duration, cb);\n  } else {\n    return slideUp(el, duration, cb);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliLmpzPzQyYzQiXSwibmFtZXMiOlsiZ2V0SGVpZ2h0IiwiZWwiLCJjb21wdXRlZCIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJoZWlnaHQiLCJib3hTaXppbmciLCJvZmZzZXRIZWlnaHQiLCJwYXJzZUZsb2F0IiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckJvdHRvbVdpZHRoIiwiZGlzcGxheSIsImNsb25lTm9kZSIsImNsb25lIiwiT2JqZWN0IiwiYXNzaWduIiwic3R5bGUiLCJ2aXNpYmlsaXR5Iiwib3ZlcmZsb3ciLCJtYXhIZWlnaHQiLCJvcGFjaXR5IiwiYWZ0ZXIiLCJyZW1vdmUiLCJzY3JvbGxDbGFzc1RvZ2dsZSIsIml0ZW1zIiwibGVuZ3RoIiwiY2xhc3NUb2dnbGUiLCJpdGVtIiwicmVwZWF0IiwiZGF0YXNldCIsInVuZGVmaW5lZCIsImJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNoaWZ0Iiwib3ZlciIsImJvdHRvbSIsInVuZGVyIiwiaW5uZXJIZWlnaHQiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImZvckVhY2giLCJhZGRFdmVudExpc3RlbmVyIiwic2Nyb2xsQmFzZWRUb2dnbGUiLCJzdGlja3kiLCJvcHRpb25zIiwiY3VycmVudCIsImFjdGl2ZSIsImZpcnN0IiwibmFtZSIsImNsYXNzTmFtZSIsInNwbGl0IiwiX3dyYXBwZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJwYXJlbnROb2RlIiwiYXBwZW5kIiwicG9zaXRpb24iLCJ0b3AiLCJvdXRlciIsInN0ZXAiLCJNYXRoIiwiZmxvb3IiLCJhYnMiLCJzY3JvbGxIZWlnaHQiLCJpIiwiYWRkIiwic2VsZWN0VHdlYWtlciIsInRleHQiLCJzZWxlY3QiLCJxdWVyeVNlbGVjdG9yQWxsIiwiX2hlYWQiLCJfbGlzdCIsInJlbW92ZUF0dHJpYnV0ZSIsInRleHRDb250ZW50IiwidG9nZ2xlIiwiayIsImluc2VydEFkamFjZW50SFRNTCIsInZhbHVlIiwiY2hpbGRyZW4iLCJnZXRBdHRyaWJ1dGUiLCJlIiwidGFyZ2V0Iiwicm91Z2hBY2NvcmRpb24iLCJldmVudHMiLCJldmVudCIsInN0b3BQcm9wYWdhdGlvbiIsInNtb290aEFjY29yZGlvbiIsImR1cmF0aW9uIiwic2xpZGVVcCIsIm5leHRFbGVtZW50U2libGluZyIsInNsaWRlVG9nZ2xlIiwic2xpZGVEb3duIiwibWFrZUdhbGxlcnkiLCJjbHMiLCJuYXZpZ2F0aW9uIiwiZnJhbWUiLCJpbWFnZXMiLCJfdGh1bWJzIiwiaiIsIl9pbWFnZSIsIl90aHVtYiIsImJhY2tncm91bmRJbWFnZSIsInNyYyIsIl9wcmV2IiwiX25leHQiLCJjdXJyZW50QWN0aXZlIiwiZmluZEluZGV4IiwiY2xlYXJBY3RpdmUiLCJtb3ZlQWN0aXZlIiwiZGlyZWN0aW9uIiwibWFrZVBhcmFsbGF4IiwiX3VuZGVybGF5Iiwic3R5bGVzIiwiaW1hZ2UiLCJiYWNrZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kUmVwZWF0IiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYmFja2dyb3VuZFNpemUiLCJ6SW5kZXgiLCJyaWdodCIsImxlZnQiLCJwcmVwZW5kIiwidHJhbnNsYXRlWSIsInNwZWVkIiwic2NyZWVuIiwidHJhbnNmb3JtIiwiYWRkVW5kZXJsYXkiLCJxdWVyeVNlbGVjdG9yIiwiX2JvZHkiLCJfY2xvc2UiLCJfY29udGVudCIsImlkIiwic2V0QXR0cmlidXRlIiwiYm9keSIsIm1ha2VNb2RhbEZyYW1lIiwic2Nyb2xsTG9jayIsIklucHV0bWFzayIsIm1vZGFsIiwiY2xvc2UiLCJwcmV2ZW50RGVmYXVsdCIsImNsZWFyUXVldWVTY3JvbGxMb2NrcyIsImVuYWJsZVBhZ2VTY3JvbGwiLCJpbm5lckhUTUwiLCJvcGVuIiwiY3VycmVudFRhcmdldCIsImNvbnRlbnQiLCJkaXNhYmxlUGFnZVNjcm9sbCIsIm1hc2siLCJjYiIsInRyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsInNldCIsIm1hcmdpbkJvdHRvbSIsIm1hcmdpblRvcCIsInRyYW5zaXRpb24iLCJzZXRUaW1lb3V0IiwiY2FsbCIsInJlbW92ZVByb3BlcnR5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ08sSUFBTUEsU0FBUyxHQUFHLFNBQVpBLFNBQVksQ0FBQ0MsRUFBRCxFQUFRO0FBQ2hDLE1BQUksQ0FBQ0EsRUFBTCxFQUFTO0FBRVQsTUFBTUMsUUFBUSxHQUFHQyxNQUFNLENBQUNDLGdCQUFQLENBQXdCSCxFQUF4QixDQUFqQjtBQUNBLE1BQUlJLE1BQU0sR0FBSUgsUUFBUSxDQUFDSSxTQUFULEtBQXVCLFlBQXhCLEdBQXdDTCxFQUFFLENBQUNNLFlBQTNDLEdBQTBETixFQUFFLENBQUNNLFlBQUgsR0FBa0JDLFVBQVUsQ0FBQ04sUUFBUSxDQUFDTyxVQUFWLENBQTVCLEdBQW9ERCxVQUFVLENBQUNOLFFBQVEsQ0FBQ1EsYUFBVixDQUE5RCxHQUF5RkYsVUFBVSxDQUFDTixRQUFRLENBQUNTLGNBQVYsQ0FBbkcsR0FBK0hILFVBQVUsQ0FBQ04sUUFBUSxDQUFDVSxpQkFBVixDQUFoTjs7QUFFQSxNQUFJVixRQUFRLENBQUNHLE1BQVQsS0FBb0IsTUFBcEIsSUFBOEJILFFBQVEsQ0FBQ1csT0FBVCxLQUFxQixNQUF2RCxFQUErRDtBQUM5RCxRQUFJLEVBQUNaLEVBQUQsYUFBQ0EsRUFBRCxlQUFDQSxFQUFFLENBQUVhLFNBQUwsQ0FBSixFQUFvQixPQUFPLElBQVA7QUFFcEIsUUFBTUMsS0FBSyxHQUFHZCxFQUFFLENBQUNhLFNBQUgsQ0FBYSxJQUFiLENBQWQ7QUFFQUUsVUFBTSxDQUFDQyxNQUFQLENBQWNGLEtBQUssQ0FBQ0csS0FBcEIsRUFBMkI7QUFDMUJaLGVBQVMsRUFBRSxZQURlO0FBRTFCYSxnQkFBVSxFQUFFLFFBRmM7QUFHMUJDLGNBQVEsRUFBRSxTQUhnQjtBQUkxQkMsZUFBUyxFQUFFLE1BSmU7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TSxDQUFDMEosVUFBUCxDQUFrQixZQUFNO0FBQ3ZCNUosTUFBRSxDQUFDaUIsS0FBSCxDQUFTNkksY0FBVCxDQUF3QixZQUF4QjtBQUNBOUosTUFBRSxDQUFDaUIsS0FBSCxDQUFTNkksY0FBVCxDQUF3QixRQUF4QjtBQUNBOUosTUFBRSxDQUFDaUIsS0FBSCxDQUFTNkksY0FBVCxDQUF3QixVQUF4QjtBQUNBOUosTUFBRSxDQUFDaUIsS0FBSCxDQUFTNkksY0FBVCxDQUF3QixxQkFBeEI7QUFDQTlKLE1BQUUsQ0FBQ2lCLEtBQUgsQ0FBUzZJLGNBQVQsQ0FBd0IscUJBQXhCO0FBQ0EsUUFBSSxPQUFPVCxFQUFQLEtBQWMsVUFBbEIsRUFBOEIsT0FBT0EsRUFBRSxDQUFDUSxJQUFILENBQVE3SixFQUFSLENBQVA7QUFDOUIsR0FQRCxFQU9Hd0YsUUFQSDtBQVFBLENBdENNLEMsQ0F5Q1A7O0FBQ08sSUFBTUcsV0FBVyxHQUFHLFNBQWRBLFdBQWMsQ0FBQzNGLEVBQUQsRUFBS3dGLFFBQUwsRUFBZTZELEVBQWYsRUFBc0I7QUFDaEQsTUFBSW5KLE1BQU0sQ0FBQ0MsZ0JBQVAsQ0FBd0JILEVBQXhCLEVBQTRCWSxPQUE1QixLQUF3QyxNQUE1QyxFQUFvRDtBQUNuRCxXQUFPZ0YsU0FBUyxDQUFDNUYsRUFBRCxFQUFLd0YsUUFBTCxFQUFlNkQsRUFBZixDQUFoQjtBQUNBLEdBRkQsTUFFTztBQUNOLFdBQU81RCxPQUFPLENBQUN6RixFQUFELEVBQUt3RixRQUFMLEVBQWU2RCxFQUFmLENBQWQ7QUFDQTtBQUNELENBTk0iLCJmaWxlIjoiLi9zcmMvanMvbGliLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8g0J/QvtC70YPRh9C40YLRjCDQstGL0YHQvtGC0YMg0YHQutGA0YvRgtC+0LPQviDRjdC70LXQvNC10L3RgtCwXHJcbmV4cG9ydCBjb25zdCBnZXRIZWlnaHQgPSAoZWwpID0+IHtcclxuXHRpZiAoIWVsKSByZXR1cm47XHJcblxyXG5cdGNvbnN0IGNvbXB1dGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xyXG5cdGxldCBoZWlnaHQgPSAoY29tcHV0ZWQuYm94U2l6aW5nID09PSBcImJvcmRlci1ib3hcIikgPyBlbC5vZmZzZXRIZWlnaHQgOiBlbC5vZmZzZXRIZWlnaHQgLSBwYXJzZUZsb2F0KGNvbXB1dGVkLnBhZGRpbmdUb3ApIC0gcGFyc2VGbG9hdChjb21wdXRlZC5wYWRkaW5nQm90dG9tKSAtIHBhcnNlRmxvYXQoY29tcHV0ZWQuYm9yZGVyVG9wV2lkdGgpIC0gcGFyc2VGbG9hdChjb21wdXRlZC5ib3JkZXJCb3R0b21XaWR0aCk7XHJcblxyXG5cdGlmIChjb21wdXRlZC5oZWlnaHQgPT09ICdhdXRvJyAmJiBjb21wdXRlZC5kaXNwbGF5ID09PSAnbm9uZScpIHtcclxuXHRcdGlmICghZWw/LmNsb25lTm9kZSkgcmV0dXJuIG51bGw7XHJcblx0XHRcclxuXHRcdGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKHRydWUpO1xyXG5cdFx0XHJcblx0XHRPYmplY3QuYXNzaWduKGNsb25lLnN0eWxlLCB7XHJcblx0XHRcdGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxyXG5cdFx0XHR2aXNpYmlsaXR5OiAnaGlkZGVuJyxcclxuXHRcdFx0b3ZlcmZsb3c6ICd2aXNpYmxlJyxcclxuXHRcdFx0bWF4SGVpZ2h0OiAnbm9uZScsXHJcblx0XHRcdGRpc3BsYXk6ICdibG9jaycsXHJcblx0XHRcdGhlaWdodDogJ2F1dG8nLFxyXG5cdFx0XHRvcGFjaXR5OiAnMCcsXHJcblx0XHR9KTtcclxuXHRcdFxyXG5cdFx0ZWwuYWZ0ZXIoY2xvbmUpO1xyXG5cdFx0aGVpZ2h0ID0gY2xvbmUub2Zmc2V0SGVpZ2h0O1xyXG5cdFx0Y2xvbmUucmVtb3ZlKCk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gaGVpZ2h0O1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IHNjcm9sbENsYXNzVG9nZ2xlID0gKGl0ZW1zKSA9PiB7XHJcblx0aWYgKGl0ZW1zLmxlbmd0aCkge1xyXG5cdFx0Y29uc3QgY2xhc3NUb2dnbGUgPSAoaXRlbSkgPT4ge1xyXG5cdFx0XHRjb25zdCByZXBlYXQgPSBpdGVtLmRhdGFzZXRbJ3JlcGVhdCddICE9IHVuZGVmaW5lZDtcclxuXHRcdFx0Y29uc3QgYm94ID0gaXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHRcdFx0Y29uc3Qgc2hpZnQgPSBib3guaGVpZ2h0L2l0ZW0uZGF0YXNldFsnc2hpZnQnXSB8fCAxO1xyXG5cdFx0XHRjb25zdCBvdmVyID0gYm94LmJvdHRvbSArIHNoaWZ0ID4gMDtcclxuXHRcdFx0Y29uc3QgdW5kZXIgPSBib3guYm90dG9tIC0gc2hpZnQgLSB3aW5kb3cuaW5uZXJIZWlnaHQgPCAwO1xyXG5cdFxyXG5cdFx0XHRpZiAocmVwZWF0IHx8ICFpdGVtLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpXHJcblx0XHRcdFx0aXRlbS5jbGFzc0xpc3RbKG92ZXIgJiYgdW5kZXIpID8gJ2FkZCc6ICdyZW1vdmUnXSgnYWN0aXZlJyk7XHJcblx0XHR9O1xyXG5cdFx0XHJcblx0XHRbLi4uaXRlbXNdLmZvckVhY2goaXRlbSA9PiB7XHJcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCAoKSA9PiBjbGFzc1RvZ2dsZShpdGVtKSk7XHJcblx0XHRcdGNsYXNzVG9nZ2xlKGl0ZW0pO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IHNjcm9sbEJhc2VkVG9nZ2xlID0gKHN0aWNreSwgaXRlbXMsIG9wdGlvbnMgPSB7fSkgPT4ge1xyXG5cdGNvbnN0IGN1cnJlbnQgPSBvcHRpb25zLmN1cnJlbnQgfHwgJ2N1cnJlbnQnO1xyXG5cdGNvbnN0IGFjdGl2ZSA9IG9wdGlvbnMuYWN0aXZlIHx8ICdhY3RpdmUnO1xyXG5cdGNvbnN0IGZpcnN0ID0gb3B0aW9ucy5maXJzdCB8fCBmYWxzZTtcclxuXHRjb25zdCBuYW1lID0gc3RpY2t5LmNsYXNzTmFtZS5zcGxpdCgnICcpWzBdO1xyXG5cdGNvbnN0IF93cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG5cdF93cmFwcGVyLmNsYXNzTmFtZSA9IGAke25hbWV9LW91dGVyYDtcclxuXHRzdGlja3kucGFyZW50Tm9kZS5hcHBlbmQoX3dyYXBwZXIpO1xyXG5cdF93cmFwcGVyLmFwcGVuZChzdGlja3kpO1xyXG5cclxuXHRPYmplY3QuYXNzaWduKHN0aWNreS5zdHlsZSwge1xyXG5cdFx0cG9zaXRpb246ICdzdGlja3knLFxyXG5cdFx0dG9wOiAwXHJcblx0fSk7XHJcblxyXG5cdGlmIChpdGVtcy5sZW5ndGgpIHtcclxuXHRcdGNvbnN0IGNsYXNzVG9nZ2xlID0gKGl0ZW1zLCBvdXRlciwgYWN0aXZlKSA9PiB7XHJcblx0XHRcdGNvbnN0IGJveCA9IG91dGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cdFx0XHRjb25zdCBzdGVwID0gTWF0aC5mbG9vcihNYXRoLmFicyhib3gudG9wKSAvIG91dGVyLnNjcm9sbEhlaWdodCAqIChpdGVtcy5sZW5ndGggKyAxKSk7XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoYm94LnRvcCA8IDAgJiYgYm94LmJvdHRvbSAtIHdpbmRvdy5pbm5lckhlaWdodCA+IDApIHtcclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRpdGVtc1tpXS5jbGFzc0xpc3RbKGkgPD0gc3RlcCkgPyAnYWRkJzoncmVtb3ZlJ10oYCR7YWN0aXZlfWApO1xyXG5cdFx0XHRcdFx0aXRlbXNbaV0uY2xhc3NMaXN0LnJlbW92ZShgJHtjdXJyZW50fWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpdGVtc1tzdGVwXS5jbGFzc0xpc3QuYWRkKGAke2N1cnJlbnR9YCk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKGJveC50b3AgPiAwICYmIGZpcnN0KSB7XHJcblx0XHRcdFx0aXRlbXNbMF0uY2xhc3NMaXN0LnJlbW92ZShgJHthY3RpdmV9YCwgYCR7Y3VycmVudH1gKTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHRcdFxyXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsICgpID0+IGNsYXNzVG9nZ2xlKGl0ZW1zLCBfd3JhcHBlciwgYWN0aXZlKSk7XHJcblx0fVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IHNlbGVjdFR3ZWFrZXIgPSAoaXRlbXMsIG5hbWUgPSAnc2VsZWN0JywgdGV4dCkgPT4ge1xyXG5cclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRjb25zdCBzZWxlY3QgPSBpdGVtc1tpXTtcclxuXHRcdGNvbnN0IG9wdGlvbnMgPSBzZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnb3B0aW9uJyk7XHJcblx0XHRjb25zdCBfd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0Y29uc3QgX2hlYWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdGNvbnN0IF9saXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcclxuXHRcdFxyXG5cdFx0X3dyYXBwZXIuY2xhc3NOYW1lID0gYCR7c2VsZWN0LmNsYXNzTmFtZX0gJHtuYW1lfWA7XHJcblx0XHRfaGVhZC5jbGFzc05hbWUgPSBgJHtuYW1lfV9faGVhZGA7XHJcblx0XHRfbGlzdC5jbGFzc05hbWUgPSBgJHtuYW1lfV9fbGlzdGA7XHJcblxyXG5cdFx0c2VsZWN0LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblx0XHRzZWxlY3QucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xyXG5cdFx0c2VsZWN0LnBhcmVudE5vZGUuYXBwZW5kKF93cmFwcGVyKTtcclxuXHRcdF93cmFwcGVyLmFwcGVuZChzZWxlY3QsIF9oZWFkLCBfbGlzdCk7XHJcblx0XHRcclxuXHRcdF9oZWFkLnRleHRDb250ZW50ID0gdGV4dCB8fCBvcHRpb25zWzBdLnRleHRDb250ZW50O1xyXG5cdFx0X2hlYWQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBfd3JhcHBlci5jbGFzc0xpc3QudG9nZ2xlKGAke25hbWV9X29wZW5lZGApKTtcclxuXHJcblx0XHRmb3IgKGxldCBrID0gMDsgayA8IG9wdGlvbnMubGVuZ3RoOyBrKyspIHtcclxuXHRcdFx0X2xpc3QuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBgPGxpIGNsYXNzPVwiJHtuYW1lfV9faXRlbVwiIGRhdGEtdmFsdWU9XCIke29wdGlvbnNba10udmFsdWV9XCI+JHtvcHRpb25zW2tdLnRleHR9PC9saT5gKTtcclxuXHRcdH1cclxuXHJcblx0XHRbLi4uX2xpc3QuY2hpbGRyZW5dLmZvckVhY2goaXRlbSA9PiB7XHJcblx0XHRcdGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcblx0XHRcdFx0X3dyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShgJHtuYW1lfV9vcGVuZWRgKTtcclxuXHRcdFx0XHRfaGVhZC50ZXh0Q29udGVudCA9IGl0ZW0udGV4dENvbnRlbnQ7XHJcblx0XHRcdFx0c2VsZWN0LnZhbHVlID0gaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZSA9PiB7IFxyXG5cdFx0XHRpZiAoIV93cmFwcGVyLmNvbnRhaW5zKGUudGFyZ2V0KSkgXHJcblx0XHRcdFx0X3dyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShgJHtuYW1lfV9vcGVuZWRgKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCByb3VnaEFjY29yZGlvbiA9IChpdGVtcywgb3B0aW9ucyA9IHt9KSA9PiB7XHJcblx0Y29uc3QgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCAnb3BlbmVkJztcclxuXHRjb25zdCBldmVudHMgPSBvcHRpb25zLmV2ZW50cyB8fCAnY2xpY2snO1xyXG5cdGNvbnN0IHRvZ2dsZSA9IG9wdGlvbnMudG9nZ2xlO1xyXG5cdFxyXG5cdGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZXZlbnQgPT4ge1xyXG5cdFx0aXRlbXMuZm9yRWFjaChpdGVtID0+IHtcclxuXHRcdFx0aXRlbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jdGlvbihlKSB7XHJcblx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcdFx0XHRpdGVtcy5mb3JFYWNoKGl0ZW0gPT4gKGl0ZW0gIT0gdGhpcykgJiYgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKGAke25hbWV9YCkpO1xyXG5cdFx0XHRcclxuXHRcdFx0XHRpZiAodGhpcy5jbGFzc0xpc3QgIT0gYCR7bmFtZX1gKVxyXG5cdFx0XHRcdFx0dGhpcy5jbGFzc0xpc3RbKHRvZ2dsZSkgPyAndG9nZ2xlJzonYWRkJ10oYCR7bmFtZX1gKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9KTtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBzbW9vdGhBY2NvcmRpb24gPSBmdW5jdGlvbihpdGVtcywgb3B0aW9ucyA9IHt9KSB7XHJcblx0Y29uc3QgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCAnb3BlbmVkJztcclxuXHRjb25zdCBldmVudHMgPSBvcHRpb25zLmV2ZW50cyB8fCAnY2xpY2snO1xyXG5cdGNvbnN0IGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiB8fCA0MDA7XHJcblx0Y29uc3QgdG9nZ2xlID0gb3B0aW9ucy50b2dnbGU7XHJcblxyXG5cdGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZXZlbnQgPT4ge1xyXG5cdFx0aXRlbXMuZm9yRWFjaChpdGVtID0+IHtcclxuXHRcdFx0aXRlbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jdGlvbihlKSB7XHJcblx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcblx0XHRcdFx0aXRlbXMuZm9yRWFjaChpdGVtID0+IHtcclxuXHRcdFx0XHRcdGlmIChpdGVtICE9IHRoaXMpIHtcclxuXHRcdFx0XHRcdFx0c2xpZGVVcChpdGVtLm5leHRFbGVtZW50U2libGluZywgZHVyYXRpb24pO1xyXG5cdFx0XHRcdFx0XHRpdGVtLmNsYXNzTGlzdC5yZW1vdmUoYCR7bmFtZX1gKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0aWYgKHRvZ2dsZSkge1xyXG5cdFx0XHRcdFx0c2xpZGVUb2dnbGUoaXRlbS5uZXh0RWxlbWVudFNpYmxpbmcsIGR1cmF0aW9uKTtcclxuXHRcdFx0XHRcdHRoaXMuY2xhc3NMaXN0LnRvZ2dsZShgJHtuYW1lfWApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzbGlkZURvd24oaXRlbS5uZXh0RWxlbWVudFNpYmxpbmcsIGR1cmF0aW9uKTtcclxuXHRcdFx0XHRcdHRoaXMuY2xhc3NMaXN0LmFkZChgJHtuYW1lfWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSlcclxuXHRcdH0pXHJcblx0fSk7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgY29uc3QgbWFrZUdhbGxlcnkgPSAoaXRlbXMsIG9wdGlvbnMgPSB7fSkgPT4ge1xyXG5cdGNvbnN0IGNscyA9IG9wdGlvbnMuY2xzIHx8ICdnYWxsZXJ5JztcclxuXHRjb25zdCBuYXZpZ2F0aW9uID0gb3B0aW9ucy5uYXZpZ2F0aW9uO1xyXG5cclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRjb25zdCBmcmFtZSA9IGl0ZW1zW2ldO1xyXG5cdFx0Y29uc3QgaW1hZ2VzID0gZnJhbWUucXVlcnlTZWxlY3RvckFsbCgnaW1nJyk7XHJcblx0XHRjb25zdCBfd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0Y29uc3QgX3RodW1icyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0XHJcblx0XHRfd3JhcHBlci5jbGFzc05hbWUgPSBgJHtmcmFtZS5jbGFzc05hbWV9ICR7Y2xzfWA7XHJcblx0XHRfdGh1bWJzLmNsYXNzTmFtZSA9IGAke2Nsc31fX3RodW1ic2A7XHJcblx0XHRmcmFtZS5jbGFzc05hbWUgPSBgJHtjbHN9X19mcmFtZWA7XHJcblx0XHRcclxuXHRcdGZvciAobGV0IGogPSAwOyBqIDwgaW1hZ2VzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdGxldCBhY3RpdmUgPSBqID8gJyc6J2FjdGl2ZSc7XHJcblx0XHRcdGxldCBfaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdFx0bGV0IF90aHVtYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuXHRcdFx0X2ltYWdlLmNsYXNzTmFtZSA9IGAke2Nsc31fX2ltYWdlICR7YWN0aXZlfWA7XHJcblx0XHRcdF90aHVtYi5jbGFzc05hbWUgPSBgJHtjbHN9X190aHVtYiAke2FjdGl2ZX1gO1xyXG5cdFx0XHRfdGh1bWIuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgke2ltYWdlc1tqXS5zcmN9KWA7XHJcblx0XHRcdGZyYW1lLmFwcGVuZChfaW1hZ2UpO1xyXG5cdFx0XHRfaW1hZ2UuYXBwZW5kKGltYWdlc1tqXSk7XHJcblx0XHRcdF90aHVtYnMuYXBwZW5kKF90aHVtYik7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnJhbWUucGFyZW50Tm9kZS5hcHBlbmQoX3dyYXBwZXIpO1xyXG5cdFx0X3dyYXBwZXIuYXBwZW5kKGZyYW1lLCBfdGh1bWJzKTtcclxuXHJcblx0XHRpZiAobmF2aWdhdGlvbikge1xyXG5cdFx0XHRjb25zdCBfcHJldiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xyXG5cdFx0XHRjb25zdCBfbmV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xyXG5cdFx0XHRfcHJldi5jbGFzc05hbWUgPSBgJHtjbHN9X19wcmV2YDtcclxuXHRcdFx0X25leHQuY2xhc3NOYW1lID0gYCR7Y2xzfV9fbmV4dGA7XHJcblx0XHRcdF93cmFwcGVyLmFwcGVuZChfcHJldiwgX25leHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdF93cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG5cdFx0XHQvLyDQuNC90LTQtdC60YEg0LDQutGC0LjQstC90L7Qs9C+INGB0LvQsNC50LTQsFxyXG5cdFx0XHRsZXQgY3VycmVudEFjdGl2ZSA9IFsuLi5pbWFnZXNdLmZpbmRJbmRleChlbCA9PiBlbC5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpO1xyXG5cclxuXHRcdFx0Ly8g0YPQsdGA0LDRgtGMINC60LvQsNGB0YEgXCJhY3RpdmVcIiDRgyDQstGB0LXRhSDRgdC70LDQudC00L7QsiDQuCDRgyDQstGB0LXRhSDQv9GA0LXQstGM0Y7RiNC10LpcclxuXHRcdFx0bGV0IGNsZWFyQWN0aXZlID0gKCkgPT4ge1xyXG5cdFx0XHRcdFsuLi5pbWFnZXNdLmZvckVhY2goKGVsKSA9PiB7IGVsLnBhcmVudE5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJykgfSk7XHJcblx0XHRcdFx0Wy4uLl90aHVtYnMuY2hpbGRyZW5dLmZvckVhY2goKGVsKSA9PiB7IGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpIH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyDRgdC00LLQuNC90YPRgtGMINC40L3QtNC10LrRgSDQsNC60YLQuNCy0L3QvtCz0L4g0YHQu9Cw0LnQtNCwINCyINC30LDQtNCw0L3QvdC+0Lwg0L3QsNC/0YDQsNCy0LvQtdC90LjQuFxyXG5cdFx0XHRsZXQgbW92ZUFjdGl2ZSA9IChkaXJlY3Rpb24pID0+IHtcclxuXHRcdFx0XHRjbGVhckFjdGl2ZSgpO1xyXG5cdFx0XHRcdGN1cnJlbnRBY3RpdmUgKz0gZGlyZWN0aW9uO1xyXG5cclxuXHRcdFx0XHRpZiAoY3VycmVudEFjdGl2ZSA+PSBpbWFnZXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRjdXJyZW50QWN0aXZlID0gMDtcclxuXHRcdFx0XHR9IGVsc2UgaWYoY3VycmVudEFjdGl2ZSA8IDApIHtcclxuXHRcdFx0XHRcdGN1cnJlbnRBY3RpdmUgPSBpbWFnZXMubGVuZ3RoIC0gMTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGltYWdlc1tjdXJyZW50QWN0aXZlXS5wYXJlbnROb2RlLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpXHJcblx0XHRcdFx0X3RodW1icy5jaGlsZHJlbltjdXJyZW50QWN0aXZlXS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8g0LXRgdC70Lgg0LrQu9C40Log0L/QviDQv9GA0LXQstGM0Y7RiNC60LVcclxuXHRcdFx0aWYoZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGAke2Nsc31fX3RodW1iYCkpIHtcclxuXHRcdFx0XHRjbGVhckFjdGl2ZSgpO1xyXG5cdFx0XHRcdGltYWdlc1tbLi4uX3RodW1icy5jaGlsZHJlbl0uZmluZEluZGV4KGVsID0+IGVsID09IGUudGFyZ2V0KV0ucGFyZW50Tm9kZS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcclxuXHRcdFx0XHRlLnRhcmdldC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8g0LXRgdC70Lgg0LrQu9C40Log0L/QviDQutC90L7Qv9C60LUgXCJwcmV2XCJcclxuXHRcdFx0aWYgKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhgJHtjbHN9X19wcmV2YCkpXHJcblx0XHRcdFx0bW92ZUFjdGl2ZSgtMSk7XHJcblxyXG5cdFx0XHQvLyDQtdGB0LvQuCDQutC70LjQuiDQv9C+INC60L3QvtC/0LrQtSBcIm5leHRcIlxyXG5cdFx0XHRpZiAoZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGAke2Nsc31fX25leHRgKSlcclxuXHRcdFx0XHRtb3ZlQWN0aXZlKDEpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IG1ha2VQYXJhbGxheCA9IChpdGVtcywgbmFtZSA9IFwicGFyYWxsYXhcIikgPT4ge1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcclxuXHRcdGNvbnN0IF91bmRlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0Y29uc3Qgc3R5bGVzID0ge1xyXG5cdFx0XHRiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJHtpdGVtLmRhdGFzZXQuaW1hZ2V9KWAsXHJcblx0XHRcdGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcclxuXHRcdFx0YmFja2dyb3VuZFJlcGVhdDogJ25vLXJlcGVhdCcsXHJcblx0XHRcdGJhY2tncm91bmRQb3NpdGlvbjogJ2NlbnRlcicsXHJcblx0XHRcdGJhY2tncm91bmRTaXplOiAnY292ZXInLFxyXG5cdFx0XHRwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuXHRcdFx0ekluZGV4OiAxLFxyXG5cdFx0XHRib3R0b206IDAsXHJcblx0XHRcdHJpZ2h0OiAwLFxyXG5cdFx0XHRsZWZ0OiAwLFxyXG5cdFx0XHR0b3A6IDAsXHJcblx0XHR9XHJcblxyXG5cdFx0T2JqZWN0LmFzc2lnbihfdW5kZXJsYXkuc3R5bGUsIHN0eWxlcyk7XHJcblx0XHRfdW5kZXJsYXkuY2xhc3NMaXN0LmFkZChgJHtuYW1lfV9fdW5kZXJsYXlgKTtcclxuXHJcblx0XHRpdGVtLmNsYXNzTGlzdC5hZGQoYCR7bmFtZX1gKTtcclxuXHRcdGl0ZW0uc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG5cdFx0aXRlbS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xyXG5cdFx0aXRlbS5wcmVwZW5kKF91bmRlcmxheSk7XHJcblxyXG5cdFx0Y29uc3QgdHJhbnNsYXRlWSA9ICgpID0+IHtcclxuXHRcdFx0Y29uc3QgYm94ID0gaXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHRcdFx0Y29uc3Qgc3BlZWQgPSBpdGVtLmRhdGFzZXQuc3BlZWQgfHwgMTA7XHJcblx0XHRcdGNvbnN0IHNjcmVlbiA9IHdpbmRvdy5pbm5lckhlaWdodDtcclxuXHRcdFx0XHJcblx0XHRcdGlmICgoYm94LnRvcCA8IHNjcmVlbikgJiYgKGJveC5ib3R0b20gPiAwKSkge1xyXG5cdFx0XHRcdF91bmRlcmxheS5zdHlsZS50b3AgPSBgJHsoc2NyZWVuICsgYm94LmhlaWdodCkgLyAtc3BlZWR9cHhgO1xyXG5cdFx0XHRcdF91bmRlcmxheS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWSgke2JveC5ib3R0b20gLyBzcGVlZH1weClgO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRyYW5zbGF0ZVkpO1xyXG5cdFx0dHJhbnNsYXRlWSgpO1xyXG5cdH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBhZGRVbmRlcmxheSA9IGZ1bmN0aW9uKGNscyA9ICdtb2RhbCcpIHtcclxuXHRpZighIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke2Nsc31fX3VuZGVybGF5YCkpIHtcclxuXHRcdGNvbnN0IF91bmRlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0Y29uc3QgX2JvZHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdGNvbnN0IF9jbG9zZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuXHRcdGNvbnN0IF9jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRcclxuXHRcdF91bmRlcmxheS5jbGFzc05hbWUgPSBgJHtjbHN9YDtcclxuXHRcdF91bmRlcmxheS5pZCA9IGAke2Nsc31fX3VuZGVybGF5YDtcclxuXHRcdF91bmRlcmxheS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2Nyb2xsLWxvY2stc2Nyb2xsYWJsZScsICcnKTtcclxuXHRcdF9ib2R5LmNsYXNzTmFtZSA9IGAke2Nsc31fX2JvZHlgO1xyXG5cdFx0X2Nsb3NlLmNsYXNzTmFtZSA9IGAke2Nsc31fX2Nsb3NlYDtcclxuXHRcdF9jb250ZW50LmNsYXNzTmFtZSA9IGAke2Nsc31fX2NvbnRlbnRgO1xyXG5cclxuXHRcdF9ib2R5LmFwcGVuZChfY2xvc2UpO1xyXG5cdFx0X2JvZHkuYXBwZW5kKF9jb250ZW50KTtcclxuXHRcdF91bmRlcmxheS5hcHBlbmQoX2JvZHkpO1xyXG5cdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmQoX3VuZGVybGF5KTtcclxuXHR9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgY29uc3QgbWFrZU1vZGFsRnJhbWUgPSBmdW5jdGlvbihvcHRpb25zID0ge30pIHtcclxuXHRjb25zdCB7IHNjcm9sbExvY2ssIElucHV0bWFzayB9ID0gb3B0aW9ucztcclxuXHRjb25zdCBjbHMgPSBvcHRpb25zLmNscyB8fCAnbW9kYWwnO1xyXG5cclxuXHRjb25zdCBtb2RhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke2Nsc31fX3VuZGVybGF5YCk7XHJcblx0Y29uc3QgYm9keSA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoYC4ke2Nsc31fX2NvbnRlbnRgKTtcclxuXHRcclxuXHRpZiAobW9kYWwpIHtcclxuXHRcdGNvbnN0IGNsb3NlID0gZnVuY3Rpb24oZSkge1xyXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0XHRpZih0eXBlb2Ygc2Nyb2xsTG9jayAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRzY3JvbGxMb2NrLmNsZWFyUXVldWVTY3JvbGxMb2NrcygpO1xyXG5cdFx0XHRcdHNjcm9sbExvY2suZW5hYmxlUGFnZVNjcm9sbCgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtb2RhbC5jbGFzc05hbWUgPSBgJHtjbHN9YDtcclxuXHRcdFx0bW9kYWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG5cdFx0XHRib2R5LmlubmVySFRNTCA9ICcnO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG9wZW4gPSBmdW5jdGlvbihlKSB7XHJcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcblx0XHRcdGlmIChnZXRDb21wdXRlZFN0eWxlKG1vZGFsKS5kaXNwbGF5ICE9PSAnbm9uZScpIFxyXG5cdFx0XHRcdGNsb3NlKGUpO1xyXG5cclxuXHRcdFx0Y29uc3QgaWQgPSBlLmN1cnJlbnRUYXJnZXQuZGF0YXNldFtgJHtjbHN9YF0gfHwgJ2Vycm9yJztcclxuXHRcdFx0Y29uc3QgY29udGVudCA9IChpZCA9PSAnIycpID8gZS5jdXJyZW50VGFyZ2V0LmlubmVySFRNTCA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgaWQpLmlubmVySFRNTDtcclxuXHJcblx0XHRcdGJvZHkuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBjb250ZW50KTtcclxuXHRcdFx0bW9kYWwuY2xhc3NMaXN0LmFkZChpZCAhPSAnIycgPyBgJHtjbHN9XyR7aWR9YDpgJHtjbHN9X3NlbGZgKTtcclxuXHRcdFx0bW9kYWwuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuXHJcblx0XHRcdGlmKHR5cGVvZiBzY3JvbGxMb2NrICE9PSAndW5kZWZpbmVkJylcclxuXHRcdFx0XHRzY3JvbGxMb2NrLmRpc2FibGVQYWdlU2Nyb2xsKCk7XHJcblx0XHRcdFxyXG5cdFx0XHRpZih0eXBlb2YgSW5wdXRtYXNrICE9PSAndW5kZWZpbmVkJykgXHJcblx0XHRcdFx0SW5wdXRtYXNrLm1hc2soYm9keS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwidGVsXCJdJykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLSR7Y2xzfV1gKS5mb3JFYWNoKGl0ZW0gPT4ge1xyXG5cdFx0XHRpdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb3Blbik7XHJcblx0XHR9KTtcclxuXHJcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XHJcblx0XHRcdC8vIGlmIChlLnRhcmdldC5oYXNBdHRyaWJ1dGUoYGRhdGEtJHtjbHN9YCkpIFxyXG5cdFx0XHQvLyBcdG9wZW4oZSk7XHJcblx0XHRcdGlmIChlLnRhcmdldCA9PSBtb2RhbCB8fCBlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoYCR7Y2xzfV9fY2xvc2VgKSlcclxuXHRcdFx0XHRjbG9zZShlKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufVxyXG5cclxuXHJcbi8vINCf0LvQsNCy0L3QviDRgdC60YDRi9GC0Ywg0Y3Qu9C10LzQtdC90YJcclxuZXhwb3J0IGNvbnN0IHNsaWRlVXAgPSAoZWwsIGR1cmF0aW9uID0gNTAwLCBjYikgPT4ge1xyXG5cdGlmICgoZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uICYmIGVsLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSkgfHwgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmRpc3BsYXkgPT09ICdub25lJykgcmV0dXJuO1xyXG5cclxuXHRjb25zdCBzZXQgPSB7XHJcblx0XHRvdmVyZmxvdzogJ2hpZGRlbicsXHJcblx0XHRwYWRkaW5nQm90dG9tOiAwLFxyXG5cdFx0bWFyZ2luQm90dG9tOiAwLFxyXG5cdFx0cGFkZGluZ1RvcDogMCxcclxuXHRcdG1hcmdpblRvcDogMCxcclxuXHRcdGhlaWdodDogMFxyXG5cdH1cclxuXHRcclxuXHRjb25zdCB0cmFuc2l0aW9uID0ge1xyXG5cdFx0dHJhbnNpdGlvblByb3BlcnR5OiAnaGVpZ2h0LCBtYXJnaW4sIHBhZGRpbmcnLFxyXG5cdFx0dHJhbnNpdGlvbkR1cmF0aW9uOiBkdXJhdGlvbiArICdtcycsXHJcblx0XHRoZWlnaHQ6IGVsLm9mZnNldEhlaWdodCArICdweCcsXHJcblx0XHRib3hTaXppbmc6ICdib3JkZXItYm94JyxcclxuXHR9XHJcblx0XHRcclxuXHRPYmplY3QuYXNzaWduKGVsLnN0eWxlLCB0cmFuc2l0aW9uKTtcclxuXHRlbC5vZmZzZXRIZWlnaHQ7XHJcblx0T2JqZWN0LmFzc2lnbihlbC5zdHlsZSwgc2V0KTtcclxuXHJcblx0d2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG5cdFx0ZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xyXG5cdFx0ZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHRcdGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHJldHVybiBjYi5jYWxsKGVsKTtcclxuXHR9LCBkdXJhdGlvbik7XHJcbn1cclxuXHJcblxyXG4vLyDQn9C70LDQstC90L4g0L/QvtC60LDQt9Cw0YLRjCDRjdC70LXQvNC10L3RglxyXG5leHBvcnQgY29uc3Qgc2xpZGVEb3duID0gKGVsLCBkdXJhdGlvbiA9IDUwMCwgY2IpID0+IHtcclxuXHRpZiAoKGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiAmJiBlbC5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkpIHx8IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5kaXNwbGF5ICE9PSAnbm9uZScpIHJldHVybjtcclxuXHJcblx0ZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcblxyXG5cdGNvbnN0IHNldCA9IHtcclxuXHRcdG92ZXJmbG93OiAnaGlkZGVuJyxcclxuXHRcdHBhZGRpbmdCb3R0b206IDAsXHJcblx0XHRtYXJnaW5Cb3R0b206IDAsXHJcblx0XHRwYWRkaW5nVG9wOiAwLFxyXG5cdFx0bWFyZ2luVG9wOiAwLFxyXG5cdFx0aGVpZ2h0OiAwXHJcblx0fVxyXG5cdFxyXG5cdGNvbnN0IHRyYW5zaXRpb24gPSB7XHJcblx0XHR0cmFuc2l0aW9uUHJvcGVydHk6ICdoZWlnaHQsIG1hcmdpbiwgcGFkZGluZycsXHJcblx0XHR0cmFuc2l0aW9uRHVyYXRpb246IGR1cmF0aW9uICsgJ21zJyxcclxuXHRcdGhlaWdodDogZWwub2Zmc2V0SGVpZ2h0ICsgJ3B4JyxcclxuXHRcdGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbihlbC5zdHlsZSwgc2V0KTtcclxuXHRlbC5vZmZzZXRIZWlnaHQ7XHJcblx0T2JqZWN0LmFzc2lnbihlbC5zdHlsZSwgdHJhbnNpdGlvbik7XHJcblxyXG5cdGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdwYWRkaW5nLXRvcCcpO1xyXG5cdGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdwYWRkaW5nLWJvdHRvbScpO1xyXG5cdGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdtYXJnaW4tdG9wJyk7XHJcblx0ZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ21hcmdpbi1ib3R0b20nKTtcclxuXHJcblx0d2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG5cdFx0ZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2JveC1zaXppbmcnKTtcclxuXHRcdGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdoZWlnaHQnKTtcclxuXHRcdGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdvdmVyZmxvdycpO1xyXG5cdFx0ZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3RyYW5zaXRpb24tZHVyYXRpb24nKTtcclxuXHRcdGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCd0cmFuc2l0aW9uLXByb3BlcnR5Jyk7XHJcblx0XHRpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSByZXR1cm4gY2IuY2FsbChlbCk7XHJcblx0fSwgZHVyYXRpb24pO1xyXG59XHJcblxyXG5cclxuLy8g0J/Qu9Cw0LLQvdC+INC/0LXRgNC10LrQu9GO0YfQuNGC0Ywg0L7RgtC+0LHRgNCw0LbQtdC90LjQtSDRjdC70LXQvNC10L3RgtCwXHJcbmV4cG9ydCBjb25zdCBzbGlkZVRvZ2dsZSA9IChlbCwgZHVyYXRpb24sIGNiKSA9PiB7XHJcblx0aWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5kaXNwbGF5ID09PSAnbm9uZScpIHtcclxuXHRcdHJldHVybiBzbGlkZURvd24oZWwsIGR1cmF0aW9uLCBjYik7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBzbGlkZVVwKGVsLCBkdXJhdGlvbiwgY2IpO1xyXG5cdH1cclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/lib.js\n");

/***/ })

/******/ });